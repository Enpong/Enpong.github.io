<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis与Memcached]]></title>
    <url>%2F2019%2F05%2F06%2FRedis%E4%B8%8EMemcached%2F</url>
    <content type="text"><![CDATA[两者都是内存键值对数据库。 数据类型Memcached 只支持字符串类型； Redis 支持5种不同数据类型，字符串对象、列表对象、哈希对象、集合对象、有序集合对象。 分布式Memcacahed 不支持分布式，只能通过客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式支持。 数据持久化Memcached 不支持持久化； Redis 有两种持久化策略：RDB、AOF。 内存管理机制 在 Redis 中，并不是所有数据都一直存在内存中，可以将一些很久没用的 value 交换到磁盘，而Memcached 的数据一直在内存中； Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是内存利用率不高]]></content>
      <categories>
        <category>后端</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持久化]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[持久化Redis 是内存型数据库，为了保证在断电之后数据不会丢失，需要将内存的数据持久化到硬盘上。 RDB 持久化将某个时间点的所有数据都存到硬盘上。 可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。 如果系统发生崩溃，将会丢失最后一次创建快照之后的数据。 如果数据量很大的话，保存快照的时间很长。 AOF 持久化将写命令添加到 AOF 文件的末尾 使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。 选项中由 always、everysec、no，决定服务器性能和丢失的数据量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。]]></content>
      <categories>
        <category>后端</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis使用场景]]></title>
    <url>%2F2019%2F05%2F06%2FRedis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[计数器可以对 String 进行自增自减运算，从而实现计数器功能。 Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存将热点数据放到内存中： 设置内存的最大使用量以及淘汰策略来保证缓存的命中率； 通过设置过期时间来实现缓存的过期失效。 查找表例如 DNS 记录就很适合使用 Redis 来存储。 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 消息队列List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息 不过最好使用 Kafka、RabbitMQ 等消息中间件。 会话缓存可以使用 Redis 来统一存储多台应用服务器的会话信息。 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 分布式锁在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程同步。 可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其他Set 可以实现交集、并集等操作，从而实现共同好友等功能； ZSet 可以实现有序性操作，从而实现排行榜等功能]]></content>
      <categories>
        <category>后端</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构及对象]]></title>
    <url>%2F2019%2F05%2F06%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象（数据类型）redis数据库存储的是一个个键值对(key-value)，每个键值对都是由对象组成 键总是一个字符串对象 值可以是字符串对象(string)、列表对象(list)、哈希对象(hash)、集合对象(set)、有序集合对象(sorted set) 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素 对单个或者多个元素 进行修剪，只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 数据结构简单动态字符串SDS，类似于C++封装的string，Java封装的String，Redis 自己构建了一种简单动态字符串的抽象类型，用在Redis 的字符串类型； 链表应用场景 列表键的底层实现之一； 发布与订阅、慢查询、监视器等功能也用到了链表； Redis 服务器本身使用链表来保存多个客户端的状态信息；构建客户端输出缓冲区。 字典又称符号表、关联数组、映射，一种保存键值对的抽象数据结构 应用场景 Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在字典的操作上的； 在数据库中创建一个键为”msg”，值为”hello world“ 的键值对，保存在字典中。 字典也是哈希键的的底层实现；每个哈希键对应一个数据库，里面的键值对保存的地方就是字典 实现字典 (dict) 类似于Java的HashMap，具有一个散列表结构，散列表中存放键值对，使用拉链法解决哈希冲突； dict 字典 1234567typedef struct dict &#123; dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */&#125; dict; dictht 散列表 12345678/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */typedef struct dictht &#123; dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;&#125; dictht; dictEntry散列表中的键值对 12345678910typedef struct dictEntry &#123; void *key; union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; struct dictEntry *next;&#125; dictEntry; rehash 扩容操作 字典包含两个哈希表dictht，这是为了方便扩容 rehash 操作； 扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上，完成之后释放空间并交换两个 dictht 的角色； rehash 操作不是一次性完成，而是采用渐进式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担； 渐进式 rehash rehashidx ，字典结构中的一个属性，如果该值为 -1 ，字典不采用渐进式 rehash； 渐进式 rehash 通过记录 dict 的 rehashidx 完成，从0开始，然后每执行一次 rehash 都会递增；例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 中的 table[rehashidx] 的键值对 rehash 到 dict[1] 中，并令 dict[0] 的 table[rehashidx] 指向 null，rehashidx++； 在渐进式 rehash 期间，每次对字典增删改查操作时，都会执行一次 rehash； 采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去查找。 1234567891011121314151617181920212223/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */int dictRehash(dict *d, int n) &#123; int empty_visits = n * 10; /* Max number of empty buckets to visit. */ if (!dictIsRehashing(d)) return 0; while (n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123; dictEntry *de, *nextde; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(d-&gt;ht[0].size &gt; (unsigned long) d-&gt;rehashidx); while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123; d-&gt;rehashidx++; if (--empty_visits == 0) return 1; &#125; 跳跃表跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点； 节点查找复杂度：平均O(logN)、最坏O(N). 应用场景 有序集合的底层实现之一； 在集群节点中用作内部数据结构 实现 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表 查找时，从上层指针开始，找到对应的区间之后再到下一层去查找； 与红黑树等平衡树相比，跳跃表具有以下优点： 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作 整数集合压缩列表对象 Redis 并没有直接使用以上数据结构来实现键值对数据库，而是基于这些数据结构创建一个对象系统，这个系统包含字符串对象、哈希对象、列表对象、集合对象、有序集合对象这五种类型的对象。而每个对象都用到了至少一种以上的数据结构。 对象系统实现了基于引用计数技术的内存回收机制、对象共享机制（让多个数据库键共享同一个对象来节约内存） Redis 中的每个对象都由一个redisObject 结构表示，该结构中有 type 、encoding、 ptr 三个属性； 123456789101112typedef struct redisObject&#123; //类型 (5种对象) unsigned type:4; //编码 unsigned encoding:4; //指向底层实现数据结构的指针 void *ptr; // ...&#125; robj; 一部分对象的编码：]]></content>
      <categories>
        <category>后端</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荷兰国旗问题]]></title>
    <url>%2F2019%2F05%2F03%2F%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[荷兰国旗包含三种颜色：红、白、蓝。 有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。 它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。 按颜色进行排序75. Sort Colors (Medium) 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] 题目描述：只有 0/1/2 三种颜色。 123456789101112131415161718public void sortColors(int[] nums) &#123; int zero = -1, one = 0, two = nums.length; while (one &lt; two) &#123; if (nums[one] == 0) &#123; swap(nums, ++zero, one++); &#125; else if (nums[one] == 2) &#123; swap(nums, --two, one); &#125; else &#123; ++one; &#125; &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>leetcode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kth Element & TopK Element]]></title>
    <url>%2F2019%2F05%2F03%2FKth-Element-TopK-Element%2F</url>
    <content type="text"><![CDATA[Kth Element快速排序使用快排将数组排序，选取排好序的第 K 个元素，时间复杂度O(nlogn)，空间复杂度O(1) 1234public int getKthLargest(int[] nums, int k)&#123; Arrays.sort(nums); return nums[nums.length-k];&#125; 堆排序维护大小为 K 的小顶堆，首先建立大小为K的小顶堆，第 K+1 元素加入堆时与堆顶元素比较大小，如果大于堆顶元素，则替代堆顶元素，重新调整堆成为小顶堆；直到遍历完剩下的元素；时间复杂度为O(nlogK)，空间复杂度O(K). 123456789public int getKthLargest(int[] nums, int K)&#123; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(); for(int val : nums)&#123; heap.add(val); if(heap.size &gt; k) heap.poll(); &#125; return heap.peek();&#125; 快速选择根据快速排序分区操作的特性：分区操作将小于基准值的元素分在基准左边，大于分在右边，并返回基准值下标；如果返回的基准值下标正好是 K ，则完成；平均时间复杂度O(n)，最坏时间复杂度O(n²)，空间复杂度O(1)。 123456789101112131415161718192021222324252627282930public int getKthLargest(int[] nums, int K)&#123; int l = 0, h = nums.length-1; while(l &lt;= h)&#123; int partitionInd = partition(nums, l, h); if(partitionInd == k-1) return nums[partitionInd]; else if(partitionInd &lt; k-1) h = partitionInd-1; else l = partitionInd+1; &#125; return 0;&#125;public int partition(int[] nums, int l, int h)&#123; if(l==h) return l; int pivot = nums[l]; while(l&lt;h)&#123; while(nums[h]&gt;=pivot &amp;&amp; l&lt;h) h--; nums[l] = nums[h]; while(nums[l]&lt;=pivot &amp;&amp; l&lt;h) l++; nums[h] = nums[l]; &#125; nums[l] = pivot; return l;&#125; TopK Element用于求解 TopK Elements 问题，通过维护一个大小为 K 的堆，堆中的元素就是 TopK Elements。 堆排序也可以用于求解 Kth Element 问题，堆顶元素就是 Kth Element。 快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。]]></content>
      <categories>
        <category>编程</category>
        <category>leetcode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>排序</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述解题思路最大堆使用Java的优先队列（也就是堆），我们可以使用最大堆（PriorityQueue默认是最小堆，构建最大堆只需要在构建时传入一个 comparator 即可），在滑动窗口滑动时，将当前元素加入最大堆中，堆顶的元素即是最大值。 12345678910111213141516public ArrayList&lt;Integer&gt; maxInWindows(int[] nums, int size)&#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0 || size==0) return ret; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); for(int i=0; i&lt;size; i++)&#123; heap.add(nums[i]); &#125; ret.add(heap.peek()); for(int i=0, j=i+size; j&lt;nums.length; i++,j++)&#123; heap.remove(nums[i]); heap.add(nums[j]); ret.add(heap.peek()); &#125; return ret;&#125; 双端队列可以使用双端队列，队列中之存放当前元素的下标，设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值），如果前面的元素比 k 大，判断是否还在窗口范围内，不在则移除。 先判断当前队列是否为空，如果不空而且当前元素比队列中尾部的元素大，将队列元素的尾端弹出； 判断队列头元素（存的是下标）是否还在滑动窗口中，不在则把头元素移除。 1234567891011121314151617public ArrayList&lt;Integer&gt; maxInWindows(int[] nums, int size)&#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0 || size==0) return ret; Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; while(!queue.isEmpty() &amp;&amp; nums[i]&gt;=nums[queue.getLast()]) queue.pollLast(); while(!queue.isEmpty() &amp;&amp; queue.getFirst()&lt;i-(size-1)) queue.pollFirst(); queue.offerLast(i); if(i+1&gt;=size)&#123; ret.add(nums[queue.getFirst()]); &#125; &#125; return ret;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>双端队列</tag>
        <tag>最值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建高性能的索引]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引由存储引擎层实现。 B-Tree索引查询类型 全值匹配：索引中所有列进行匹配； 匹配最左前缀：只是用索引的第一列； 匹配列前缀：匹配索引第一列的值的开头部分； 匹配范围值：索引第一列某个范围的所有；如果范围匹配的不是索引第一列，需要补全需要范围索引列的前面全部索引列 限制限制与索引列的顺序息息相关 如果不是从索引的最左列开始查找，则无法使用索引； 不能跳过跳过索引中的列； 如果查询中有某个列的范围查找，其右边所有列都无法使用索引优化查找。 哈希索引限制 哈希索引只保存哈希值和行指针，不存储字段值；需要通过行指针获取行数据； 哈希索引不支持部分索引列匹配，因为哈希值是全部索引列的值哈希得到的； 哈希索引只支持等值查询； 哈希索引无法用于排序，因为数据不是按索引的值顺序存储的。 自适应哈希索引当InnoDB注意到某些索引值被使用非常频繁时，会在B-Tree索引的基础上建立哈希索引，这样就有了哈希索引的一些特点，比如快速哈希查找；这是一个完全自动、内部的行为，无法人为配置控制，只能选择开启或关闭该功能。 空间数据索引（R-Tree）MyISAM表支持空间索引，可以用作地理数据存储；和B-Tree索引不同，它无需前缀索引，而是可以使用所有维度来索引数据，可以使用任意维度来组合查询。 全文索引全文索引是一种特殊的索引类型，用于查找文本中的关键词，而不是索引的值。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL架构]]></title>
    <url>%2F2019%2F04%2F29%2FMySQL%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[MySQL逻辑架构 第一层：连接/线程管理，授权认证、安全等； 第二层：核心服务功能，查询、优化、解析、缓存以及所有内置函数，存储过程、触发器、视图； 第三层：存储引擎，负责MySQL中数据的提取和存储；事务、行级锁在该层实现。 并发控制读写锁读锁：共享锁，同一时刻多个客户可以同时读取同一资源互不干扰； 写锁：排他锁，一个写锁会阻塞其他写锁和读锁。 锁粒度锁定资源粒度越小，并发度越高，锁开销越大。 表锁尽管存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种有效的表锁来实现不同的目的，比如，服务器会为 ALTER TABLE语句使用表锁而忽略存储引擎的锁机制。 行锁行级锁只在存储引擎层实现，而MySQL服务器层没有实现。 事务ACID 原子性：一个事务中的操作要么全部执行，要么全部失败回滚； 一致性：数据库总是从一个一致性状态到另一个一致性状态； 隔离性：一个事务的修改在提交前，对其他事务不可见； 持久性：事务一旦提交，所做的修改持久化到数据库。 隔离级别 未提交读：事务中的修改，即使未提交，其他事务也是可见的； 提交读：一个事务从开始直到提交之前，所作的修改对其他事务不可见； 可重复读：保证同一事务多次读取同一记录结果一致； 串行化：强制事务串行执行；在读取的每一行数据都加锁，会导致大量的超时和锁争用问题。 死锁两个或多个事务在同一资源上相互争用，并请求对方已经锁定的资源，从而导致的恶性循环现象。 解决姿势： 查询时间到达锁等待设定的时间后，放弃锁请求； InnoDB处理方式：将持有最少行级排他锁的事务回滚。 事务日志预写式日志：修改数据时只需要修改内存拷贝中的数据，并且将修改行为追加记录到持久在硬盘的事务日志中；因此修改需要两次写磁盘，一次修改行为写入日志，一次是内存中被修改的数据慢慢刷回磁盘；如果数据的修改行为已经记录到日志中而数据本身还未写回磁盘，此时系统崩溃，数据的修改也不会丢失，存储引擎重启时执行事务日志即可恢复。 多版本并发控制（MVCC）事务型存储引擎，采用多版本并发控制减少加锁操作，降低锁开销。 InnoDB多版本并发控制的简单实现 SELECT：1.查找版本号小于或等于当前事务版本的数据行，这样可以确保读取的数据行要么是事务开始前已存在的或者当前事务插入的行； 2.删除标识版本号要么未定义，要么大于当前事务版本号； INSERT：为插入的数据行保存当前系统版本号为行版本号； DELETE：为删除的数据行保存当前系统版本号为删除标识； UPDATE：先INSERT后DELETE。 MySQL存储引擎数据表的定义由服务器层实现； InnoDB 数据存储在表空间 MVCC支持高并发，默认隔离级别可重复读，并使用间隙锁解决幻读问题； 聚簇索引 优化：可预测性预读、自适应哈希索引、插入缓冲区 在线热备份 MyISAM 全文索引、压缩]]></content>
      <categories>
        <category>计算机基础</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>锁</tag>
        <tag>事务</tag>
        <tag>存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F04%2F24%2FLinux%2F</url>
    <content type="text"><![CDATA[常用操作和命令Tab：命令或文件名补全； Ctrl+C：中断程序； Ctrl+D：结束键盘输入； ls：（-a全部文件）、（-d只列出目录）、（-l长数据串行输出）； mkdir：（-p递归创建）、（-m配置权限）； rmkdir：（-p递归删除） touch：更新文件时间或者建立新文件； –help：指令用法和选项介绍； man：显示指令具体信息； info：将文档分成一个个页面，每个页面可跳转； doc：/usr/share/doc，存放软件一整套说明文件； who：查看在线用户； sync：将内存中的文件同步到磁盘，关机前使用； shutdown：（-k警告信息不关机）、（-r关闭系统服务后重启）、（-h关闭系统服务后立即关机）、（-c取消shutdown命令） PATH：环境变量，声明可执行文件的路径，多个用：分隔符； sudo：一般用户使用root可执行的命令，只有再/etc/sudoers配置的用户才可用； RPM：redhat package manager，软件包管理工具； YUM：基于RPM，具有依赖管理和软件升级功能； VIM：指令模式，编辑模式，指令列模式； 磁盘磁盘接口IDE：磁盘接口，并口线抗干扰性差，已逐渐被SATA取代； SATA：串口ATA，支持热插拔； SCSI：小型机系统接口； SAS：采取序列式技术以获得更高传输速度； 磁盘文件名Linux每个硬件都被当成一个文件，包括磁盘 IDE磁盘：/dev/hd[a-d] SATA/SCSI/SAS磁盘：/dev/sd[a-p] 后面的序号与系统检测到磁盘的顺序有关，有插入的插槽位置无关； 分区分区表MBR：限制较多，第一个扇区最重要，里面有开机记录和分区表，开机记录446bytes，分区表64bytes；分区表最多能存4个分区，主分区和扩展分区，扩展分区只有一个，扩展区可分出更多分区（逻辑分区）；分区也是一个文件，命名方式：磁盘文件名+编号，/dev/sda1；逻辑分区从5开始。 GPT： 文件系统分区与文件系统对分区进行格式化是为了再分区建立文件系统，一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。 组成inode：一个文件一个，记录文件属性，同时记录文件内容所在的block编号； block：记录文件的内容，文件太大的话，占用多个block； superblock：记录文件系统的整体信息，包括inode和block总量、使用量、剩余量，以及文件系统的格式和相关信息等； block bitmap：记录block是否被使用的位域； 文件读取Ext2文件系统：当要读取一个文件内容时，先在inode中查找文件内容所在的所有block，然后把所有内容读出来； FAT文件系统：没有inode，每个block中存着下一个block编号； 磁盘碎片文件内容所在block过于分散，导致磁盘头移动距离过大降低读写性能； block：在Ext2文件系统，block大小1K，2K，4K三种，一个block只能被一个文件使用； inode：权限，拥有者与群组，容量，建立修改时间，最近读取时间，文件特性旗标，文件真正内容指向；大小固定128bytes，每个文件仅占用1个； 目录一个目1个Inode，至少1个block，block记录目录下文件的inode和文件名；inode本身不记录文件名，文件名记录在目录，因此文件增删改操作与目录的w权限有关； 日志修复文件系统 挂载挂载利用目录作为文件系统进入点，即进入目录之后就可以读取文件系统的数据 目录配置/：根目录 /usr：系统默认软件都会安装到这个目录 /var：存放系统或程序运行过程中的数据文件 文件文件属性ls： drwxr-xr-x 3 root root 17 May 6 00:14 .config dr…x：文件类型（d目录、-文件、l链接文件）和权限，文件拥有者、群组、其他人； 3：链接数； root：文件拥有者； root：所属群组； 17：文件大小； May..:14：最后修改时间； config：文件名 获取文件内容cat：取出文件内容 tac：cat的反向操作，从最后一行打印 more：可以一页一页查看文件内容，适合大文件查看； less：和more类似，多了向前翻页功能 head：取得文件前几行； tail：取得文件后几行 od：以字符或者十六进制显示二进制文件； 指令与文件搜索witch：指令搜索 whereis：文件搜索，速度快，因为只搜索几个特定目录； locate：文件搜索，可用关键字或正则搜索，使用/var/lib/mlocate/数据库进行搜索，存在内存中，每日一更；（-r正则表达式） find：文件搜索，可以使用文件属性和权限搜索 Bash]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发工具类：CyclicBarrier]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACyclicBarrier%2F</url>
    <content type="text"><![CDATA[CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier。 注意比较CountDownLatch 和CyclicBarrier： (01) CountDownLatch 的作用是允许1或N个线程等待其他线程完成执行；而 CyclicBarrier 则是允许N个线程相互等待。 (02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 CyclicBarrier函数列表1234567891011121314151617CyclicBarrier(int parties)//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。CyclicBarrier(int parties, Runnable barrierAction)//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。int await()//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。int await(long timeout, TimeUnit unit)//在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。int getNumberWaiting()//返回当前在屏障处等待的参与者数目。int getParties()//返回要求启动此 barrier 的参与者数目。boolean isBroken()//查询此屏障是否处于损坏状态。void reset()//将屏障重置为其初始状态。 CyclicBarrier数据结构 CyclicBarrier 是包含了 “ ReentrantLock 对象 lock “和” Condition 对象 trip “，它是通过独占锁实现的。下面通过源码去分析到底是如何实现的。 1. 构造函数 CyclicBarrier 的构造函数共2个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable barrierAction)。第1个构造函数是调用第2个构造函数来实现的，下面第2个构造函数的源码 123456789public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); // parties表示“必须同时到达barrier的线程个数”。 this.parties = parties; // count表示“处在等待状态的线程个数”。 this.count = parties; // barrierCommand表示“parties个线程到达barrier时，会执行的动作”。 this.barrierCommand = barrierAction;&#125; 2. 等待函数 1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; // 获取“独占锁(lock)” lock.lock(); try &#123; // 保存“当前的generation” final Generation g = generation; // 若“当前generation已损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; // 将“count计数器”-1 int index = --count; // 如果index=0，则意味着“有parties个线程到达barrier”。 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; // 如果barrierCommand不为null，则执行该动作。 final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 唤醒所有等待线程，并更新generation。 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生， // 当前线程才继续执行。 for (;;) &#123; try &#123; // 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。 if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; // 如果等待过程中，线程被中断，则执行下面的函数。 if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; // 如果“当前generation已经损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果“generation已经换代”，则返回index。 if (g != generation) return index; // 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; // 释放“独占锁(lock)” lock.unlock(); &#125;&#125; 说明：dowait() 的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，当前线程才继续执行。 (01) generation 是 CyclicBarrier 的一个成员变量，在 CyclicBarrier 中，同一批的线程属于同一代，即同一个Generation；CyclicBarrier 中通过 generation 对象，记录属于哪一代。当有parties个线程到达 barrier，generation 就会被更新换代。 它的定义如下： 1234private Generation generation = new Generation();private static class Generation &#123; boolean broken = false;&#125; (02) 如果当前线程被中断，即 Thread.interrupted() 为true；则通过 breakBarrier() 终止 CyclicBarrier。breakBarrier() 会设置当前中断标记 broken 为 true，意味着“将该 Generation 中断”；同时，设置 count=parties ，即重新初始化 count；最后，通过 signalAll() 唤醒 CyclicBarrier 上所有的等待线程。 breakBarrier() 的源码如下： 12345private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll();&#125; (03) 将“ count 计数器”-1，即 –count ；然后判断是不是“有 parties 个线程到达 barrier ”，即 index 是不是为0。首先，它会调用 signalAll() 唤醒 CyclicBarrier 上所有的等待线程；接着，重新初始化 count；最后，更新 generation 的值。 当 index =0时，如果 barrierCommand 不为null，则执行该 barrierCommand ， barrierCommand 就是我们创建 CyclicBarrier 时，传入的 Runnable 对象。然后，调用 nextGeneration() 进行换代工作， nextGeneration() 的源码如下： 12345private void nextGeneration() &#123; trip.signalAll(); count = parties; generation = new Generation();&#125; 04) 在 for(;;) 循环中。 timed 是用来表示当前是不是“超时等待”线程。如果不是，则通过 trip.await() 进行等待；否则，调用 awaitNanos() 进行超时等待。 CyclicBarrier 的使用示例123456789101112131415161718192021222324252627import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest1 &#123; private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) &#123; cb = new CyclicBarrier(SIZE); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " wait for CyclicBarrier."); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + " continued."); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 12345678910Thread-1 wait for CyclicBarrier.Thread-2 wait for CyclicBarrier.Thread-3 wait for CyclicBarrier.Thread-4 wait for CyclicBarrier.Thread-0 wait for CyclicBarrier.Thread-0 continued.Thread-4 continued.Thread-2 continued.Thread-3 continued.Thread-1 continued. 结果说明：主线程中新建了5个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrie r时，这些线程才继续运行！ 示例2 新建5个线程，当这5个线程达到一定的条件时，执行某项任务。 12345678910111213141516171819202122232425262728293031import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest2 &#123; private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) &#123; cb = new CyclicBarrier(SIZE, new Runnable () &#123; public void run() &#123; System.out.println("CyclicBarrier's parties is: "+ cb.getParties()); &#125; &#125;); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " wait for CyclicBarrier."); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + " continued."); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011Thread-1 wait for CyclicBarrier.Thread-2 wait for CyclicBarrier.Thread-3 wait for CyclicBarrier.Thread-4 wait for CyclicBarrier.Thread-0 wait for CyclicBarrier.CyclicBarrier's parties is: 5Thread-0 continued.Thread-4 continued.Thread-2 continued.Thread-3 continued.Thread-1 continued. 结果说明：主线程中新建了5个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到cb中所有线程都达到barrier时，执行新建cb时注册的Runnable任务。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发工具类：CountDownLatch]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACountDownLatch%2F</url>
    <content type="text"><![CDATA[CountDownLatch 所描述的是”在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待“：用给定的计数初始化 CountDownLatch 。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。CountDownLatch 的本质也是一个“共享锁” \12345678910111213CountDownLatch(int count)构造一个用给定计数初始化的 CountDownLatch。// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。void await()// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。boolean await(long timeout, TimeUnit unit)// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。void countDown()// 返回当前计数。long getCount()// 返回标识此锁存器及其状态的字符串。String toString() CountDownLatch 是通过一个计数器来实现的，当我们在 new 一个 CountDownLatch 对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。 虽然，CountDownlatch 与 CyclicBarrier（后续会接受。另外一并发工具类）区别：1. CountDownLatch 的作用是允许1或N个线程等待其他线程完成执行；而 CyclicBarrier 则是允许N个线程相互等待1. CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的barrier###### 实现分析 通过上面的结构图我们可以看到，CountDownLatch 内部依赖Sync实现，而 Sync 继承 AQS。CountDownLatch 仅提供了一个构造方法： CountDownLatch(int count) ： 构造一个用给定计数初始化的 CountDownLatch 1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; sync 为 CountDownLatch 的一个内部类，其定义如下： 1234567891011121314151617181920212223242526272829private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; //获取同步状态 int getCount() &#123; return getState(); &#125; //获取同步状态 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; //释放同步状态 protected boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; &#125; 通过这个内部类 Sync 我们可以清楚地看到 CountDownLatch 是采用共享锁来实现的。 CountDownLatch 提供 await() 方法来使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断，定义如下： 123public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; await 其内部使用 AQS 的 acquireSharedInterruptibly(int arg)： 1234567public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 在内部类 Sync 中重写了 tryAcquireShared(int arg) 方法： 123protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; getState() 获取同步状态，其值等于计数器的值，从这里我们可以看到如果计数器值不等于0，则会调用doAcquireSharedInterruptibly(int arg)，该方法为一个自旋方法会尝试一直去获取同步状态： 1234567891011121314151617181920212223242526272829private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; /** * 对于CountDownLatch而言，如果计数器值不等于0，那么r 会一直小于0 */ int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; //等待 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; CountDownLatch 提供 countDown() 方法递减锁存器的计数，如果计数到达零，则释放所有等待的线程。 123public void countDown() &#123; sync.releaseShared(1); &#125; 内部调用 AQS 的 releaseShared(int arg) 方法来释放共享锁同步状态： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; tryReleaseShared(int arg) 方法被 CountDownLatch 的内部类 Sync 重写： 1234567891011121314protected boolean tryReleaseShared(int releases) &#123; for (;;) &#123; //获取锁状态 int c = getState(); //c == 0 直接返回，释放锁成功 if (c == 0) return false; //计算新“锁计数器” int nextc = c-1; //更新锁状态（计数器） if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; 总结 CountDownLatch 内部通过共享锁实现。在创建 CountDownLatch 实例时，需要传递一个 int 型的参数： count ，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。当某个线程调用 await() 方法，程序首先判断 count 的值是否为0，如果不会0的话则会一直等待直到为0为止。当其他线程调用 countDown() 方法时，则执行释放共享锁状态，使count值 - 1。当在创建 CountDownLatch 时初始化的 count 参数，必须要有count 线程调用 countDown 方法才会使计数器 count 等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch 不能回滚重置。 应用示例示例仍然使用开会案例。老板进入会议室等待5个人全部到达会议室才会开会。所以这里有两个线程老板等待开会线程、员工到达会议室： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CountDownLatchTest &#123; private volatile static CountDownLatch countDownLatch = new CountDownLatch(5); /** * Boss线程，等待员工到达开会 */ static class BossThread extends Thread&#123; BossThread(String name)&#123; super(name); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + ":Boss在会议室等待，总共有" + countDownLatch.getCount() + "个人开会..."); try &#123; //Boss等待 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ":所有人都已经到齐了，开会吧..."); &#125; &#125; //员工到达会议室 static class EmpleoyeeThread extends Thread&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "，到达会议室...."); //员工到达会议室 count - 1 countDownLatch.countDown(); &#125; &#125; public static void main(String[] args) throws InterruptedException&#123; //Boss线程启动 new BossThread("张总").start(); new BossThread("李总").start(); new BossThread("王总").start(); Thread.sleep(1000); for(int i = 0 ; i &lt; 5 ; i++)&#123; new EmpleoyeeThread().start(); &#125; &#125;&#125; 1234567891011张总:Boss在会议室等待，总共有5个人开会...李总:Boss在会议室等待，总共有5个人开会...王总:Boss在会议室等待，总共有5个人开会...Thread-0，到达会议室....Thread-1，到达会议室....Thread-2，到达会议室....Thread-3，到达会议室....Thread-4，到达会议室....张总:所有人都已经到齐了，开会吧...王总:所有人都已经到齐了，开会吧...李总:所有人都已经到齐了，开会吧...]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读写锁-ReentrantReadWriteLock]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AF%BB%E5%86%99%E9%94%81-ReentrantReadWriteLock%2F</url>
    <content type="text"><![CDATA[重入锁ReentrantLockReentrantLock 排他锁，排他锁在同一时刻仅有一个线程可以进行访问，但是在大多数场景下，大部分时间都是提供读服务，而写服务占有的时间较少。然而读服务不存在数据竞争问题，如果一个线程在读时禁止其他线程读势必会导致性能降低。所以就提供了读写锁。 读写锁ReentrantReadWriteLock 读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：在同一时间可以允许多个读线程同时访问，但是在写线程访问时，所有读线程和写线程都会被阻塞。 读写锁的主要特性： 公平性：支持公平性和非公平性。 重入性：支持重入。读写锁最多支持65535个递归写入锁和65535个递归读取锁。 锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁 读写锁 ReentrantReadWriteLock 实现接口 ReadWriteLock ，该接口维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。 1234public interface ReadWriteLock &#123; Lock readLock(); Lock writeLock();&#125; ReadWriteLock 定义了两个方法。readLock() 返回用于读操作的锁，writeLock() 返回用于写操作的锁。ReentrantReadWriteLock 定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** 内部类 读锁 */private final ReentrantReadWriteLock.ReadLock readerLock;/** 内部类 写锁 */private final ReentrantReadWriteLock.WriteLock writerLock;final Sync sync;/** 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */public ReentrantReadWriteLock() &#123; this(false);&#125;/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */public ReentrantReadWriteLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this);&#125;/** 返回用于写入操作的锁 */public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;/** 返回用于读取操作的锁 */public ReentrantReadWriteLock.ReadLock readLock() &#123; return readerLock; &#125;abstract static class Sync extends AbstractQueuedSynchronizer &#123; /** * 省略其余源代码 */&#125;public static class WriteLock implements Lock, java.io.Serializable&#123; /** * 省略其余源代码 */&#125;public static class ReadLock implements Lock, java.io.Serializable &#123; /** * 省略其余源代码 */&#125; ReentrantReadWriteLock 与 ReentrantLock 一样，其锁主体依然是 Sync ，它的读锁、写锁都是依靠 Sync 来实现的。所以 ReentrantReadWriteLock 实际上只有一个锁，只是在获取读取锁和写入锁的方式上不一样而已，它的读写锁其实就是两个类：ReadLock、writeLock，这两个类都是 lock 实现。 在 ReentrantLock 中使用一个 int 类型的 state 来表示同步状态，该值表示锁被一个线程重复获取的次数。但是读写锁 ReentrantReadWriteLock 内部维护着两个一对锁，需要用一个变量维护多种状态。所以读写锁采用“按位切割使用”的方式来维护这个变量，将其切分为两部分，高16为表示读，低16为表示写。分割之后，读写锁是如何迅速确定读锁和写锁的状态呢？通过位运算。假如当前同步状态为 S ，那么写状态等于 S &amp; 0x0000FFFF（将高16位全部抹去），读状态等于S &gt;&gt;&gt; 16(无符号补0右移16位)。代码如下： 1234567static final int SHARED_SHIFT = 16;static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; 写锁（写锁就是一个支持可重入的排他锁） 写锁的获取（写锁的获取最终会调用 tryAcquire(int arg) ，该方法在内部类 Sync 中实现：） 12345678910111213141516171819202122232425protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); //当前锁个数 int c = getState(); //写锁 int w = exclusiveCount(c); if (c != 0) &#123; //c != 0 &amp;&amp; w == 0 表示存在读锁 //当前线程不是已经获取写锁的线程 if (w == 0 || current != getExclusiveOwnerThread()) return false; //超出最大范围 if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); setState(c + acquires); return true; &#125; //是否需要阻塞 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; //设置获取锁的线程为当前线程 setExclusiveOwnerThread(current); return true; &#125; 该方法和 ReentrantLock 的 tryAcquire(int arg) 大致一样，在判断重入时增加了一项条件：读锁是否存在。因为要确保写锁的操作对读锁是可见的，如果在存在读锁的情况下允许获取写锁，那么那些已经获取读锁的其他线程可能就无法感知当前写线程的操作。因此只有等读锁完全释放后，写锁才能够被当前线程所获取，一旦写锁获取了，所有其他读、写线程均会被阻塞。 写锁的释放（获取了写锁用完了则需要释放，WriteLock提供了 unlock() 方法释放写锁） 12345678910111213public void unlock() &#123; sync.release(1);&#125;public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 写锁的释放最终还是会调用 AQS 的模板方法 release(int arg) 方法，该方法首先调用 tryRelease(int arg) 方法尝试释放锁，tryRelease(int arg) 方法为读写锁内部类 Sync 中定义了，如下： ;) 123456789101112protected final boolean tryRelease(int releases) &#123; //释放的线程不为锁的持有者 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; //若写锁的新线程数为0，则将锁的持有者设置为null boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); setState(nextc); return free;&#125; 写锁释放锁的整个过程和独占锁ReentrantLock相似，每次释放均是减少写状态，当写状态为0时表示 写锁已经完全释放了，从而等待的其他线程可以继续访问读写锁，获取同步状态，同时此次写线程的修改对后续的线程可见。 读锁 （读锁为一个可重入的共享锁，它能够被多个线程同时持有，在没有其他写线程访问时，读锁总是会获取成功） 读锁的获取（读锁的获取可以通过ReadLock的lock()方法） 123public void lock() &#123; sync.acquireShared(1);&#125; Sync的acquireShared(int arg)定义在AQS中： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; tryAcqurireShared(int arg)尝试获取读同步状态，该方法主要用于获取共享式同步状态，获取成功返回 &gt;= 0的返回结果，否则返回 &lt; 0 的返回结果。 1234567891011121314151617181920212223242526272829303132333435363738394041protected final int tryAcquireShared(int unused) &#123; //当前线程 Thread current = Thread.currentThread(); int c = getState(); //exclusiveCount(c)计算写锁 //如果存在写锁，且锁的持有者不是当前线程，直接返回-1 //存在锁降级问题，后续阐述 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; //读锁 int r = sharedCount(c); /* * readerShouldBlock():读锁是否需要等待（公平锁原则） * r &lt; MAX_COUNT：持有线程小于最大数（65535） * compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态 */ if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; /* * holdCount部分后面讲解 */ if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 读锁获取的过程相对于独占锁而言会稍微复杂下，整个过程如下： 因为存在锁降级情况，如果存在写锁且锁的持有者不是当前线程则直接返回失败，否则继续 依据公平性原则，判断读锁是否 塞，读锁持有线程数小于最大值（65535），且设置锁状态成功，执行以下代码（对于HoldCounter下面再阐述），并返回1。如果不满足改条件，执行fullTryAcquireShared()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final int fullTryAcquireShared(Thread current) &#123; HoldCounter rh = null; for (;;) &#123; int c = getState(); //锁降级 if (exclusiveCount(c) != 0) &#123; if (getExclusiveOwnerThread() != current) return -1; &#125; //读锁需要阻塞 else if (readerShouldBlock()) &#123; //列头为当前线程 if (firstReader == current) &#123; &#125; //HoldCounter后面讲解 else &#123; if (rh == null) &#123; rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) &#123; rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); &#125; &#125; if (rh.count == 0) return -1; &#125; &#125; //读锁超出最大范围 if (sharedCount(c) == MAX_COUNT) throw new Error("Maximum lock count exceeded"); //CAS设置读锁成功 if (compareAndSetState(c, c + SHARED_UNIT)) &#123; //如果是第1次获取“读取锁”，则更新firstReader和firstReaderHoldCount if (sharedCount(c) == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; //如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程,则将firstReaderHoldCount+1 else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); //更新线程的获取“读取锁”的共享计数 rh.count++; cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125; &#125; fullTryAcquireShared(Thread current)会根据“是否需要阻塞等待”，“读取锁的共享计数是否超过限制”等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过CAS尝试获取锁，并返回1 读锁的释放（与写锁相同，读锁也提供了unlock()释放读锁） 123public void unlock() &#123; sync.releaseShared(1);&#125; unlcok()方法内部使用Sync的releaseShared(int arg)方法，该方法定义在AQS中： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 调用tryReleaseShared(int arg)尝试释放读锁，该方法定义在读写锁的Sync内部类中： 12345678910111213141516171819202122232425262728293031protected final boolean tryReleaseShared(int unused) &#123; Thread current = Thread.currentThread(); //如果想要释放锁的线程为第一个获取锁的线程 if (firstReader == current) &#123; //仅获取了一次，则需要将firstReader 设置null，否则 firstReaderHoldCount - 1 if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; &#125; //获取rh对象，并更新“当前线程获取锁的信息” else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; --rh.count; &#125; //CAS更新同步状态 for (;;) &#123; int c = getState(); int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; 锁降级 锁降级：从写锁变成读锁； 锁升级：从读锁变成写锁。 读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。 如下代码会产生死锁，因为同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，ReentrantReadWriteLock是不支持的。 12345ReadWriteLock rtLock = new ReentrantReadWriteLock();rtLock.readLock().lock();System.out.println("get readLock.");rtLock.writeLock().lock();System.out.println("blocking"); ReentrantReadWriteLock支持锁降级，如下代码不会产生死锁。 123456ReadWriteLock rtLock = new ReentrantReadWriteLock();rtLock.writeLock().lock();System.out.println("writeLock");rtLock.readLock().lock();System.out.println("get read lock"); 以上这段代码虽然不会导致死锁，但没有正确的释放锁。从写锁降级成读锁，并不会自动释放当前线程获取的写锁，仍然需要显示的释放，否则别的线程永远也获取不到写锁。锁降级就意味着写锁是可以降级为读锁的，但是需要遵循先获取写锁、获取读锁在释放写锁的次序。注意如果当前线程先获取写锁，然后释放写锁，再获取读锁这个过程不能称之为锁降级，锁降级一定要遵循那个次序。 锁降级中读锁的获取释放为必要？肯定是必要的。试想，假如当前线程A不获取读锁而是直接释放了写锁，这个时候另外一个线程B获取了写锁，那么这个线程B对数据的修改是不会对当前线程A可见的。如果获取了读锁，则线程B在获取写锁过程中判断如果有读锁还没有释放则会被阻塞，只有当前线程A释放读锁后，线程B才会获取写锁成功。 读写锁例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; final Queue3 q3 = new Queue3(); for(int i=0;i&lt;3;i++) &#123; new Thread()&#123; public void run()&#123; while(true)&#123; q3.get(); &#125; &#125; &#125;.start(); &#125; for(int i=0;i&lt;3;i++) &#123; new Thread()&#123; public void run()&#123; while(true)&#123; q3.put(new Random().nextInt(10000)); &#125; &#125; &#125;.start(); &#125; &#125;&#125;class Queue3&#123; private Object data = null;//共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。 private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public void get()&#123; System.out.println(Thread.currentThread().getName() + " be to read data!"); try &#123; Thread.sleep((long)(Math.random()*1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "have read data :" + data); &#125; public void put(Object data)&#123; rwl.writeLock().lock();//上写锁，不允许其他线程读也不允许写 try &#123; System.out.println(Thread.currentThread().getName() + " be to write data!"); try &#123; Thread.sleep((long)(Math.random()*1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.data = data; System.out.println(Thread.currentThread().getName() + " have write data: " + data); &#125; finally &#123; rwl.writeLock().unlock();//释放写锁 &#125; &#125;&#125; 123456789101112Thread-0 be ready to read data!Thread-1 be ready to read data!Thread-2 be ready to read data!Thread-0have read data :nullThread-2have read data :nullThread-1have read data :nullThread-5 be ready to write data!Thread-5 have write data: 6934Thread-5 be ready to write data!Thread-5 have write data: 8987Thread-5 be ready to write data!Thread-5 have write data: 8496 使用读写锁模拟一个缓存器： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class CacheDemo &#123; /** * 缓存器,这里假设需要存储1000左右个缓存对象，按照默认的负载因子0.75，则容量=750，大概估计每一个节点链表长度为5个 * 那么数组长度大概为：150,又有雨设置map大小一般为2的指数，则最近的数字为：128 */ private Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(128); private ReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; &#125; public Object get(String id)&#123; Object value = null; rwl.readLock().lock();//首先开启读锁，从缓存中去取 try&#123; value = map.get(id); if(value == null)&#123; //如果缓存中没有释放读锁，上写锁 rwl.readLock().unlock(); rwl.writeLock().lock(); try&#123; if(value == null)&#123; //防止多写线程重复查询赋值 value = "redis-value"; //此时可以去数据库中查找，这里简单的模拟一下 &#125; rwl.readLock().lock(); //加读锁降级写锁,不明白的可以查看上面锁降级的原理与保持读取数据原子性的讲解 &#125;finally&#123; rwl.writeLock().unlock(); //释放写锁 &#125; &#125; &#125;finally&#123; rwl.readLock().unlock(); //最后释放读锁 &#125; return value; &#125;&#125;]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁条件Condition]]></title>
    <url>%2F2019%2F04%2F20%2F%E9%94%81%E6%9D%A1%E4%BB%B6Condition%2F</url>
    <content type="text"><![CDATA[Condition简介 Condition 的作用是对锁进行更精确的控制。 Condition 中的 await() 方法相当于 Object 的 wait() 方法， Condition 中的 signal() 方法相当于 Object 的 notify() 方法， Condition 中的 signalAll() 相当于 Object 的 notifyAll() 方法。不同的是， Object 中的 wait() , notify() , notifyAll() 方法是和”同步锁” (synchronized 关键字) 捆绑使用的；而 Condition 是需要与”互斥锁”/“共享锁”捆绑使用的。 12345678910111213void await()// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。boolean await(long time, TimeUnit unit)// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。long awaitNanos(long nanosTimeout)// 造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】void awaitUninterruptibly()// 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。boolean awaitUntil(Date deadline)// 唤醒一个等待线程。void signal()// 唤醒所有等待线程。void signalAll() Condtion的实现 获取一个 Condition 必须要通过 Lock 的 newCondition() 方法。该方法定义在接口 Lock 下面，返回的结果是绑定到此 Lock 实例的新 Condition 实例。 Condition 为一个接口，其下仅有一个实现类 ConditionObject ，由于 Condition 的操作需要获取相关的锁，而 AQS 则是同步锁的实现基础，所以 ConditionObject 则定义为 AQS 的内部类。定义如下： 123public abstract class AbstractQueuedLongSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; public class ConditionObject implements Condition, java.io.Serializable &#123;&#125;&#125; 等待队列 每个 Condition 对象都包含着一个 FIFO 队列，该队列是 Condition 对象通知/等待功能的关键。在队列中每一个节点都包含着一个线程引用，该线程就是在该 Condition 对象上等待的线程。我们看 Condition 的定义就明白了： 12345678910111213public class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; //头节点 private transient Node firstWaiter; //尾节点 private transient Node lastWaiter; public ConditionObject() &#123; &#125; /** 省略方法 **/&#125; 从上面代码可以看出 Condition 拥有首节点（firstWaiter），尾节点（lastWaiter）。当前线程调用 await() 方法，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾部。结构如下： Node 里面包含了当前线程的引用。 Node 定义与 AQS 的 CLH 同步队列的节点使用的都是同一个类（AbstractQueuedSynchronized.Node 静态内部类）。 Condition 的队列结构比 CLH 同步队列的结构简单些，新增过程较为简单只需要将原尾节点的 nextWaiter 指向新增节点，然后更新 lastWaiter 即可。 等待（await） 调用 Condition 的 await() 方法会使当前线程进入等待状态，同时会加入到 Condition 等待队列同时释放锁。当从 await() 方法返回时，当前线程一定是获取了 Condition 相关连的锁。 123456789101112131415161718192021222324252627282930public final void await() throws InterruptedException &#123; // 当前线程中断 if (Thread.interrupted()) throw new InterruptedException(); //当前线程加入等待队列 Node node = addConditionWaiter(); //释放锁 long savedState = fullyRelease(node); int interruptMode = 0; /** * 检测此节点的线程是否在同步队上，如果不在，则说明该线程还不具备竞争锁的资格，则继续等待 * 直到检测到此节点在同步队列上 * 需要被唤醒才能从条件队列转移到CLF同步队列 */ while (!isOnSyncQueue(node)) &#123; //线程挂起 LockSupport.park(this); //如果已经中断了，则退出 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //竞争同步状态 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; //清理下条件队列中的不是在等待条件的节点 if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 此段代码的逻辑是：首先将当前线程新建一个节点同时加入到条件队列中，然后释放当前线程持有的同步状态。然后则是不断检测该节点代表的线程释放出现在 CLH 同步队列中（收到 signal 信号之后就会在 AQS 队列中检测到），如果不存在则一直挂起，否则参与竞争同步状态。 加入条件队列（addConditionWaiter()）源码如下： 1234567891011121314151617181920private Node addConditionWaiter() &#123; Node t = lastWaiter; //尾节点 //Node的节点状态如果不为CONDITION，则表示该节点不处于等待状态，需要清除节点 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; //清除条件队列中所有状态不为Condition的节点 unlinkCancelledWaiters(); t = lastWaiter; &#125; //当前线程新建节点，状态CONDITION Node node = new Node(Thread.currentThread(), Node.CONDITION); /** * 将该节点加入到条件队列中最后一个位置 */ if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125; 该方法主要是将当前线程加入到 Condition 条件队列中。当然在加入到尾节点之前会清楚所有状态不为 Condition 的节点。 fullyRelease(Node node)，负责释放该线程持有的锁。 1234567891011121314151617final long fullyRelease(Node node) &#123; boolean failed = true; try &#123; //节点状态--其实就是持有锁的数量 long savedState = getState(); //释放锁 if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125;&#125; isOnSyncQueue(Node node)：如果一个节点刚开始在条件队列上，现在在同步队列上获取锁则返回true 12345678910final boolean isOnSyncQueue(Node node) &#123; //状态为Condition，获取前驱节点为null，返回false if (node.waitStatus == Node.CONDITION || node.prev == null) return false; //后继节点不为null，肯定在CLH同步队列中 if (node.next != null) return true; return findNodeFromTail(node);&#125; unlinkCancelledWaiters()：负责将条件队列中状态不为Condition的节点删除 12345678910111213141516171819private void unlinkCancelledWaiters() &#123; Node t = firstWaiter; Node trail = null; while (t != null) &#123; Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) &#123; t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; &#125; else trail = t; t = next; &#125;&#125; 通知（signal） 调用 Condition 的 signal() 方法，将会唤醒在条件等待队列中等待最长时间的节点（条件队列里的首节点），在唤醒节点前，会将节点移到 CLH 同步队列中。 123456789public final void signal() &#123; //检测当前线程是否为拥有锁 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); //头节点，唤醒条件队列中的第一个节点 Node first = firstWaiter; if (first != null) doSignal(first); //唤醒&#125; 该方法首先会判断当前线程是否已经获得了锁，这是前置条件。然后唤醒条件队列中的头节点。 doSignal(Node first)：唤醒头节点 123456789private void doSignal(Node first) &#123; do &#123; //修改头结点，完成旧头结点的移出工作 if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125; doSignal(Node first)主要是做两件事：1.修改头节点，2.调用 transferForSignal(Node first) 方法将节点移动到CLH同步队列中。transferForSignal(Node first)源码如下： 12345678910111213 final boolean transferForSignal(Node node) &#123; //将该节点从状态CONDITION改变为初始状态0, if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //将节点加入到syn队列中去，返回的是syn队列中node节点前面的一个节点 Node p = enq(node); int ws = p.waitStatus; //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; 判断当前线程是否已经获取了锁，如果没有获取则直接抛出异常，因为获取锁为通知的前置条件。 如果线程已经获取了锁，则将唤醒条件队列的首节点 唤醒首节点是先将条件队列中的头节点移出，然后调用 AQS 的 enq(Node node) 方法将其安全地移到 CLH 同步队列中 最后判断如果该节点的同步状态是否为 Cancel ，或者修改状态为 Signal 失败时，则直接调用LockSupport唤醒该节点的线程。 总结 一个线程获取锁后，通过调用 Condition 的 await() 方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过 isOnSyncQueue(Node node) 方法不断自检看节点是否已经在 CLH 同步队列了，如果是则尝试获取锁，否则一直挂起。当线程调用 signal() 方法后，程序首先检查当前线程是否获取了锁，然后通过 doSignal(Node first) 方法唤醒 CLH 同步队列的首节点。被唤醒的线程，将从 await() 方法中的 while 循环中退出来，然后调用 acquireQueued() 方法竞争同步状态。 synchronized原理 synchronized 原理在 java 中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当我们调用某对象的 synchronized 方法时，就获取了该对象的同步锁。例如， synchronized(obj) 就获取了“obj这个对象”的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程 A 和线程 B ，它们都会访问“对象 obj 的同步锁”。假设，在某一时刻，线程 A 获取到“ obj 的同步锁”并在执行一些操作；而此时，线程 B 也企图获取“ obj 的同步锁” —— 线程 B 会获取失败，它必须等待，直到线程 A 释放了“该对象的同步锁”之后线程 B 才能获取到“ obj 的同步锁”从而才可以运行。 synchronized基本规则 synchronized 基本规则我们将 synchronized 的基本规则总结为下面3条，并通过实例对它们进行说明。 第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。 实例锁对应的就是synchronized关键字。 全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 全局锁对应的就是 static synchronized（或者是锁在该类的class或者classloader对象上）。 Condtion的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[5]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); //获取锁 try &#123; // 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。 while (count == items.length) notFull.await(); // 将x添加到缓冲中 items[putptr] = x; // 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。 if (++putptr == items.length) putptr = 0; // 将“缓冲”数量+1 ++count; // 唤醒take线程，因为take线程通过notEmpty.await()等待 notEmpty.signal(); // 打印写入的数据 System.out.println(Thread.currentThread().getName() + " put "+ (Integer)x); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); //获取锁 try &#123; // 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。 while (count == 0) notEmpty.await(); // 将x从缓冲中取出 Object x = items[takeptr]; // 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。 if (++takeptr == items.length) takeptr = 0; // 将“缓冲”数量-1 --count; // 唤醒put线程，因为put线程通过notFull.await()等待 notFull.signal(); // 打印取出的数据 System.out.println(Thread.currentThread().getName() + " take "+ (Integer)x); return x; &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; &#125;public class ConditionTest2 &#123; private static BoundedBuffer bb = new BoundedBuffer(); public static void main(String[] args) &#123; // 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)； // 启动10个“读线程”，从BoundedBuffer中不断的读数据。 for (int i=0; i&lt;10; i++) &#123; new PutThread("p"+i, i).start(); new TakeThread("t"+i).start(); &#125; &#125; static class PutThread extends Thread &#123; private int num; public PutThread(String name, int num) &#123; super(name); this.num = num; &#125; public void run() &#123; try &#123; Thread.sleep(1); // 线程休眠1ms bb.put(num); // 向BoundedBuffer中写入数据 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; static class TakeThread extends Thread &#123; public TakeThread(String name) &#123; super(name); &#125; public void run() &#123; try &#123; Thread.sleep(10); // 线程休眠1ms Integer num = (Integer)bb.take(); // 从BoundedBuffer中取出数据 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; 1234567891011121314151617181920p1 put 1p4 put 4p5 put 5p0 put 0p2 put 2t0 take 1p3 put 3t1 take 4p6 put 6t2 take 5p7 put 7t3 take 0p8 put 8t4 take 2p9 put 9t5 take 3t6 take 6t7 take 7t8 take 8t9 take 9 (01) BoundedBuffer 是容量为5的缓冲，缓冲中存储的是 Object 对象，支持多线程的读/写缓冲。多个线程操作“一个 BoundedBuffer 对象”时，它们通过互斥锁 lock 对缓冲区 items 进行互斥访问；而且同一个 BoundedBuffer 对象下的全部线程共用 “notFull” 和 “notEmpty” 这两个 Condition 。 notFull 用于控制写缓冲， notEmpty 用于控制读缓冲。当缓冲已满的时候，调用 put 的线程会执行notFull.await()进行等待；当缓冲区不是满的状态时，就将对象添加到缓冲区并将缓冲区的容量count+1，最后，调用notEmpty.signal()缓冲notEmpty上的等待线程(调用notEmpty.await的线程)。 简言之，notFull控制“缓冲区的写入”，当往缓冲区写入数据之后会唤醒notEmpty上的等待线程。 同理，notEmpty控制“缓冲区的读取”，当读取了缓冲区数据之后会唤醒notFull上的等待线程。(02) 在ConditionTest2的main函数中，启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)；同时，也启动10个“读线程”，从BoundedBuffer中不断的读数据。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS同步状态的获取和释放]]></title>
    <url>%2F2019%2F04%2F20%2FAQS%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE%2F</url>
    <content type="text"><![CDATA[AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。 独占式 独占式，同一时刻仅有一个线程持有同步状态。 独占式同步状态获取 acquire(int arg)方法为 AQS 提供的模板方法，该方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 各个方法定义如下： tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。 addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。 acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。 selfInterrupt：产生一个中断。 acquireQueued 方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。如下： 12345678910111213141516171819202122232425262728final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; //中断标志 boolean interrupted = false; /* * 自旋过程，其实就是一个死循环而已 */ for (;;) &#123; //当前线程的前驱节点 final Node p = node.predecessor(); //当前线程的前驱节点是头结点，且同步状态成功 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; //获取失败，线程等待--具体后面介绍 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由： 保持FIFO同步队列原则。 头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。 acquire(int arg) 方法流程图如下： 独占式获取响应中断 AQS 提供了 acquire(int arg) 方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS 提供了acquireInterruptibly(int arg)方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常 nterruptedException 。 1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; 首先校验该线程是否已经中断了，如果是则抛出 InterruptedException ，否则执行 tryAcquire(int arg) 方法获取同步状态，如果获取成功，则直接返回，否则执行doAcquireInterruptibly(int arg)。doAcquireInterruptibly(int arg) 定义如下： 12345678910111213141516171819202122private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; doAcquireInterruptibly(int arg) 方法与 acquire(int arg) 方法仅有两个差别。1.方法声明抛出 InterruptedException 异常；2.在中断方法处不再是使用 interrupted 标志，而是直接抛出 InterruptedException 异常。 独占式超时获取 AQS 除了提供上面两个方法外，还提供了一个增强版的方法：tryAcquireNanos(int arg,long nanos)。该方法为 acquireInterruptibly 方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回 false ，否则返回 true 。如下： 1234567public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; tryAcquireNanos(int arg, long nanosTimeout) 方法超时获取最终是在 doAcquireNanos(int arg, long nanosTimeout) 中实现的，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; //nanosTimeout &lt;= 0 if (nanosTimeout &lt;= 0L) return false; //超时时间 final long deadline = System.nanoTime() + nanosTimeout; //新增Node节点 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; //自旋 for (;;) &#123; final Node p = node.predecessor(); //获取同步状态成功 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; /* * 获取失败，做超时、中断判断 */ //重新计算需要休眠的时间 nanosTimeout = deadline - System.nanoTime(); //已经超时，返回false if (nanosTimeout &lt;= 0L) return false; //如果没有超时，则等待nanosTimeout纳秒 //注：该线程会直接从LockSupport.parkNanos中返回， //LockSupport为JUC提供的一个阻塞和唤醒的工具类，后面做详细介绍 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); //线程是否已经中断了 if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 针对超时控制，程序首先记录唤醒时间 deadline ，deadline = System.nanoTime() + nanosTimeout（时间间隔）。如果获取同步状态失败，则需要计算出需要休眠的时间间隔nanosTimeout（= deadline - System.nanoTime()），如果 nanosTimeout &lt;= 0 表示已经超时了，返回false，如果大于 spinForTimeoutThreshold（1000L） 则需要休眠 nanosTimeout ，如果nanosTimeout &lt;= spinForTimeoutThreshold ，就不需要休眠了，直接进入快速自旋的过程。原因在于 spinForTimeoutThreshold 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让nanosTimeout 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。 整个流程如下： 独占式同步状态释放 当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS 提供了 release(int arg) 方法释放同步状态： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 该方法同样是先调用自定义同步器自定义的 tryRelease(int arg) 方法来释放同步状态，释放成功后，会调用 unparkSuccessor(Node node) 方法唤醒后继节点。 总结一下： 在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的队尾并一直保持着自旋。在 CLH 同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH 同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。 共享式 共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。 共享式同步状态获取 AQS 提供 acquireShared(int arg)方法共享式获取同步状态： 12345public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) //获取失败，自旋获取同步状态 doAcquireShared(arg);&#125; 从上面程序可以看出，方法首先是调用 tryAcquireShared(int arg) 方法尝试获取同步状态，如果获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。自选式获取同步状态如下： 12345678910111213141516171819202122232425262728293031private void doAcquireShared(int arg) &#123; //共享式节点 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //前驱节点 final Node p = node.predecessor(); //如果其前驱节点，获取同步状态 if (p == head) &#123; //尝试获取同步 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; tryAcquireShared(int arg)方法尝试获取同步状态，返回值为 int ，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。 acquireShared(int arg) 方法不响应中断，与独占式相似，AQS 也提供了响应中断、超时的方法，分别是：acquireSharedInterruptibly(int arg)、tryAcquireSharedNanos(int arg,long nanos)，这里就不做解释了。 共享式同步状态释放 获取同步状态后，需要调用release(int arg)方法释放同步状态，方法如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS简介]]></title>
    <url>%2F2019%2F04%2F20%2FAQS%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[AQS简介 AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC 并发包的作者（ Doug Lea ）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。 AQS 解决了在实现同步器时涉及到的大量细节问题，例如获取同步状态、 FIFO 同步队列。基于 AQS 来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中所有基于 AQS 构建的同步器均可以获得这个优势。 AQS 的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 AQS 使用一个 int 类型的成员变量 state 来表示同步状态，当 state &gt; 0 时表示已经获取了锁，当 state = 0 时表示释放了锁。它提供了三个方法（ getState() 、setState(int newState) 、compareAndSetState(int expect,int update)）来对同步状态 state 进行操作，当然 AQS 可以确保对 state 的操作是安全的。 AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态（锁）失败时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。 AQS方法 getState()：返回同步状态的当前值； setState(int newState)：设置当前同步状态； compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性； tryAcquire(int arg)：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态； tryRelease(int arg)：独占式释放同步状态； tryAcquireShared(int arg)：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败； tryReleaseShared(int arg)：共享式释放同步状态； isHeldExclusively()：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占； acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法； acquireInterruptibly(int arg)：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回； tryAcquireNanos(int arg,long nanos)：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true； acquireShared(int arg)：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态； acquireSharedInterruptibly(int arg)：共享式获取同步状态，响应中断； tryAcquireSharedNanos(int arg, long nanosTimeout)：共享式获取同步状态，增加超时限制； release(int arg)：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒； releaseShared(int arg)：共享式释放同步状态； CLH同步队列 CLH 同步队列是一个 FIFO 双向队列，AQS 依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS 则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到 CLH 同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。 在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static final class Node &#123; /** 共享 */ static final Node SHARED = new Node(); /** 独占 */ static final Node EXCLUSIVE = null; /** * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态； */ static final int CANCELLED = 1; /** * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行 */ static final int SIGNAL = -1; /** * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中 */ static final int CONDITION = -2; /** * 表示下一次共享式同步状态获取将会无条件地传播下去 */ static final int PROPAGATE = -3; /** 等待状态 */ volatile int waitStatus; /** 前驱节点 */ volatile Node prev; /** 后继节点 */ volatile Node next; /** 获取同步状态的线程 */ volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; &#125; Node(Thread thread, Node mode) &#123; this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; CLH同步队列结构图如下： 入列 学了数据结构的我们，CLH 队列入列是再简单不过了，无非就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。代码我们可以看看addWaiter(Node node)方法： 1234567891011121314151617private Node addWaiter(Node mode) &#123; //新建Node Node node = new Node(Thread.currentThread(), mode); //快速尝试添加尾节点 Node pred = tail; if (pred != null) &#123; node.prev = pred; //CAS设置尾节点 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //多次尝试 enq(node); return node;&#125; addWaiter(Node node) 先通过快速尝试设置尾节点，如果失败，则调用 enq(Node node) 方法设置尾节点 123456789101112131415161718private Node enq(final Node node) &#123; //多次尝试，直到成功为止 for (;;) &#123; Node t = tail; //tail不存在，设置为首节点 if (t == null) &#123; if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //设置为尾节点 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; 在上面代码中，两个方法都是通过一个 CAS 方法 compareAndSetTail(Node expect, Node update)来设置尾节点，该方法可以确保节点是线程安全添加的。在 enq(Node node) 方法中，AQS 通过“死循环”的方式来保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去。 过程图如下： 出列 CLH 同步队列遵循 FIFO ，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head 执行该节点并断开原首节点的 next 和当前节点的 prev 即可，注意在这个过程是不需要使用 CAS 来保证的，因为只有一个线程能够成功获取到同步状态。过程图如下：]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池-tomcat]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0-tomcat%2F</url>
    <content type="text"><![CDATA[线程池在tomcat中的创建实现为： 123456789public abstract class AbstractEndpoint&lt;S&gt; &#123; public void createExecutor() &#123; internalExecutor = true; TaskQueue taskqueue = new TaskQueue(); TaskThreadFactory tf = new TaskThreadFactory(getName() + "-exec-", daemon, getThreadPriority()); executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), 60, TimeUnit.SECONDS,taskqueue, tf); taskqueue.setParent( (ThreadPoolExecutor) executor); &#125;&#125; 同时（重点）： tomcat 的线程池扩展了 jdk 的 executor ，而且队列用的是自己的 task queue ，因此其策略与 jdk 的有所不同，需要注意一下。 tomcat线程池策略 场景1：接受一个请求，此时 tomcat 启动的线程数还没有达到 corePoolSize ( tomcat 里头叫 minSpareThreads )， tomcat 会启动一个线程来处理该请求； 场景2：接受一个请求，此时 tomcat 启动的线程数已经达到了 corePoolSize ， tomcat 把该请求放入队列 (offer) ，如果放入队列成功，则返回，放入队列不成功，则尝试增加工作线程，在当前线程个数 &lt; maxThreads 的时候，可以继续增加线程来处理，超过 maxThreads 的时候，则继续往等待队列里头放，等待队列放不进去，则抛出 RejectedExecutionException ； 值得注意的是，使用 LinkedBlockingQueue 的话，默认是使用 Integer.MAX_VALUE ，即无界队列(这种情况下如果没有配置队列的 capacity 的话，队列始终不会满，那么始终无法进入开启新线程到达 maxThreads 个数的地步，则此时配置 maxThreads 其实是没有意义的)。 tomcat等待队列 而 TaskQueue 的队列 capacity 为 maxQueueSize ，默认也是 Integer.MAX_VALUE 。但是，其重写 offer 方法，当其线程池大小 &lt; maximumPoolSize 的时候，返回false，即在一定程度改写了队列满的逻辑，修复了使用LinkedBlockingQueue默认的 capacity为 Integer.MAX_VALUE 的时候， maxThreads 失效的 “bug” 。从而可以继续增长线程到 maxThreads ，超过之后，继续放入队列。 tomcat 的线程池使用了自己扩展的 taskQueue ，而不是 Executors 工厂方法里头用的 LinkedBlockingQueue 。(主要是修改了 offer 的逻辑) TaskQueue 实现的offer操作如下： 1234567891011121314151617181920212223package org.apache.tomcat.util.threads;import java.util.Collection;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.TimeUnit;public class TaskQueue extends LinkedBlockingQueue&lt;Runnable&gt; &#123; private ThreadPoolExecutor parent = null; @Override public boolean offer(Runnable o) &#123; //we can't do any checks if (parent==null) return super.offer(o); //we are maxed out on threads, simply queue the object if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o); //we have idle threads, just add it to the queue if (parent.getSubmittedCount()&lt;(parent.getPoolSize())) return super.offer(o); //当其线程池大小小于maximumPoolSize的时候，返回false if (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) return false; //if we reached here, we need to add it to the queue return super.offer(o); &#125;&#125; tomcat拒绝任务 这里改写了 jdk 线程池默认的 Rejected 规则，即 catch 住了 RejectedExecutionException 。正常 jdk 的规则是 core 线程数＋临时线程数 &gt; maxSize 的时候，就抛出 RejectedExecutionException 。这里 catch 住的话，继续往 taskQueue 里头放 123456789101112131415161718192021222324252627282930313233343536373839404142434445package org.apache.tomcat.util.threads;import java.util.concurrent.BlockingQueue;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadFactory;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicLong;import org.apache.tomcat.util.res.StringManager;public class ThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor &#123; /** * &#123;@inheritDoc&#125; */ @Override public void execute(Runnable command) &#123; execute(command,0,TimeUnit.MILLISECONDS); &#125; public void execute(Runnable command, long timeout, TimeUnit unit) &#123; submittedCount.incrementAndGet(); try &#123; super.execute(command); &#125; catch (RejectedExecutionException rx) &#123; if (super.getQueue() instanceof TaskQueue) &#123; final TaskQueue queue = (TaskQueue)super.getQueue(); try &#123; if (!queue.force(command, timeout, unit)) &#123; submittedCount.decrementAndGet(); throw new RejectedExecutionException("Queue capacity is full."); &#125; &#125; catch (InterruptedException x) &#123; submittedCount.decrementAndGet(); Thread.interrupted(); throw new RejectedExecutionException(x); &#125; &#125; else &#123; submittedCount.decrementAndGet(); throw rx; &#125; &#125; &#125;&#125; 重点看下 queue.force 方法 1234public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123; if ( parent.isShutdown() ) throw new RejectedExecutionException("Executor not running, can't force a command into the queue"); return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task is rejected &#125; 注意的是这里调用的 super.offer(o,timeout,unit) ，即 LinkedBlockingQueue ，只有当队列满的时候，返回 false ，才会抛出重新抛出 RejectedExecutionException 。 这里改变了 jdk 的 ThreadPoolExecutor 的 RejectedExecutionException 抛出的逻辑，也就是超出了 maxThreads 不会抛出 RejectedExecutionException ，而是继续往队列丢任务，而 taskQueue 本身是无界的，因此可以默认几乎不会抛出 RejectedExecutionException 回顾 JDK 线程池策略 每次提交任务时，如果线程数还没达到 coreSize 就创建新线程并绑定该任务。所以第 coreSize 次提交任务后线程总数必达到 coreSize ，不会重用之前的空闲线程。 线程数达到 coreSize 后，新增的任务就放到工作队列里，而线程池里的线程则努力的使用 take() 从工作队列里拉活来干。 如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。 临时线程使用 poll(keepAliveTime，timeUnit) 来从工作队列拉活，如果时候到了仍然两手空空没拉到活，表明它太闲了，就会被解雇掉。 如果 core 线程数＋临时线程数 &gt; maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder 。默认的 AbortPolicy 抛 RejectedExecutionException 异常，其他选择包括静默放弃当前任务(Discard)，放弃工作队列里最老的任务(DisacardOldest)，或由主线程来直接执行(CallerRuns). 1234567891011121314151617181920212223242526272829303132333435363738394041public class ThreadPoolExecutor extends AbstractExecutorService &#123; public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125;&#125; 总结tomcat 的线程池与 jdk 的使用无界 LinkedBlockingQueue 主要有如下两点区别： 举个例子：假设队列大小为 10，corePoolSize 为 3，maximumPoolSize 为 6，那么当加入 20 个任务时 jdk有界执行任务过程 核心线程(3) 1、2、3 等待队列(10) 4、5、6、… 12、13 非核心线程(3) 14、15、16 拒绝任务 17、18、19、20 任务执行顺序 1、2、3、14、15、16、4、5、6、… 12、13 tomcat执行任务过程 核心线程 1、2、3 等待队列（无界) 7、8、9、… 19、20 非核心线程 4、5、6 拒绝任务 任务执行顺序 1、2、3、4、5、6、… 19、20 ThreadPoolExecutor 的线程池增长策略是： 如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。 而 tomcat 的 ThreadPoolExecutor 使用的 taskQueue ，是无界的 LinkedBlockingQueue ，但是通过 taskQueue 的 offer 方法覆盖了 LinkedBlockingQueue 的 offer 方法，改写了规则，使得它也走 jdk 的 ThreadPoolExecutor 的有界队列的线程增长策略。 ThreadPoolExecutor 拒绝任务策略： jdk ，当 core线程数＋临时线程数 &gt; maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder 。 而 tomcat 的ThreadPoolExecutor 则改写了这个规则，即 catch 住了 RejectExecutionHanlder ，继续往队列里头放，直到队列满了才抛出 RejectExecutionHanlder 。而默认 taskQueue 是无界的。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[JAVA语言为我们提供了两种基础线程池的选择：ScheduledThreadPoolExecutor和ThreadPoolExecutor。它们都实现了ExecutorService接口（注意，ExecutorService接口本身和“线程池”并没有直接关系，它的定义更接近“执行器”，而“使用线程管理的方式进行实现”只是其中的一种实现方式）。这篇文章中，我们主要围绕 ThreadPoolExecutor 类进行讲解。 ThreadPoolExecutor的构造方法逻辑结构12345678910public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造函数中需要传入的参数包括corePoolSize、maximumPoolSize、keepAliveTime、timeUnit和workQueue。要明确理解这些参数（和后续将要介绍的参数）的含义，就首先要搞清楚 ThreadPoolExecutor 线程池的逻辑结构。 一定要注意一个概念，即存在于线程池中容器的一定是 Thread 对象，而不是您要求运行的任务（所以叫线程池而不叫任务池也不叫对象池，更不叫游泳池）；您要求运行的任务将被线程池分配给某一个空闲的 Thread 运行。从上图中，我们可以看到构成线程池的几个重要元素： 等待队列：顾名思义，就是您调用线程池对象的 submit() 方法或者 execute() 方法，要求线程池运行的任务（这些任务必须实现 Runnable 接口或者 Callable 接口）。但是出于某些原因线程池并没有马上运行这些任务，而是送入一个队列等待执行。 核心线程：线程池主要用于执行任务的是“核心线程”，“核心线程”的数量是您创建线程时所设置的 corePoolSize 参数决定的。如果不进行特别的设定，线程池中始终会保持 corePoolSize 数量的线程数（不包括创建阶段）。 非核心线程：一旦任务数量过多（由等待队列的特性决定），线程池将创建“非核心线程”临时帮助运行任务。您设置的大于 corePoolSize 参数小于 maximumPoolSize 参数的部分，就是线程池可以临时创建的“非核心线程”的最大数量。这种情况下如果某个线程没有运行任何任务，在等待 keepAliveTime 时间后，这个线程将会被销毁，直到线程池的线程数量重新达到corePoolSize。也就是说，并不是所谓的“非核心线程”才会被回收；而是谁的空闲时间达到 keepAliveTime 这个阀值，就会被回收。直到线程池中线程数量等于 corePoolSize 为止。 maximumPoolSize 参数也是当前线程池允许创建的最大线程数量。那么如果您设置的 corePoolSize 参数和您设置的 maximumPoolSize 参数一致时，线程池在任何情况下都不会回收空闲线程。 keepAliveTime 和 timeUnit 也就失去了意义。 keepAliveTime 参数和 timeUnit 参数也是配合使用的。 keepAliveTime 参数指明等待时间的量化值， timeUnit 指明量化值单位。例如 keepAliveTime=1，timeUnit 为 TimeUnit.MINUTES ，代表空闲线程的回收阀值为1分钟。 线程池种类 CachedThreadPool：一个任务创建一个线程； 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; FixedThreadPool：所有任务只能使用固定大小的线程； 123456public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。 1234567public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125; 完整的任务处理过程 1、首先您可以通过线程池提供的 submit() 方法或者 execute() 方法，要求线程池执行某个任务。线程池收到这个要求执行的任务后，会有几种处理情况： 1.1、如果当前线程池中运行的线程数量还没有达到 corePoolSize 大小时，线程池会创建一个新的线程运行您的任务，无论之前已经创建的线程是否处于空闲状态。 1.2、如果当前线程池中运行的线程数量已经达到设置的 corePoolSize 大小，线程池会把您的这个任务加入到等待队列中。直到某一个的线程空闲了，线程池会根据您设置的等待队列规则，从队列中取出一个新的任务执行。 1.3、如果根据队列规则，这个任务无法加入等待队列。这时线程池就会创建一个“非核心线程”直接运行这个任务。注意，如果这种情况下任务执行成功，那么当前线程池中的线程数量一定大于 corePoolSize 。 1.4、如果这个任务，无法被“核心线程”直接执行，又无法加入等待队列，又无法创建“非核心线程”直接执行，且您没有为线程池设置RejectedExecutionHandler。这时线程池会抛出 RejectedExecutionException 异常，即线程池拒绝接受这个任务。（实际上抛出 RejectedExecutionException 异常的操作，是 ThreadPoolExecutor 线程池中一个默认的 RejectedExecutionHandler 实现：AbortPolicy） 2、一旦线程池中某个线程完成了任务的执行，它就会试图到任务等待队列中拿去下一个等待任务（所有的等待任务都实现了BlockingQueue接口，按照接口字面上的理解，这是一个可阻塞的队列接口），它会调用等待队列的 poll() 方法，并停留在哪里。 3、当线程池中的线程超过您设置的 corePoolSize 参数，说明当前线程池中有所谓的“非核心线程”。那么当某个线程处理完任务后，如果等待 keepAliveTime 时间后仍然没有新的任务分配给它，那么这个线程将会被回收。线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于您设置的 corePoolSize 参数时，回收过程才会停止，还有回收的前提条件是线程数大于 corePoolSize。 allowCoreThreadTimeOut 前文我们讨论到，线程池回收线程只会发生在当前线程池中线程数量大于 corePoolSize 参数的时候；当线程池中线程数量小于等于 corePoolSize 参数的时候，回收过程就会停止。 allowCoreThreadTimeOut 设置项可以要求线程池：将包括“核心线程”在内的，没有任务分配的任何线程，在等待 keepAliveTime 时间后全部进行回收： 12ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 10, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;Runnable&gt;(1));poolExecutor.allowCoreThreadTimeOut(true); prestartAllCoreThreads 前文我们还讨论到，当线程池中的线程还没有达到您设置的 corePoolSize 参数值的时候，如果有新的任务到来，线程池将创建新的线程运行这个任务，无论之前已经创建的线程是否处于空闲状态。这个描述可以用下面的示意图表示出来： prestartAllCoreThreads设置项，可以在线程池创建，但还没有接收到任何任务的情况下，先行创建符合 corePoolSize 参数值的线程数： 12ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 10, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;Runnable&gt;(1));poolExecutor.prestartAllCoreThreads(); 使用ThreadFactory 线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在 ThreadPoolExecutor 线程池中，创建线程的工作交给ThreadFactory来完成。要使用线程池，就必须要指定ThreadFactory。 如果我们使用的构造函数时并没有指定使用的 ThreadFactory ，这个时候 ThreadPoolExecutor 会使用一个默认的 ThreadFactory：DefaultThreadFactory。 12345678910111213package test.thread.pool;import java.util.concurrent.ThreadFactory;/** * 测试自定义的一个线程工厂 */public class TestThreadFactory implements ThreadFactory &#123; @Override public Thread newThread(Runnable r) &#123; // do something before new thread created; // create new thread ， and return return new Thread(r); &#125;&#125; 线程池的等待队列 在使用 ThreadPoolExecutor 线程池的时候，需要指定一个实现了 BlockingQueue接口的任务等待队列。在 ThreadPoolExecutor 线程池的 API 文档中，一共推荐了三种等待队列，它们是：SynchronousQueue、LinkedBlockingQueue和ArrayBlockingQueue；但通过观察 BlockingQueue 接口的实现情况，您可以发现，能够直接使用的等待队列还有：PriorityBlockingQueue、LinkedBlockingDeque和LinkedTransferQueue。 有限队列 SynchronousQueue： 一种阻塞队列，其中每个 put 必须等待一个 take，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。即这是一个内部没有任何容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行插入操作的线程就要一直等待，反之亦然。 12345SynchronousQueue&lt;Object&gt; queue = new SynchronousQueue&lt;Object&gt;();// 不要使用add，因为这个队列内部没有任何容量，所以会抛出异常“IllegalStateException”// queue.add(new Object());// 操作线程会在这里被阻塞，直到有其他操作线程取走这个对象queue.put(new Object()); ArrayBlockingQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO （先进先出）原则对元素进行排序。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。 123456789// 我们创建了一个ArrayBlockingQueue，并且设置队列空间为2ArrayBlockingQueue&lt;Object&gt; arrayQueue = new ArrayBlockingQueue&lt;Object&gt;(2);// 插入第一个对象arrayQueue.put(new Object());// 插入第二个对象arrayQueue.put(new Object());// 插入第三个对象时，这个操作线程就会被阻塞。arrayQueue.put(new Object());// 请不要使用add操作，和SynchronousQueue的add操作一样，它们都使用了AbstractQueue中的add实现 无限队列 LinkedBlockingQueue： 在 ThreadPoolExecutor 线程池中常应用的等待队列。它可以指定容量也可以不指定容量。由于它具有“无限容量”的特性，所以我还是将它归入了无限队列的范畴（实际上任何无限容量的队列/栈都是有容量的，这个容量就是 Integer.MAX_VALUE ）。 LinkedBlockingQueue 的实现是基于链表结构，而不是类似 ArrayBlockingQueue 那样的数组。但实际使用过程中，您不需要关心它的内部实现，如果您指定了 LinkedBlockingQueue 的容量大小，那么它反映出来的使用特性就和 ArrayBlockingQueue 类似了。 1234567891011121314LinkedBlockingQueue&lt;Object&gt; linkedQueue = new LinkedBlockingQueue&lt;Object&gt;(2);linkedQueue.put(new Object());// 插入第二个对象linkedQueue.put(new Object());// 插入第三个对象时，这个操作线程就会被阻塞。linkedQueue.put(new Object());=======================================// 或者如下使用：LinkedBlockingQueue&lt;Object&gt; linkedQueue = new LinkedBlockingQueue&lt;Object&gt;();linkedQueue.put(new Object());// 插入第二个对象linkedQueue.put(new Object());// 插入第N个对象时，都不会阻塞linkedQueue.put(new Object()); LinkedBlockingDeque：一个基于链表的双端队列。 LinkedBlockingQueue 的内部结构决定了它只能从队列尾部插入，从队列头部取出元素；但是 LinkedBlockingDeque 既可以从尾部插入/取出元素，还可以从头部插入元素/取出元素。 1234567891011121314151617LinkedBlockingDeque&lt;TempObject&gt; linkedDeque = new LinkedBlockingDeque&lt;TempObject&gt;();// push ，可以从队列的头部插入元素linkedDeque.push(new TempObject(1));linkedDeque.push(new TempObject(2));linkedDeque.push(new TempObject(3));// poll ， 可以从队列的头部取出元素TempObject tempObject = linkedDeque.poll();// 这里会打印 tempObject.index = 3System.out.println("tempObject.index = " + tempObject.getIndex());// put ， 可以从队列的尾部插入元素linkedDeque.put(new TempObject(4));linkedDeque.put(new TempObject(5));// pollLast , 可以从队列尾部取出元素tempObject = linkedDeque.pollLast();// 这里会打印 tempObject.index = 5System.out.println("tempObject.index = " + tempObject.getIndex()); PriorityBlockingQueue： 一个按照优先级进行内部元素排序的无限队列。存放在 PriorityBlockingQueue 中的元素必须实现 Comparable 接口，这样才能通过实现 compareTo() 方法进行排序。优先级最高的元素将始终排在队列的头部； PriorityBlockingQueue 不会保证优先级一样的元素的排序，也不保证当前队列中除了优先级最高的元素以外的元素，随时处于正确排序的位置。 LinkedTransferQueue：一个无限队列，它除了具有一般队列的操作特性外（先进先出），还具有一个阻塞特性： LinkedTransferQueue 可以由一对生产者/消费者线程进行操作，当消费者将一个新的元素插入队列后，消费者线程将会一直等待，直到某一个消费者线程将这个元素取走，反之亦然。 拒绝任务 在 ThreadPoolExecutor 线程池中还有一个重要的接口：RejectedExecutionHandler。当提交给线程池的某一个新任务无法直接被线程池中“核心线程”直接处理，又无法加入等待队列，也无法创建新的线程执行；又或者线程池已经调用 shutdown() 方法停止了工作；又或者线程池不是处于正常的工作状态；这时候 ThreadPoolExecutor 线程池会拒绝处理这个任务，触发您创建 ThreadPoolExecutor 线程池时定义的 RejectedExecutionHandler 接口的实现。 ThreadPoolExecutor线程池在创建时，会使用一个默认的 RejectedExecutionHandler 接口实现 12345678910111213141516171819202122232425262728293031323334353637public class ThreadPoolExecutor extends AbstractExecutorService &#123; ...... /** * The default rejected execution handler */ private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); ...... // 可以看到，ThreadPoolExecutor中的两个没有指定RejectedExecutionHandler // 接口的构造函数，都是使用了一个RejectedExecutionHandler接口的默认实现：AbortPolicy public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; ...... public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; ......&#125; 实际上，在 ThreadPoolExecutor 中已经提供了四种可以直接使用的 RejectedExecutionHandler 接口的实现： CallerRunsPolicy：这个拒绝处理器，将直接运行这个任务的 run 方法。但是，请注意并不是在 ThreadPoolExecutor 线程池中的线程中运行，而是直接调用这个任务实现的 run 方法。 AbortPolicy：这个处理器，在任务被拒绝后会创建一个 RejectedExecutionException 异常并抛出。这个处理过程也是 ThreadPoolExecutor 线程池默认的 RejectedExecutionHandler 实现。 DiscardPolicy ： DiscardPolicy处理器，将会默默丢弃这个被拒绝的任务，不会抛出异常，也不会通过其他方式执行这个任务的任何一个方法，更不会出现任何的日志提示。 DiscardOldestPolicy：这个处理器很有意思。它会检查当前ThreadPoolExecutor线程池的等待队列。并调用队列的 poll() 方法，将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。 CallerRunsPolicy 在非线程池以外直接调用任务的 run 方法，可能会造成线程安全上的问题； ​ DiscardPolicy 默默的忽略掉被拒绝任务，也没有输出日志或者提示，开发人员不会知道线程池的处理过程出现了错误； ​ DiscardOldestPolicy 中 e.getQueue().poll() 的方式好像是科学的，但是如果等待队列出现了容量问题，大多数情况下就是这个线程池的代码出现了 BUG 。 ​ 最科学的的还是 AbortPolicy 提供的处理方式：抛出异常，由开发人员进行处理。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring AOP]]></title>
    <url>%2F2019%2F04%2F20%2Fspring-AOP%2F</url>
    <content type="text"><![CDATA[存在的意义 面向对象编程（ OOP ）有一些弊端，当需要为多个不具有继承关系的对象引人同一个公共行为时，例如日志、安全检测等，我们只有在每个对象里引用公共行为，这样程序中就产生了大量的重复代码，程序就不便于维护了，所以就有了一个对面向对象编程的补充，即面向方面编程（ AOP ), AOP 所关注的方向是横向的，不同于OOP 的纵向。 专有名词 通知Advice：你想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下 ； 连接点JoinPoint：spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的钱、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点 ； 切入点PoinCut：你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法 ； 切面Aspect：通知和切入点的结合 ，通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义 ； 织入Weaving：切面应用到目标对象来创建新的代理对象的过程 。 常用的AOPAspectJ、JBossAOP、SpringAOP]]></content>
      <categories>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring IOC]]></title>
    <url>%2F2019%2F04%2F20%2Fspring-IOC%2F</url>
    <content type="text"><![CDATA[作用spring ioc是spring的特性，称为控制反转。将对象的创建、初始化和销毁交由容器管理。实现方式有依赖查找和依赖注入。 原理在spring容器启动的时候，通过反射的方式，主动加载（或延迟加载）我们主动配置的bean以及该bean的依赖对象。 好处在不同的业务之间的相互调用，我们无需去关注业务对象的产生。而更注重业务之间的逻辑，这在复杂工程中显得尤为重要。 spring构造对象的三种方法 采用默认的构造函数创建 1&lt;bean class="com.mc.base.learn.spring.bean.Person" id="person"&gt; 静态工厂创建 1&lt;bean id="bean" class="com.mc.base.learn.spring.factory.PersonStaticFactory" factory-method="createPerson"&gt; 实例化工厂 123 &lt;!-- 实例工程方法需要先创建工厂实例，然后在创建所需对象的时候，将其赋值为factory-bean --&gt;&lt;bean id="personFactory" class="com.mc.base.learn.spring.factory.PersonFactory"&gt;&lt;/bean&gt;&lt;bean id="person2" factory-bean="personFactory" factory-method="createInstance"&gt;&lt;/bean&gt; spring初始化的三种方式 通过实现 InitializingBean/DisposableBean 接口来定制初始化之后/销毁之前的操作方法； 通过&lt;bean&gt;元素的init-method/destroy-method属性指定初始化之后 /销毁之前调用的操作方法； 在指定方法上加上@PostConstruct 或@PreDestroy注解来制定该方法是在初始化之后还是销毁之前调用]]></content>
      <categories>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义确保一个类只有一个实例，并提供该实例的全局访问点 。 数据结构 私有构造函数、私有静态变量、公有静态函数 保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量 分类懒汉式 饿汉式]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链]]></title>
    <url>%2F2019%2F04%2F19%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%2F</url>
    <content type="text"><![CDATA[定义使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 数据结构 demo123456789101112public abstract class Handler &#123; protected Handler successor; public Handler(Handler successor) &#123; this.successor = successor; &#125; protected abstract void handleRequest(Request request);&#125; 123456789101112131415161718public class ConcreteHandler1 extends Handler &#123; public ConcreteHandler1(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.TYPE1) &#123; System.out.println(request.getName() + " is handle by ConcreteHandler1"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; 123456789101112131415161718public class ConcreteHandler2 extends Handler &#123; public ConcreteHandler2(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.TYPE2) &#123; System.out.println(request.getName() + " is handle by ConcreteHandler2"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; 123456789101112131415161718192021public class Request &#123; private RequestType type; private String name; public Request(RequestType type, String name) &#123; this.type = type; this.name = name; &#125; public RequestType getType() &#123; return type; &#125; public String getName() &#123; return name; &#125;&#125; 123public enum RequestType &#123; TYPE1, TYPE2&#125; 1234567891011121314public class Client &#123; public static void main(String[] args) &#123; Handler handler1 = new ConcreteHandler1(null); Handler handler2 = new ConcreteHandler2(handler1); Request request1 = new Request(RequestType.TYPE1, "request1"); handler2.handleRequest(request1); Request request2 = new Request(RequestType.TYPE2, "request2"); handler2.handleRequest(request2); &#125;&#125; 123&gt; request1 is handle by ConcreteHandler1&gt; request2 is handle by ConcreteHandler2&gt; Java中的应用 java.util.logging.Logger#log() Apache Commons Chain javax.servlet.Filter#doFilter()]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人的运动范围]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[题目描述地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？ 思路深度遍历 123456789101112131415161718192021222324252627282930313233343536373839404142private static final int[][] next = &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;private int cnt = 0;private int rows;private int cols;private int threshold;private int[][] digitSum;public int movingCount(int threshold, int rows, int cols) &#123; this.rows = rows; this.cols = cols; this.threshold = threshold; initDigitSum(); boolean[][] marked = new boolean[rows][cols]; dfs(marked, 0, 0); return cnt;&#125;private void dfs(boolean[][] marked, int r, int c) &#123; if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols || marked[r][c]) return; marked[r][c] = true; if (this.digitSum[r][c] &gt; this.threshold) return; cnt++; for (int[] n : next) dfs(marked, r + n[0], c + n[1]);&#125;private void initDigitSum() &#123; int[] digitSumOne = new int[Math.max(rows, cols)]; for (int i = 0; i &lt; digitSumOne.length; i++) &#123; int n = i; while (n &gt; 0) &#123; digitSumOne[i] += n % 10; n /= 10; &#125; &#125; this.digitSum = new int[rows][cols]; for (int i = 0; i &lt; this.rows; i++) for (int j = 0; j &lt; this.cols; j++) this.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中的路径]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下面的矩阵包含了一条 bfce 路径。 思路回溯法： 1234567891011121314151617181920212223242526272829303132333435363738private final static int[][] next = &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;private int rows;private int cols;public boolean hasPath(char[] array, int rows, int cols, char[] str) &#123; if (rows == 0 || cols == 0) return false; this.rows = rows; this.cols = cols; boolean[][] marked = new boolean[rows][cols]; char[][] matrix = buildMatrix(array); for (int i = 0; i &lt; rows; i++) for (int j = 0; j &lt; cols; j++) if (backtracking(matrix, str, marked, 0, i, j)) return true; return false;&#125;private boolean backtracking(char[][] matrix, char[] str, boolean[][] marked, int pathLen, int r, int c) &#123; if (pathLen == str.length) return true; if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols || matrix[r][c] != str[pathLen] || marked[r][c]) return false; marked[r][c] = true; for (int[] n : next) if (backtracking(matrix, str, marked, pathLen + 1, r + n[0], c + n[1])) return true; marked[r][c] = false; return false;&#125;private char[][] buildMatrix(char[] array) &#123; char[][] matrix = new char[rows][cols]; for (int i = 0, idx = 0; i &lt; rows; i++) for (int j = 0; j &lt; cols; j++) matrix[i][j] = array[idx++]; return matrix;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组的最小数字]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。 思路在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为 O(logN)。 本题可以修改二分查找算法进行求解： 当 nums[m] &lt;= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m； 否则解在 [m + 1, h] 之间，令 l = m + 1。 12345678910111213public int minNumberInRotateArray(int[] nums) &#123; if (nums.length == 0) return 0; int l = 0, h = nums.length - 1; while (l &lt; h) &#123; int m = l + (h - l) / 2; if (nums[m] &lt;= nums[h]) h = m; else l = m + 1; &#125; return nums[l];&#125; 拓展如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。 12345678910111213141516171819202122public int minNumberInRotateArray(int[] nums) &#123; if (nums.length == 0) return 0; int l = 0, h = nums.length - 1; while (l &lt; h) &#123; int m = l + (h - l) / 2; if (nums[l] == nums[m] &amp;&amp; nums[m] == nums[h]) return minNumber(nums, l, h); else if (nums[m] &lt;= nums[h]) h = m; else l = m + 1; &#125; return nums[l];&#125;private int minNumber(int[] nums, int l, int h) &#123; for (int i = l; i &lt; h; i++) if (nums[i] &gt; nums[i + 1]) return nums[i + 1]; return nums[l];&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩形覆盖]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[题目描述我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 思路由于小矩形的尺寸是2×1，所以有大矩形为2×n的存在，那么我们第一步就可以有两种处理方式： 第一步如果选择竖方向填充，那么该问题的规模就缩减为对于剩余的2*(n-1)的大矩形的填充 ； 第一步如果选择横方向的填充，则第二排的前面两个小矩形也只能如此填充，那么该问题的规模就缩减为对于剩余的2*(n-2)的大矩形的填充 。 结合上述分析，很容易得到递推的关系： rectCover(n) = rectCover(n-1)+rectCover(n-2)。当然此处也要注意递归跳出条件的判定 。 12345678910111213public int rectCover(int n)&#123; if(n&lt;=2) return n; int ret1 = 1; int ret2 = 2; int ret = 1; for(int i=3; i&lt;=n; i++)&#123; ret = ret1 + ret2; ret1 = ret2; ret2 = ret; &#125; return ret;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述求斐波那契数列的第 n 项，n &lt;= 39。 思路 递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。 1234567891011public int Fibonacci(int n) &#123; if(n&lt;=1) return n; int[] fib = new fib[n+1]; fib[0] = 0; fib[1] = 1; for(int i=2; i&lt;=n; i++)&#123; fib[i] = fib[i-1] + fib[i-2]; &#125; return fib[n];&#125; 考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。 12345678910111213public int Fibonacci(int n) &#123; if(n&lt;=1) return n; int fib1 = 0; int fib2 = 1; int result = 0; for(int i=2; i&lt;=n; i++)&#123; result = fib1 + fib2; fib1 = fib2; fib2 = result; &#125; return result;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>空间优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 思路in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。 1234567891011121314151617Stack&lt;Integer&gt; in = new Stack&lt;&gt;();Stack&lt;Integer&gt; out = new Stack&lt;&gt;();public void push(int node)&#123; in.push(node);&#125;public int pop() throws Exception&#123; if(out.isEmpty())&#123; while(!in.isEmpty())&#123; out.push(in.pop()); &#125; &#125; if(out.isEmpty()) throw new Exception("queue is empty!"); return out.pop();&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2019%2F04%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路 该节点的右子树不为空，则下一节点是该节点右子树中最左节点； 该节点的右子树为空，则下一节点是包含该节点的最小左子树的子树根节点。 1234567891011121314151617181920212223242526//二叉树结点结构class TreeNode&#123; int val; TreeNode left; TreeNode right; TreeNode parent;&#125;public TreeNode getNext(TreeNode node)&#123; if(node.right!=null)&#123; TreeNode temp = node.right; while(temp.left!=null)&#123; temp = temp.left; &#125; return temp; &#125; else&#123; while(node.parent!=null)&#123; TreeNode parent = node.parent; if(parent.left==node) return parent; node = parent; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>中序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2019%2F04%2F18%2F%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] 思路前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。 1234567891011121314151617181920212223242526272829//二叉树结构class TreeNode&#123; int val; TreeNode left; TreeNode right; TreeNode(int val)&#123;this.val = val; left = null; right = null&#125;;&#125;//缓存中序遍历数组每个值对应的索引public Map&lt;Integer, Integer&gt; indexForInOrder = new HashMap&lt;&gt;();public TreeNode reConstructBinaryTree(int[] pre, int[] in)&#123; for(int i=0; i&lt;in.length; i++)&#123; indexForInOrder.put(in[i], i); &#125; return reConstructBianryTree(pre, 0, pre.length-1, 0);&#125;//参数：前序遍历数组、前序部分数组左边界，前序部分数组右边界、中序部分数组左边界private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL)&#123; if(preL &gt; preR) return null; TreeNode root = new TreeNode(pre[preL]); int leftTreeSize = indexForInOrder(root.val) - inL; //对于preL和preR的计算：DLR //对于inL的计算：LDR root.left = reConstructBinaryTree(pre, preL+1, preL+leftTreeSize, inL);//D(L)R root.right = reConstructBinaryTree(pre, preL+leftSize+1, preR, inL+leftTreeSize+1);//DL(R) return root;&#125; 拓展重建一棵二叉树： 前序+中序 后序+中序 1234567891011121314151617181920212223242526272829//二叉树结构class TreeNode&#123; int val; TreeNode left; TreeNode right; TreeNode(int val)&#123;this.val = val; left = null; right = null&#125;;&#125;//缓存中序遍历数组每个值对应的索引public Map&lt;Integer, Integer&gt; indexForInOrder = new HashMap&lt;&gt;();public TreeNode reConstructBinaryTree(int[] next, int[] in)&#123; for(int i=0; i&lt;in.length; i++)&#123; indexForInOrder.put(in[i], i); &#125; return reConstructBianryTree(next, next.length-1, 0, 0);&#125;//参数：后序遍历数组、后序部分数组右边界，后序部分数组左边界、中序部分数组左边界private TreeNode reConstructBinaryTree(int[] next, int nextR, int nextL, int inL)&#123; if(nextL &gt; nextR) return null; TreeNode root = new TreeNode(next[nextR]); int rightTreeSize = indexForInOrder(root.val) - inL; //对于nextR和nextL的计算：LRD //对于inL的计算：LDR root.right = reConstructBinaryTree(next, nextR-1, nextR-rightTreeSize, inL);//L(R)D root.left = reConstructBinaryTree(pre, nextR-rightTreeSize-1, nextL, inL+leftTreeSize+1);//(L)RD return root;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>前序</tag>
        <tag>后序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2019%2F04%2F18%2F%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述反转链表，返回反转后链表头部 Input: 1-&gt;2-&gt;3 Output: 3-&gt;2-&gt;1 思路1234class Node&#123; int val; Node next;&#125; 递归 12345678910public Node reverseList(Node head)&#123; if(head==null || head.next==null)//如果没有节点或者只有一个节点直接返回 return head; Node cur = head.next;//保存当前节点的下一个节点 head.next = null;//打断当前节点的指针域，使之能够成为末尾节点 Node newHead = reverseList(cur); //返回以pNext为头的反转链表， //返回之后newHead为新头，pNext为末节点 cur.next = head;//在以newHead为头、以pNext为末的新链表中接上应该为末节点的head return newHead;&#125; 栈 1234567891011121314151617public Node reverseList(Node head)&#123; if(head==null || head.next==null) return head; Stack&lt;Node&gt; s = new Stack&lt;&gt;(); Node newHead = null;//记录最后一个指针,即反转后头节点 while(head.next!=null)&#123;//最后一个指针不入栈，方便出栈容易实现 s.push(head); head = head.next; &#125; newHead = head; while(!s.isEmpty())&#123; head.next = s.pop(); head = head.next; &#125; head.next = null; return newHead;&#125; 遍历 12345678910111213public Node reverseList(Node head)&#123; Node newHead = null;//反转后的新头节点 Node cur = head; //当前节点 Node pre = null; //当前节点前一节点 while(node!=null)&#123; Node next = cur.next; //当前节点后一节点 if(next==null) newHead = cur; cur.next = pre;//当前节点下一节点指向前节点，起到反转作用 pre = cur; cur = next;//三个指针整体向后移动，起到遍历效果 &#125;&#125; 拓展反转部分链表，反转[m,n]之间的链表 Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 [2,5] Output: 1-&gt;5-&gt;4-&gt;3-&gt;2-&gt;6 个人感觉递归实现困难，采用栈和遍历的方式应该简单（只要记录以下入栈节点个数或者遍历个数即可）]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>反转</tag>
        <tag>递归</tag>
        <tag>遍历</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[替换空格]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目描述将一个字符串中的空格替换成 “%20”。 12345Input:&quot;A B&quot;Output:&quot;A%20B&quot; 解题思路在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。 12345678910111213141516171819public String replaceSpace(StringBuffer str) &#123; int P1 = str.length() - 1; for (int i = 0; i &lt;= P1; i++) if (str.charAt(i) == ' ') str.append(" "); int P2 = str.length() - 1; while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) &#123; char c = str.charAt(P1--); if (c == ' ') &#123; str.setCharAt(P2--, '0'); str.setCharAt(P2--, '2'); str.setCharAt(P2--, '%'); &#125; else &#123; str.setCharAt(P2--, c); &#125; &#125; return str.toString();&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>替换</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F2019%2F04%2F18%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。 1234567891011Consider the following matrix:[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false. 思路要求时间复杂度 O(M + N)，空间复杂度 O(1)。 该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 12345678910111213141516public boolean Find(int target, int[][] matrix) &#123; if(matrix==null || matrix.length==0 || matrix[0].length==0) return false; int row = matrix.length; int col = matrix[0].length; int r = 0, c = col-1;//从右上角开始 while(r&lt;=row-1 &amp;&amp; c&gt;=0)&#123; if(target == matrix[r][c]) return true; else if(target &gt; matrix[r][c]) r++; else c--; &#125; return false;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中重复的数字]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 Input:{2, 3, 1, 0, 2, 5} Output:2 思路要求是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。 以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复： 12345678910111213141516171819public boolean duplicate(int[] nums, int length, int[] duplicatin)&#123; if(nums==null || length==0) return false; for(int i=0; i&lt;length; i++)&#123; while(nums[i]!=i)&#123; if(nums[i]==nums[nums[i]])&#123; duplication[0] = nums[i]; return true; &#125; swap(nums, i, nums[i]); &#125; &#125;&#125;private void swap(int[] nums, int i, int j)&#123; int temp = nums[i]; nums[j] = nums[i]; nums[i] = temp;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>重复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为运算表达式设计优先级]]></title>
    <url>%2F2019%2F03%2F22%2F%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[回溯搜索。该问题牵涉到括号的组合问题，一般使用递归+回溯的思想。主要想法： 递归回溯。可以产生所有的组合方式。 每个小组合方式相当于一个子集，不断的将计算结果返回给上一层。 举例：a + (b - (c d))会不断的变成a + (b - (res1 res2))-&gt; a + (res1 - res2) -&gt; res1 res2 计算结果需要for循环！！！其实有这种情况，a + (b - (c d))和a + (b - c) d))，这里 a +res2，res2就可能有多种情况。 ​123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; ways = new ArrayList&lt;&gt;(); for(int i=0; i&lt;input.length(); i++)&#123; char c = input.charAt(i); if(c=='+' || c=='-' || c=='*')&#123; List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0, i)); List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+1)); for(Integer l : left)&#123; for(Integer r : right)&#123; switch(c)&#123; case '+': ways.add(l+r); break; case '-': ways.add(l-r); break; case '*': ways.add(l*r); break; &#125; &#125; &#125; &#125; &#125; if(ways.size()==0) ways.add(Integer.valueOf(input)); return ways; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>leetcode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>括号</tag>
        <tag>组合</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F03%2F22%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找基本实现12345678910111213public int binarySearch(int[] nums, int key)&#123; int l = 0, h = nums.length-1; while(l&lt;=h)&#123; int mid = l+(h-l)/2; //防止(h+l)/2加法溢出 if(nums[mid]==key) return mid; else if(nums[mid]&gt;key) h = mid-1; else l = mid+1; &#125; return -1;&#125; 变种二分查找，找出数组中key重复元素最左位置(注意边界)1234567891011121314public int binarySearch(int[] nums, int key)&#123; int l=0, h=nums.length-1; while(l&lt;h)&#123; int mid = l+(h-l)/2; if(nums[mid]&gt;=key) h = mid; else l = mid+1; &#125; if(nums[l]==key) return l; else return -1;&#125; leetcode上二分查找题1234567891011121314151617//求开方 69. Sqrt(x) (Easy)public int mySqrt(int x)&#123; if(x&lt;=1) return x; int l=1,h=x; while(l&lt;=h)&#123; int mid = l+(h-l)/2; int sqrt = x/mid; if(sqrt==mid) return mid; else if(mid&gt;sqrt) h = mid-1; else l = mid+1; &#125; return h;&#125; 12345678910111213//给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符//744. Find Smallest Letter Greater Than Target (Easy)public char nextGreatestLetter(char[] letters, char target)&#123; int l=0, h=letters.length-1; while(l&lt;=h)&#123; int mid = l+(h-l)/2; if(letters[mid]&lt;=target) l = mid+1; else h = mid-1; &#125; return l&lt;letters.length ? letters[l] : letters[0];&#125; 123456789101112131415161718//以O(logN)时间复杂度找出有序数组中唯一不出现2次的元素//540. Single Element in a Sorted Array (Medium)//假设index是该元素所在位置，mid是偶数，则当(mid+1&lt;index)时，nums[m]==nums[m+1];//当(mid+1&gt;=index),nums[m]!=nums[m+1]//因此，m为偶数的情况下，当nums[m]==nums[m+1],index所在区间应该为[m+2,h];否则，index在[l,m];public int singleNonDuplicate(int[] nums)&#123; int l=0, h=nums.length-1; while(l&lt;h)&#123; int mid = l+(h-l)/2; if(mid%2==1) mid--; //保证mid是偶数 if(nums[mid]==nums[mid+1) l = m+2; else h = m; &#125; return h;&#125; 123456789101112//旋转数组中的最小数字 153. Find Minimum in Rotated Sorted Array (Medium)public int findMin(int[] nums)&#123; int l=0, h=nums.length-1; while(l&lt;h)&#123; int mid = l+(h-l)/2; if(nums[mid]&lt;=nums[h]) h = mid; else l = mid+1; &#125; return nums[l];&#125; 123456789101112131415161718192021222324252627282930//查找区间，找到最左位置，找到最右位置//34. Search for a Range (Medium)public int findRange(int[] nums, int target)&#123; int first=0, last=0; int l=0, h=nums.length-1; //找最左位置 while(l&lt;h)&#123; int mid = l+(h-l)/2; if(nums[mid]&gt;=target) h = mid; else l = mid+1; &#125; if(nums[l]!=target) return new int&#123;-1,-1&#125;; else&#123; first = l; //找最右位置 l=0, h=nums.length-1; while(l&lt;h)&#123; int mid = l+(h-l+1)/2;//这里mid选择向上取整，否则会死循环 if(nums[mid]&lt;=target) l = mid; else h = mid-1; &#125; last = h; return new int&#123;first, last&#125;; &#125;&#125; ​ 总结关于while里的判断条件，如果缩小区间的形式是l = m-1 &amp;&amp; h = m+1（即两边闭区间），那么判断条件是l&lt;=h；否则应该是l&lt;h]]></content>
      <categories>
        <category>编程</category>
        <category>leetcode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程同步]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[进程中线程同步的四种常用方式：临界区（CCriticalSection)当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区对象的线程可以访问被保护的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程释放临界区为止。 定义临界区对象CCriticalSection g_CriticalSection； 在访问共享资源之前，先获取临界区对象，g_CriticalSection； 访问资源结束后，释放临界区对象，g_CriticalSection.unLock(); 事件（CEvent）事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。每个Cevent对象可以有两种状态： 信号状态和无信号状态。Cevent类对象有两种类型： 自动事件对象：在被至少一个线程释放后自动返回到无信号状态； 人工事件对象：获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。在创 建Cevent对象时，默认创建的是自动事件。 互斥量（CMutex）互斥对象和临界区对象非常相似，只是互斥量允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。 互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。 信号量（CSemphore）当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现LRU策略缓冲]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%AE%9E%E7%8E%B0LRU%E7%AD%96%E7%95%A5%E7%BC%93%E5%86%B2%2F</url>
    <content type="text"><![CDATA[1.基于双向链表+HashMap实现： 访问某个节点时，将该节点从双向链表中原位置删除，并重新插入链表头。这样可以保证链表尾部节点就是最近最久未被使用的，当节点数量大于缓存空间就淘汰链表尾部节点； 为了能在O(1)时间内从链表删除某个节点，不能通过遍历链表查找该节点。需要借助HashMap存储key与节点的映射，通过key在O(1)时间内找到节点，并在O(1)时间内删除该节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class LRU&lt;K, V&gt; implements Iterable&lt;K&gt; &#123; private Node head; private Node tail; private HashMap&lt;K, Node&gt; map; private int maxSize; private class Node &#123; Node pre; Node next; K k; V v; public Node(K k, V v) &#123; this.k = k; this.v = v; &#125; &#125; public LRU(int maxSize) &#123; this.maxSize = maxSize; this.map = new HashMap&lt;&gt;(maxSize * 4 / 3); head = new Node(null, null); tail = new Node(null, null); head.next = tail; tail.pre = head; &#125; public V get(K key) &#123; if (!map.containsKey(key)) &#123; return null; &#125; Node node = map.get(key); unlink(node); appendHead(node); return node.v; &#125; public void put(K key, V value) &#123; if (map.containsKey(key)) &#123; Node node = map.get(key); unlink(node); &#125; Node node = new Node(key, value); map.put(key, node); appendHead(node); if (map.size() &gt; maxSize) &#123; Node toRemove = removeTail(); map.remove(toRemove.k); &#125; &#125; private void unlink(Node node) &#123; Node pre = node.pre; Node next = node.next; pre.next = next; next.pre = pre; node.pre = null; node.next = null; &#125; private void appendHead(Node node) &#123; Node next = head.next; node.next = next; next.pre = node; node.pre = head; head.next = node; &#125; private Node removeTail() &#123; Node node = tail.pre; Node pre = node.pre; tail.pre = pre; pre.next = tail; node.pre = null; node.next = null; return node; &#125; @Override public Iterator&lt;K&gt; iterator() &#123; return new Iterator&lt;K&gt;() &#123; private Node cur = head.next; @Override public boolean hasNext() &#123; return cur != tail; &#125; @Override public K next() &#123; Node node = cur; cur = cur.next; return node.k; &#125; &#125;; &#125;&#125; 2.使用Java容器中的LinkedHashMap LinkedHashMap继承自HashMap，因此具有和HashMap一样的快速查找特性； 内部维护了一个双向链表，用来维护插入顺序或者LRU顺序；accessOrder字段决定了顺序，默认为false（插入顺序）； 因此，LinkedHashMap = 双向链表+HashMap. 但是LinkedHashMap实现的LRU缓存与第1个实现方式有一点 区别，即LinkedHashMap的链表首部才是最近最久未使用节点 ；当然，这个区别对于双向链表来说不是事儿，只是寓意上的区别而已（在我看来）。 访问一个节点时，调用get()方法，get()中有一个函数afterNodeAccess()；该方法用于将该节点移到链表尾部（最近访问节点） ​123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 在put等操作之后执行afterNodeInsertion()，当removeEldestEntry()方法返回true时会移除最晚的节点，也就是链表首部节点；evict只有在构建Map时才为false，在这里为true. ​1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; removeEldestEntry()默认为false，也就是说put操作后执行的afterNodeInsertion()并没有移除首部节点，也就没有LRU缓存淘汰的说法了；如果需要让它为true，需要继承LinkedHashMap并且覆盖该方法； ​123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 因此，要用LinkedHashMap来实现一个LRU缓存，需要：1.设定最大缓存空间MAX_ENTRIES2.使用LinkedHashMap的构造方法将accessOrder设置为true，开启LRU顺序；3.覆盖removeEldestEntry（）方法实现，在节点多于MAX_ENTRIES就会将最近最久未使用的节点删除。 1234567891011121314151617181920212223class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125;&#125;public class LRUTest&#123; - public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, "a"); cache.put(2, "b"); cache.put(3, "c"); cache.get(1); cache.put(4, "d"); System.out.println(cache.keySet()); &#125;&#125; ​]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java容器</tag>
        <tag>LRU</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程的中断操作]]></title>
    <url>%2F2019%2F03%2F06%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[InterruptedException如果一个线程处于阻塞、限期等待或无限期等待状态时，调用该线程的interrupt()方法中断线程，就会抛出InterruptedException，从而提前结束该线程；（注意：不能中断IO阻塞和Synchronized锁阻塞） Interupted 如果一个线程的run()方法执行一个循环体，并且循环体中没有会抛出InterruptedException的操作（如sleep())，那么该线程调用interrupted()就无法中断线程； 由于一个线程调用interrupt()会设置线程中断标志，该标志可以通过interrupted()来获取；因此可以在run()方法的循环体中以该标志来判断线程是否处于中断状态，以结束线程。 Executor中断操作 Executor的shutDown()会等待所有线程执行完毕之后再关闭；而调用shutDownNow()，相当于调用每个线程的interrupt()方法，中断所有线程； 如果只想中断Executor中的一个线程，可以使用submit()提交一个线程，该方法返回一个Future&lt;?&gt;对象，通过调用该对象的cancel(true)方法中断线程。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web页面请求过程]]></title>
    <url>%2F2019%2F03%2F06%2FWeb%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[转自： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/计算机网络.md#web-页面请求过程 DHCP配置主机信息 假设主机最开始没有IP地址以及其他信息，那么就需要先使用DHCP来获取； 主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中； 该报文段则被放入在一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中； 该数据报则被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备； 连接在交换机的DHCP服务器收到广播帧之后，不断向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中； 该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧； 主机收到该帧后，不断向上分解得到DHCP报文。之后就配置它的IP地址，子网掩码和DNS服务器IP地址，并在其IP转发表中安装默认网关． ARP解析MAC地址 主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成该套接字，主机需要知道网站的域名对应的IP地址。 主机生成一个DNS查询报文，该报文具有53端口，因为DNS服务器的端口号时53； 该DNS查询报文被放入目的地址为DNS服务器的IP数据报中； 该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器； DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议； 主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将该ARP查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器； 网关路由器接收到该帧后，不断向上分解得到ARP报文，发现其中的IP地址与其接口的IP地址匹配，因此就发送ARP回答报文，包含了它的MAC地址，发回给主机。 DNS解析域名 知道了网关路由器的MAC地址之后，就可以继续DNS的解析过程了； 网关路由器接收到包含DNS查询报文的以太网帧后，抽取出IP数据报，并根据转发表决定该IP数据报应该转发的路由器； 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达DNS服务器的路由表项； 到达DNS服务器后，DNS服务器抽取出DNS查询报文，并在DNS数据库中查找待解析的域名； 找到DNS记录之后，发送DNS回答报文，将该回答报文放入UDP报文段中，然后放入IP数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 HTTP请求页面 有了HTTP服务器的IP地址，主机就能够生成TCP套接字，该套接字将用于向Web服务器发送HTTP GET报文； 在生成TCP套接字之前，必须先与HTTP服务器进行三次握手来建立连接。生成一个具有目的端口80的TCP SYN报文段，并向HTTP服务器发送该报文段； HTTP服务器接到该报文段之后，生成TCP SYN ACK报文段，发回给主机； 连接建立之后，浏览器生成HTTP GET报文，并交付给HTTP服务器； HTTP服务器从TCP套接字中读取HTTP GET报文，生成一个HTTP响应报文，将Web页面内容放入报文体中，发回给主机； 浏览器收到HTTP响应报文后，抽取出Web页面内容，之后进行渲染，显示Web页面。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>DHCP</tag>
        <tag>ARP</tag>
        <tag>DNS</tag>
        <tag>HTTP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五种IO模型]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一个输入操作通常有两个阶段： 等待数据准备，即从存储介质（磁盘，网络等）拷贝到内核； 从内核向进程复制数据 阻塞I/O 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回 非阻塞I/O 应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。 I/O复用 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中； 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。 信号驱动I/O 通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的； 当数据报准备好被读时，就为该进程生成一个SIGIO信号； 应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。 异步I/O 应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号； 调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。 对比五种I/O模型 同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞； 异步I/O：在I/O操作未完成前，请求进程未被阻塞。 阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BitSet]]></title>
    <url>%2F2019%2F03%2F02%2FBitSet%2F</url>
    <content type="text"><![CDATA[JAVA中BitSet就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个数据结构KEY和Value的保存需要消耗较多的内存，不适合保存较多的数据，即大数据场景；比如在有10亿条URL中判定一个（ www.baidu.com ）是否存在，如果我们使用常规的hashmap来保存将是不现实的，因为URL本身需要占据较多的内存而无法直接操作。如果我们使用bitset来保存，那么可以对一条URL求hashcode，并将数字映射在bitset上，那么事实上它只需要bitset上的一个bit位即可，即我们1位空间即可表达一个URL字符串的存在性。 所谓“存在性”，就是通过BitSet来检测一个数字是否存在。 BitSet原理JAVA中，一个long型数字占用64位空间，根据上述“位图”的概念，那么一个long型数字（4个字节）就可以保存64个数字的“存在性”状态(无碰撞冲突时，即true、false状态)。比如50个数字{0,1,10,…63}，判定“15”是否存在，那么我们通常会首先将这些数字使用数组或者hashmap保存，然后再去判定，那么保存这些这些数据需要占用64 * 64位；如果使用位图，那么一个long型数字即可。（如果换成50个字符串，那么其节约的空间可能更大）。 BitSet只面向数字比较，比如set(int a,boolean value)方法，将数字a在bitSet中设定为true或者false；此后可以通过get(int a)方法检测结果。对于string类型的数据，如果像使用BitSet，那么可以将其hashcode值映射在bitset中。 首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 数字范围 [0,63] [64,127] [128,191] … long数组索引 0 1 2 … bitSet内部的long[]数组是基于向量的，即随着set的最大数字而动态扩展。数组的最大长度计算： 1(maxValue - 1) &gt;&gt; 6 + 1 BitSet中set方法伪代码： 1234567public void set(int number) &#123; int index = number &gt;&gt; 6;//找到number需要映射的数组的index。 if(index + 1 &gt; length) &#123; ensureCapacity(index + 1);//重新扩展long[]数组 &#125; long[index] |= (1L &lt;&lt; number);//冲突解决 &#125; 使用BitSet本例中使用bitSet做String字符串的存在性校验。 12345678910BitSet bitSet = new BitSet(Integer.MAX_VALUE);//hashcode的值域 //0x7FFFFFFF String url = "http://baidu.com/a"; int hashcode = url.hashCode() &amp; 0x7FFFFFFF; bitSet.set(hashcode); System.out.println(bitSet.cardinality());//着色位的个数 System.out.println(bitSet.get(hashcode));//检测存在性 bitSet.clear(hashcode);//清除位数据 BitSet与Hashcode冲突因为BitSet API只能接收int型的数字，即只能判定int数字是否在bitSet中存在。所以，对于String类型，我们通常使用它的hashcode，但这有一种隐患，java中hashcode存在冲突问题，即不同的String可能得到的hashcode是一样的（即使不重写hashcode方法），如果我们不能很好的解决这个问题，那么就会出现“数据抖动”—不同的hashcode算法、运行环境、bitSet容量，会导致判断的结果有所不同。比如A、B连个字符串，它们的hashcode一样，如果A在BitSet中“着色”(值为true)，那么检测B是否在BitSet存在时，也会得到true。 这个问题该如何解决或者缓解呢？ 调整hashcode生成算法：我们可以对一个String使用多个hashcode算法，生成多个hashcode，然后在同一个BitSet进行多次“着色”，在判断存在性时，只有所有的着色位为true时，才判定成功 12345678String url = "http://baidu.com/a"; int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF; bitSet.set(hashcode1); int hashcode2 = (url + "-seed-").hashCode() &amp; 0x7FFFFFFF; bitSet.set(hashcode2); System.out.println(bitSet.get(hashcode1) &amp;&amp; bitSet.get(hashcode2)); //也可以在两个不同的bitSet上进行2次“着色”，这样冲突性更小。但会消耗双倍的内存 其实我们能够看出，这种方式降低了误判的概率。但是如果BitSet中存储了较多的数字，那么互相覆盖着色，最终数据冲突的可能性会逐渐增加，最终仍然有一定概率的判断失误。所以在hashcode算法的个数与实际String的个数之间有一个权衡，我们建议: “hashcode算法个数 String字符串的个数” &lt; Integer.MAX_VALUE 0.8 多个BitSet并行保存：改良1)中的实现方式，我们仍然使用多个hashcode生成算法，但是每个算法生成的值在不同的BitSet中着色，这样可以保持每个BitSet的稀疏度(降低冲突的几率)。在实际结果上，比1)的误判率更低，但是它需要额外的占用更多的内存，毕竟每个BitSet都需要占用内存。这种方式，通常是缩小hashcode的值域，避免内存过度消耗。 1234567891011BitSet bitSet1 = new BitSet(Integer.MAX_VALUE);//127M BitSet bitSet2 = new BitSet(Integer.MAX_VALUE); String url = "http://baidu.com/a"; int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF; bitSet1.set(hashcode1); int hashcode2 = (url + "-seed-").hashCode() &amp; 0x7FFFFFFF; bitSet2.set(hashcode2); System.out.println(bitSet1.get(hashcode1) &amp;&amp; bitSet2.get(hashcode2)); 是否有必要完全避免误判？如果做到100%的正确判断率，在原理上说BitSet是无法做的，BitSet能够保证“如果判定结果为false，那么数据一定是不存在；但是如果结果为true，可能数据存在，也可能不存在(冲突覆盖)”,即“false == YES，true == Maybe”。有人提出将冲突的数据保存在类似于BTree的额外数据结构中，事实上这种方式增加了设计的复杂度，而且最终仍然没有良好的解决内存占用较大的问题。 BloomFilter(布隆姆过滤器)BloomFilter 的设计思想和BitSet有较大的相似性，目的也一致，它的核心思想也是使用多个Hash算法在一个“位图”结构上着色，最终提高“存在性”判断的效率。请参见Guava BloomFilter。如下为代码样例： 12345Charset charset = Charset.forName("utf-8"); BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(charset),2&lt;&lt;21);//指定bloomFilter的容量 String url = "www.baidu.com/a"; bloomFilter.put(url); System.out.println(bloomFilter.mightContain(url)); 内存消耗据上所述，BitSet可以有效的降低内存的使用量，但是它的内存使用量是有内部long数组的大小决定，所以在创建BitSet时指定的值域非常重要，过大的值域将会导致OOM（比如指定Long.MAX_VALUE）,在一个BitMap上存储Integer.MAX_VALUE个“着色”（注意，BitSet只能对正数操作），大概消耗128M内存。 转自：https://shift-alt-ctrl.iteye.com/blog/2194519]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>BitSet</tag>
        <tag>大数据量</tag>
        <tag>hashcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Trie前缀树]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Java非递归版 ​1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Trie &#123; private class Node&#123; boolean isTrie; Map&lt;Character, Node&gt; children = new HashMap&lt;&gt;(); &#125; private Node root = new Node(); /** Initialize your data structure here. */ public Trie() &#123; &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; Node node = root; for(int i=0; i&lt;word.length(); i++)&#123; char c = word.charAt(i); if(!node.children.containsKey(c))&#123; node.children.put(c, new Node()); &#125; node = node.children.get(c); &#125; node.isTrie = true; return; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; Node node = root; for(int i=0; i&lt;word.length(); i++)&#123; char c = word.charAt(i); Node temp = node.children.get(c); if(temp == null) return false; node = temp; &#125; return node.isTrie; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; Node node = root; for(int i=0; i&lt;prefix.length(); i++)&#123; char c = prefix.charAt(i); Node temp = node.children.get(c); if(temp == null) return false; node = temp; &#125; return node!=null; &#125;&#125; ​ 关于Trie 核心思想：空间换取时间 Trie 树又叫又叫字典树、前缀树、单词查找树，它是一颗多叉查找树。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。 如果 海量数据 是字符串数据，那么就可以用很小的空间开销构建一颗 Trie 树，空间开销和树高有关。 {“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 基本性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 优点 插入和查询效率很高，都是O(m)，m是待插入/查询字符串长度；（关于查询，会有人认为hash表时间复杂度O(1)不是更快？确实，但是哈希搜索的效率通常取决于hash函数的好坏，因为这决定着冲突的概率）。 Trie树中不同关键字不会冲突； 可以对关键字按字典排序。 缺点 当hash函数很好时，Trie树的查找效率会低于哈希查找； 空间消耗比较大。 主要应用：字符串检索、词频统计、字符串排序、前缀匹配等]]></content>
      <categories>
        <category>编程</category>
        <category>leetcode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新排序得到2的幂]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[😍题目描述从正整数 N 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回false。 😘解题思路 先将数值N中的每个数字独立存储并排序为list，长度记作n；在2的幂中找出长度为n的所有数值，并同样对每个数字存储排序,得到list2，判断list与list2是否逐位相等 对于2的幂的正整数，有个规律：位数每隔3都有对应的整数个数4、3、3， 位数 个数 整数 幂指数 1 4 1，2，4，8 0，1，2，3 2 3 16，32，64 4，5，6 3 3 128，256，512 7，8，9 4 4 1024，2048，4096，8192 10，11，12，13 5 3 16384，32768，65536 14，15，16 6 3 …. 17，18，19 7 4 … 20，21，22，23 8 3 … 24，25，26 9 3 … 27，28，29 … … … … 😱示例代码​1234567891011121314151617181920212223242526272829class Solution &#123; public boolean reorderedPowerOf2(int N) &#123; String num = N+""; int len = num.length(); int n;//位数为len的整数（2的幂)的个数 int m;//位数为len的整数的幂指数 if(len%3 == 0)&#123; m = (len/3)*10-3; n = 3; &#125;else if(len%3 == 1)&#123; m = (len/3)*10; n = 4; &#125;else&#123; m = (len/3)*10+4; n = 3; &#125; String[] pows = new String[n]; for(int i=0; i&lt;n; i++)&#123; pows[i] = (int)Math.pow(2, m+i) + ""; char[] powlist = pows[i].toCharArray(); Arrays.sort(powlist); char[] numlist = num.toCharArray(); Arrays.sort(numlist); if(Arrays.equals(powlist, numlist)) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>leetcode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程通信]]></title>
    <url>%2F2019%2F03%2F01%2F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[对进程通信的理解进程是资源分配的基本单位，所以说某块资源分配给一个进程后，该资源只能是该进程独占，所以进程之间的通信就会比较麻烦，因为需要让不同的进程间能够看到一份公共的资源。所以交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。 实现进程通信的方式匿名管道（pipe） 管道是通过调用 pipe 函数创建的，是在内核中开辟出的一块缓冲区，fd[0] 用于读，fd[1] 用于写。 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 父进程关闭读端（fd[0]）,子进程关闭写端(fd[1])，则此时父进程可以往管道中进行写操作，子进程可以从管道中读，从而实现了通过管道的进程间通信 示例代码​123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;int main()&#123; int fd[2]; int ret = pipe(fd); //开启匿名管道 if(ret&lt;0) perror("pipe\n"); //开启失败 pid_t id = fork(); //创建子进程 if(id&lt;0) perror("fork\n"); //创建失败 else if(id==0)&#123; //子进程 close(fd[0]); //子进程关闭读端 int i=0; char *mesg = NULL; while(i&lt;100)&#123; mesg = "child"; write(fd[1], mesg, strlen(mesg)+1); //向管道另一端写数据 sleep(1); i++; &#125; &#125; else&#123; //父进程 close(fd[1]); //父进程关闭写端 int i=0; char mesg[100]; while(i&lt;100)&#123; memset(mesg, '\0', sizeof(mesg)); read(fd[0], mesg, sizeof(mesg)); //从管道另一端读数据 printf("%s\n", mesg); j++; &#125; &#125; return 0;&#125; ​ 命名管道（FIFO） 命名管道，去除了管道只能在父子进程中使用的限制。 命名管道创建后就可以使用了，使用方法和匿名管道基本相同。只是使用命名管道时，必须先调用open()将其打开，因为命名管道是一个存在于硬盘的文件，而匿名管道是存在于内存中的特殊文件 调用open()打开命名管道的进程可能会被阻塞。但如果同时用读写方式（ O_RDWR）打开，则一定不会导致阻塞；如果以只读方式（ O_RDONLY）打开，则调用open()函数的进程将会被阻塞直到有写方打开管道；同样以写方式（ O_WRONLY）打开也会阻塞直到有读方式打开管道。 示例代码 😜Client.c文件，向管道写数据 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#define _PATH_NAME_ "/tmp/file.tmp"#define _SIZE_ 100 int main()&#123; int ret=mkfifo(_PATH_NAME_,S_IFIFO|0666); //第一个参数是命名管道存储路径，第二个是命名管道的存取权限 if(ret==-1)&#123; printf("make fifo error\n"); return 1; &#125; char buf[_SIZE_]; memset(buf,'\0',sizeof(buf)); int fd=open(_PATH_NAME_,O_WRONLY); //打开命名管道，因为其是硬盘上的文件 while(1) &#123; //scanf("%s",buf); fgets(buf,sizeof(buf)-1,stdin); int ret=write(fd,buf,strlen(buf)+1); if(ret&lt;0)&#123; printf("write error"); break; &#125; &#125; close(fd); return 0;&#125; 😜Server.c文件，从管道读数据并输出 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#define _PATH_NAME "/tmp/file.tmp"#define _SIZE_ 100int main()&#123; int fd=open(_PATH_NAME,O_RDONLY); if(fd&lt;0)&#123; printf("open file error"); return 1; &#125; char buf[_SIZE_]; memset(buf,'\0',sizeof(buf)); while(1)&#123; int ret=read(fd,buf,sizeof(buf)); if(ret&lt;0)&#123; printf("read end or error\n"); break; &#125; printf("%s",buf); &#125; close(fd); return 0;&#125; 消息队列 消息队列可以独立于读写进程存在，从而避免了FIFO中为了同步管道的打开和关闭可能产生的困难； 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收. 1 int msgget(key_t key, int msgflg); ssize_t msgrcv(int msqid, void msgp, size_t msgsz, long msgtyp, int msgflg); int msgsnd(int msqid, const void msgp, size_t msgsz, int msgflg); int msgctl ( int msgqid, int cmd, struct msqid_ds *buf ); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364​ * 创建消息队列用系统调用`msgget()`来实现，这一步工作也被称为消息队列的初始化。 * 在进行通信时，消息队列的发送和接收分别用系统调用`msgsnd()`和`msgrcv()`来实现.。 * 在需要改变队列的使用权限及其它一些特性时，用`msgclt()`来实现。 ###### 示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10287879）](https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89)* 😘msgreceive.c ```c #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;sys/msg.h&gt; struct msg_st &#123; long int msg_type; char text[BUFSIZ]; &#125;; int main() &#123; int running = 1; int msgid = -1; struct msg_st data; long int msgtype = 0; //注意1 //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if(msgid == -1) &#123; fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno); exit(EXIT_FAILURE); &#125; //从队列中获取消息，直到遇到end消息为止 while(running) &#123; if(msgrcv(msgid, (void*)&amp;data, BUFSIZ, msgtype, 0) == -1) &#123; fprintf(stderr, &quot;msgrcv failed with errno: %d\n&quot;, errno); exit(EXIT_FAILURE); &#125; printf(&quot;You wrote: %s\n&quot;,data.text); //遇到end结束 if(strncmp(data.text, &quot;end&quot;, 3) == 0) running = 0; &#125; //删除消息队列 if(msgctl(msgid, IPC_RMID, 0) == -1) &#123; fprintf(stderr, &quot;msgctl(IPC_RMID) failed\n&quot;); exit(EXIT_FAILURE); &#125; exit(EXIT_SUCCESS); &#125; 😘msgsend.c文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/msg.h&gt;#include &lt;errno.h&gt; #define MAX_TEXT 512struct msg_st&#123; long int msg_type; char text[MAX_TEXT];&#125;; int main()&#123; int running = 1; struct msg_st data; char buffer[BUFSIZ]; int msgid = -1; //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if(msgid == -1) &#123; fprintf(stderr, "msgget failed with error: %d\n", errno); exit(EXIT_FAILURE); &#125; //向消息队列中写消息，直到写入end while(running) &#123; //输入数据 printf("Enter some text: "); fgets(buffer, BUFSIZ, stdin); data.msg_type = 1; //注意2 strcpy(data.text, buffer); //向队列发送数据 if(msgsnd(msgid, (void*)&amp;data, MAX_TEXT, 0) == -1) &#123; fprintf(stderr, "msgsnd failed\n"); exit(EXIT_FAILURE); &#125; //输入end结束输入 if(strncmp(buffer, "end", 3) == 0) running = 0; sleep(1); &#125; exit(EXIT_SUCCESS);&#125; 信号量 它是一个计数器，用于为多个进程提供对共享数据对象的访问 semget()用于创建一个新信号量或返回一个已有信号量（根据IPCkey） semop()用于改变信号量的值，用于对信号量增减操作，即PV操作 semclt()用于直接控制信号量的值，用于对信号量初始化操作 123int semget(key_t key, int num_sems, int sem_flags);int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);int semctl(int sem_id, int sem_num, int command, ...); 示例代码（来自 https://blog.csdn.net/ljianhui/article/details/10243617）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/sem.h&gt; union semun&#123; int val; struct semid_ds *buf; unsigned short *arry;&#125;; static int sem_id = 0; static int set_semvalue();static void del_semvalue();static int semaphore_p();static int semaphore_v(); int main(int argc, char *argv[])&#123; char message = 'X'; int i = 0; //创建信号量 sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT); if(argc &gt; 1) &#123; //程序第一次被调用，初始化信号量 if(!set_semvalue()) &#123; fprintf(stderr, "Failed to initialize semaphore\n"); exit(EXIT_FAILURE); &#125; //设置要输出到屏幕中的信息，即其参数的第一个字符 message = argv[1][0]; sleep(2); &#125; for(i = 0; i &lt; 10; ++i) &#123; //进入临界区 if(!semaphore_p()) exit(EXIT_FAILURE); //向屏幕中输出数据 printf("%c", message); //清理缓冲区，然后休眠随机时间 fflush(stdout); sleep(rand() % 3); //离开临界区前再一次向屏幕输出数据 printf("%c", message); fflush(stdout); //离开临界区，休眠随机时间后继续循环 if(!semaphore_v()) exit(EXIT_FAILURE); sleep(rand() % 2); &#125; sleep(10); printf("\n%d - finished\n", getpid()); if(argc &gt; 1) &#123; //如果程序是第一次被调用，则在退出前删除信号量 sleep(3); del_semvalue(); &#125; exit(EXIT_SUCCESS);&#125; static int set_semvalue()&#123; //用于初始化信号量，在使用信号量前必须这样做 union semun sem_union; sem_union.val = 1; if(semctl(sem_id, 0, SETVAL, sem_union) == -1) return 0; return 1;&#125; static void del_semvalue()&#123; //删除信号量 union semun sem_union; if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1) fprintf(stderr, "Failed to delete semaphore\n");&#125; static int semaphore_p()&#123; //对信号量做减1操作，即等待P（sv） struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1;//P() sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; fprintf(stderr, "semaphore_p failed\n"); return 0; &#125; return 1;&#125; static int semaphore_v()&#123; //这是一个释放操作，它使信号量变为可用，即发送信号V（sv） struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1;//V() sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; fprintf(stderr, "semaphore_v failed\n"); return 0; &#125; return 1;&#125; 共享内存 允许多个进程共享一个给定的存储区 因为数据不需要进程之间的复制，而是直接访问内存，所以这是最快的一种IPC。 由于共享内存并不提供同步操作，所以在使用共享内存这种通信方式时，需要借助其他手段进行进程间的同步工作，可以使用信号量等 shmget()用来创建共享内存，返回一个与key相关的共享内存标识符 shmat()用来启动对共享内存的访问，并把共享内存连接到当前进程的地址空间（第一次创建完共享内存时，还不能被任何进程访问），返回指向共享内存的指针 shmclt()用来控制共享内存，与信号量的semclt()函数一样 shmdt()用于将共享内存从当前进程中分离，注意分离不等于删除共享内存 1234int shmget(key_t key, size_t size, int shmflg);void *shmat(int shm_id, const void *shm_addr, int shmflg);int shmctl(int shm_id, int command, struct shmid_ds *buf);int shmdt(const void *shmaddr); 示例代码（来自 https://blog.csdn.net/ljianhui/article/details/10253345） 😀shmdata.h文件，定义共享内存结构 12345678910//shmdata.h文件，定义共享内存结构#ifndef _SHMDATA_H_HEADER#define _SHMDATA_H_HEADER #define TEXT_SZ 2048struct shared_use_st&#123; int written;//作为一个标志，非0：表示可读，0表示可写 char text[TEXT_SZ];//记录写入和读取的文本&#125;;#endif 😀shmread.c文件，创建共享内存，并读取其中信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include "shmdata.h" int main()&#123; int running = 1;//程序是否继续运行的标志 void *shm = NULL;//分配的共享内存的原始首地址 struct shared_use_st *shared;//指向shm int shmid;//共享内存标识符 //创建共享内存 shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT); if(shmid == -1) &#123; fprintf(stderr, "shmget failed\n"); exit(EXIT_FAILURE); &#125; //将共享内存连接到当前进程的地址空间 shm = shmat(shmid, 0, 0); if(shm == (void*)-1) &#123; fprintf(stderr, "shmat failed\n"); exit(EXIT_FAILURE); &#125; printf("\nMemory attached at %X\n", (int)shm); //设置共享内存 shared = (struct shared_use_st*)shm; shared-&gt;written = 0; while(running)//读取共享内存中的数据 &#123; //没有进程向共享内存定数据有数据可读取 if(shared-&gt;written != 0) &#123; printf("You wrote: %s", shared-&gt;text); sleep(rand() % 3); //读取完数据，设置written使共享内存段可写 shared-&gt;written = 0; //输入了end，退出循环（程序） if(strncmp(shared-&gt;text, "end", 3) == 0) running = 0; &#125; else//有其他进程在写数据，不能读取数据 sleep(1); &#125; //把共享内存从当前进程中分离 if(shmdt(shm) == -1) &#123; fprintf(stderr, "shmdt failed\n"); exit(EXIT_FAILURE); &#125; //删除共享内存 if(shmctl(shmid, IPC_RMID, 0) == -1) &#123; fprintf(stderr, "shmctl(IPC_RMID) failed\n"); exit(EXIT_FAILURE); &#125; exit(EXIT_SUCCESS);&#125; 😀shmwrite.c文件，向共享内存写入数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include "shmdata.h" int main()&#123; int running = 1; void *shm = NULL; struct shared_use_st *shared = NULL; char buffer[BUFSIZ + 1];//用于保存输入的文本 int shmid; //创建共享内存 shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT); if(shmid == -1) &#123; fprintf(stderr, "shmget failed\n"); exit(EXIT_FAILURE); &#125; //将共享内存连接到当前进程的地址空间 shm = shmat(shmid, (void*)0, 0); if(shm == (void*)-1) &#123; fprintf(stderr, "shmat failed\n"); exit(EXIT_FAILURE); &#125; printf("Memory attached at %X\n", (int)shm); //设置共享内存 shared = (struct shared_use_st*)shm; while(running)//向共享内存中写数据 &#123; //数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本 while(shared-&gt;written == 1) &#123; sleep(1); printf("Waiting...\n"); &#125; //向共享内存中写入数据 printf("Enter some text: "); fgets(buffer, BUFSIZ, stdin); strncpy(shared-&gt;text, buffer, TEXT_SZ); //写完数据，设置written使共享内存段可读 shared-&gt;written = 1; //输入了end，退出循环（程序） if(strncmp(buffer, "end", 3) == 0) running = 0; &#125; //把共享内存从当前进程中分离 if(shmdt(shm) == -1) &#123; fprintf(stderr, "shmdt failed\n"); exit(EXIT_FAILURE); &#125; sleep(2); exit(EXIT_SUCCESS);&#125; 套接字 与其它通信机制不同的是，它可用于不同机器间的进程通信 因特网提供了两种通信机制：流（stream）和数据报（datagram），因而套接字的类型也就分为流套接字和数据报套接字。 套接字域： * `AF_INET`，它指的是Internet网络，结构中有IP地址和端口 * `AF_UNIX`，表示UNIX文件系统，它就是文件输入/输出，结构中有文件路径名 socket()用于创建一个套接字，三个参数分别为套接字域、通信机制、协议类型 bind()函数把通过socket调用创建的套接字命名，从而让它可以被其他进程使用。 * 对于AF_UNIX，调用该函数后套接字就会关联到一个文件系统路径名； * 对于AF_INET，则会关联到一个IP端口号 listen()用来创建一个队列来保存未处理的请求 accept()用来等待客户建立对该套接字的连接，阻塞直到有客户建立连接 connect()用来让客户程序通过在一个未命名套接字和服务器监听套接字之间建立连接的方法来连接到服务器 close()用来终止服务器和客户上的套接字连接，我们应该总是在连接的两端（服务器和客户）关闭套接字 12345int socket(int domain, int type, int protocol);int bind( int socket, const struct sockaddr *address, size_t address_len);int listen(int socket, int backlog);int accept(int socket, struct sockaddr *address, size_t *address_len);int connect(int socket, const struct sockaddr *address, size_t address_len); 示例代码（来自 https://blog.csdn.net/ljianhui/article/details/10477427） 😡sockserver.c文件，服务器端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; int server_sockfd = -1; int client_sockfd = -1; int client_len = 0; struct sockaddr_in server_addr; struct sockaddr_in client_addr; //创建流套接字 server_sockfd = socket(AF_INET, SOCK_STREAM, 0); //设置服务器接收的连接地址和监听的端口 server_addr.sin_family = AF_INET;//指定网络套接字 server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//接受所有IP地址的连接 server_addr.sin_port = htons(9736);//绑定到9736端口 //绑定（命名）套接字 bind(server_sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)); //创建套接字队列，监听套接字 listen(server_sockfd, 5); //忽略子进程停止或退出信号 signal(SIGCHLD, SIG_IGN); while(1) &#123; char ch = '\0'; client_len = sizeof(client_addr); printf("Server waiting\n"); //接受连接，创建新的套接字 client_sockfd = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len); if(fork() == 0) &#123; //子进程中，读取客户端发过来的信息，处理信息，再发送给客户端 read(client_sockfd, &amp;ch, 1); sleep(5); ch++; write(client_sockfd, &amp;ch, 1); close(client_sockfd); exit(0); &#125; else &#123; //父进程中，关闭套接字 close(client_sockfd); &#125; &#125;&#125; 😡sockclient.c文件，客户端 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; int sockfd = -1; int len = 0; struct sockaddr_in address; int result; char ch = 'A'; //创建流套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); //设置要连接的服务器的信息 address.sin_family = AF_INET;//使用网络套接字 address.sin_addr.s_addr = inet_addr("127.0.0.1");//服务器地址 address.sin_port = htons(9736);//服务器所监听的端口 len = sizeof(address); //连接到服务器 result = connect(sockfd, (struct sockaddr*)&amp;address, len); if(result == -1) &#123; perror("ops:client\n"); exit(1); &#125; //发送请求给服务器 write(sockfd, &amp;ch, 1); //从服务器获取数据 read(sockfd, &amp;ch, 1); printf("char form server = %c\n", ch); close(sockfd); exit(0);&#125; 关于System V IPCSystem V IPC指的是AT&amp;T在System V.2发行版中引入的三种进程间通信工具： 信号量，用来管理对共享资源的访问 共享内存，用来高效地实现进程间的数据共享 共享内存，用来高效地实现进程间的数据共享 消息队列，用来实现进程间数据的传递。 我们把这三种工具统称为System V IPC的对象，每个对象都具有一个唯一的IPC标识符(identifier)。要保证不同的进程能够获取同一个IPC对象，必须提供一个IPC关键字(IPCkey)，内核负责把IPC关键字转换成IPC标识符。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程同步经典问题]]></title>
    <url>%2F2019%2F03%2F01%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[生产者-消费者问题问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full记录满缓冲区的数量。其中， ​ empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品； ​ full信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty =0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 ​123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer()&#123; while(TRUE)&#123; int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); &#125;&#125;void consumer()&#123; while(TRUE)&#123; down(&amp;full); down(&amp;mutex); int item = remove_item(); consume_item(item); up(&amp;mutex); up(&amp;empty); &#125;&#125; 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex用于对读写的数据加锁。 读者优先：当读者进行读取时，如果后面一直有读者进入，那么写者就会阻塞，直到所有读者完成之后，写者才可以进入。 12345678910111213141516171819202122232425262728typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void writer()&#123; while(TRUE)&#123; down(&amp;data_mutex); write(); up(&amp;data_mutex); &#125;&#125;void reader()&#123; while(TRUE)&#123; down(&amp;count_mutex); if(count==0) down(&amp;data_mutex);//如果是第一个读者，阻塞写者 count++; up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count==0) up(&amp;data_mutex);//最后一个读者出来，释放写者 up(&amp;count_mutex); &#125;&#125; 写者优先：置一个WriterMutex信号量来实现优先读。我们可以看到，当有写者进入时，通过P(WriterMutex)阻塞了读者 123456789101112131415161718192021222324252627282930313233typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;semaphore write_mutex = 1;//实现写者优先int count = 0;void writer()&#123; while(TRUE)&#123; down(&amp;write_mutex); down(&amp;data_mutex); write(); up(&amp;data_mutex); up(&amp;write_mutex); &#125;&#125;void reader()&#123; while(TRUE)&#123; down(&amp;write_mutex);//无写者进入时 down(&amp;count_mutex); if(count==0) down(&amp;data_mutex);//如果是第一个读者，阻塞写者 count++; up(&amp;write_mutex);//恢复对共享资源的访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count==0) up(&amp;data_mutex);//最后一个读者出来，释放写者 up(&amp;count_mutex); &#125;&#125; 哲学家进餐问题五个哲学家（A~E）围着一张圆桌就餐，他们每个人面前都有一盘通心粉。由于通心粉很滑，所以需要两只筷子才能夹住，但每两个盘子之间只放着一只筷子，如下图。哲学家只有两个动作：要么就餐，要么思考。而且他们之间从不交谈。当一个哲学家饿了的时候，就拿起盘子左右两边的筷子开始就餐（不能同时拿起两只筷子）。就餐完以后，就把筷子放回盘子左右，继续思考。由于他们之间互不交谈，所以很容易出现“死锁”：假如每个人都拿着左边的筷子，则所有人都在等右边的筷子，谁都吃不了。为了防止死锁的发生，可以设置两个条件： 必须同时拿起左右两根筷子；只有在两个邻居都没有进餐的情况下才允许进餐。 ​123456789101112131415161718192021222324252627282930313233343536373839404142#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态semaphore mutex = 1; // 临界区的互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) &#123; while(TRUE) &#123; think(); take_two(i); eat(); put_two(i); &#125;&#125;void take_two(int i) &#123; down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]);&#125;void put_two(i) &#123; down(&amp;mutex); state[i] = THINKING; test(LEFT); test(RIGHT); up(&amp;mutex);&#125;void test(i) &#123; // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123; state[i] = EATING; up(&amp;s[i]); &#125;&#125; 其他解决方案（ https://blog.csdn.net/Sunflowerfiona/article/details/52756819）]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>同步</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Spring的理解]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述Spring是一个开源框架，为简化企业级应用开发而生。Spring可以是使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和AOP容器框架。 主要核心 控制反转（IOC），传统的Java开发模式中，当需要一个对象时，我们会自己使用new或者getInstance等直接或者间接调用构造方法创建一个对象，而在Spring开发模式中，spring容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring提供的对象就可以了，这是控制反转的思想。控制反转主要的实现方式有两种：依赖查找、依赖注入。 依赖注入（DI），spring使用JavaBean对象的set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。 面向切面编程（AOP），在面向对象编程(oop)思想中，我们将事物纵向抽成一个个对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事务管理、记录日志等公用操作处理的过程就是面向切面编程的思想。AOP底层是动态代理，如果是接口采用JDK动态代理，如果是类采用CGLIB方式实现动态代理。 结构spring由20多个模块组成，可以分为数据访问/集成、Web、面向切面编程、应用服务器设备管理、消息发送、核心容器和测试 Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换和常用的工具类； Beans模块：提供框架的基础部分，包括控制反转和依赖注入。其中BeanFactory是容器核心。 Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化等；核心接口是ApplicationContext。]]></content>
      <categories>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统---概述]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[基本特征 并发一段时间内运行多个程序为并发；同一时刻运行多条指令为并行；并行需要硬件支持，比如多核处理器、分布式系统操作系统引入进程和线程，使得程序能够并发运行 共享指系统资源可以被多个并发进程使用两种共享方式：互斥共享、同时共享 虚拟两种虚拟技术：时分复用技术：多个进程在同一个处理器上并发执行空分复用技术：虚拟内存 异步指一个进程不是一次执行完毕，而是走走停停 基本功能 进程管理进程控制、进程同步、进程调度、死锁处理、处理机调度等 内存管理内存分配、地址映射、内存保护与共享、虚拟内存等 文件管理文件存储空间管理、目录管理、文件读写管理与保护等 设备管理帮助用户完成IO请求，包括缓冲管理、设备分配、设备处理、虚拟设备等 系统调用如果一个进程在用户态需要使用内核态的功能，需要通过系统调用陷入内核态，有操作系统代为完成。 中断 外中断，如IO完成请求、时钟中断、控制台中断等 异常，由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等 陷入，进程使用系统调用由用户态陷入内核态 参考： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/计算机操作系统.md#一概述]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符操作]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[编码与解码编码就是把字符转换为字节，而解码是把字节重新组合成字符。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。 Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。 String 的编码方式String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。 ​ String str1 = “中文”; byte[] bytes = str1.getBytes(“UTF-8”); String str2 = new String(bytes, “UTF-8”); System.out.println(str2); 在调用无参数getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为UTF-8。 Reader 与 Writer不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从字节流解码成字符流；OutputStreamWriter 实现字符流编码成为字节流。 实现逐行输出文本文件的内容 ​123456789101112131415public static void readFileContent(String filePath) throws IOException &#123; FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close();&#125; 参考： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java IO.md]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>字符</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象 组成部分 抽象构件(Component)它是具体构件和抽象装饰类的共同祖先，声明了具体构件需要实现的业务方法 具体构件(ConcreteComponent)它是抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的业务方法 抽象装饰类(Decorator)它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 具体装饰类(ConcreteDecorator)它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为 代码实现假设有两个程序员他们原来只会各自的技能，现在需要让Android程序猿具备设计模式技能，那就给他装饰一下。说明一下： 抽象构件：掌握技能的程序员 具体构件：一个掌握写Android代码技能的程序员，一个掌握写php代码技能的程序员 抽象装饰类： 具体装饰类： 在业务方法中添加设计模式的技能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Component（抽象构件）interface ProgramMonkey &#123; void skills();&#125;//ConcreteComponent（具体构件）class AndroidProgramMonkey implements ProgramMonkey &#123; @Override public void skills() &#123; System.out.println("会写Android代码！"); &#125;&#125;//ConcreteComponent（具体构件）class PHPProgramMonkey implements ProgramMonkey &#123; @Override public void skills() &#123; System.out.println("会写PHP代码！"); &#125;&#125;//Decorator（抽象装饰类）class ProgramMonkeyDecorator implements ProgramMonkey &#123; protected ProgramMonkey mProgramMonkey;//维护一个指向需要增加职责的构件的引用，用来调用该构件的方法 public ProgramMonkeyDecorator(ProgramMonkey mProgramMonkey) &#123; this.mProgramMonkey = mProgramMonkey; &#125; public void skills() &#123; mProgramMonkey.skills(); &#125;&#125;//ConcreteDecorator（具体装饰类）class PatternDecorator extends ProgramMonkeyDecorator &#123; public PatternDecorator(ProgramMonkey mProgramMonkey) &#123; super(mProgramMonkey); &#125; @Override public void skills() &#123; super.skills(); System.out.println("会设计模式！");//增加的职责 &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; //有一个Android程序猿只会写Android代码 ProgramMonkey programMonkey = new AndroidProgramMonkey(); programMonkey.skills(); //装饰一下他，装逼的技能，他竟然除了写Android还懂设计模式 programMonkey = new PatternDecorator(programMonkey); programMonkey.skills(); programMonkey = new PHPProgramMonkey(); programMonkey.skills(); &#125;&#125; Java I/O中的装饰模式 InputStream是抽象构件 FileInputStream是InputStream的子类，属于其中一个具体构件，提供字节流输入的操作；PipedInputStream、ByteArrayInputStream也是具体构件 FilterInputStream是InputStream的子类，属于抽象装饰类，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 DataInputStream、BufferedInputStream、PushBackInputStream都是具体装饰者]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F02%2F28%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本数据类型，byte/8、short/16、char/16、int/32、float/32、long/62、double/16、boolean（只有两个值，可以用1bit来表示，但是具体大小没有明确规定，JVM在编译时期将boolean类型的数据转成int类型） 包装数据类型，基本数据类型都有对应的包装数据类型，两者之间的转换过程为装箱拆箱，装箱：基本数据类型–&gt;包装数据类型； 缓存池：new Integer(123)每次都会新建一个对象，而使用Integer.valueOf(123)创建实例时，会先判断该值是否在缓存池中，如果在直接返回缓存池中的内容，因此多次调用会取得同一个对象的引用；在自动装箱过程中，编译器会自动调用valueOf()，因此多个 Integer实例使用自动装箱来创建并且值相同，那么就会引用相同的对象；每个基本数据类型都有对应的缓存池，使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象，但是有大小限制； String Pool(字符串常量池)：在String Pool中添加字符串有两种方法，一种是字符串字面量”abc”在编译时期就确定，另一种是通过调用intern()在程序运行时将字符串对象添加到String Pool并返回该字符串的引用。在 Java 7 之前，String Pool被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError错误 switch：从Java7开始，可以在switch条件判断语句中使用String对象；switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适 抽象类与接口：抽象类可以有构造方法而接口不行；接口的成员（字段和方法）默认都是public而抽象类可以是任意访问权限；接口的字段默认都是static和final修饰的而抽象类可以有普通成员变量 重写的两个限制：子类方法访问权限必须大于等于父类的；子类方法返回值类型必须是父类的返回值类型或子类型 重载：返回值类型、方法名相同；参数类型、个数、顺序不同 equal(Object o)的实现： 判断是否为同一对象的引用，如果是直接返回true； 判断是否为同一类型（getClass())，如果不是直接返回false； 将参数Object对象进行转型； 判断每个关键域是否相等。 hashCode()：hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。 等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等； clone()： Object的一个protected方法，如果一个类不显式重写该方法，那该类就不能调用clone()方法；而且该类要实现Cloneable()标记接口，要不然调用时会抛出CloneNotSupportedException。 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 深拷贝与浅拷贝：区别在于浅拷贝拷贝时碰到对象只是复制了对象的引用。 异常： Java与C++： 参考： CS-Note/Java基础]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发互斥同步]]></title>
    <url>%2F2019%2F02%2F28%2F%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[Java提供两种锁机制控制多线程对互斥资源的互斥访问，一种是JVM实现的synchronized，一种是JDK实现的RentranLock. synchronized 同步一个代码块；只作用于一个对象，如果调用两个不同的对象上的同步代码块，不会进行同步； 123456789public class SynchronizedExample &#123; public void func1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125; 同步一个方法；和同步代码块一样，只作用于相同对象； 1 同步一个类；作用于整个类，即两个线程调用同一类的不同对象上的同步语句，也会进行同步； 123456public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 同步一个静态方法；作用于整个类 123public synchronized static void fun() &#123; // ...&#125; RentranLockRentranLock是java.util.concurrent(J.U.C)包中的锁； Java并发之ReentrantLock详解 两者的异同 锁的实现；synchronized是JVM实现，RentranLock是JDK实现 性能：由于新版本Java对synchronized进行了很多 优化 ，例如自旋锁等，两者性能大致相同 等待可中断；当一个线程长期不释放锁时，其他在等待的线程可以放弃等待去处理其他事情；RentranLock可中断，而synchronized`不行 公平锁；即当多个线程在等待同一锁时，必须按照申请锁的时间顺序获得锁；synchronized中的锁是非公平的；RentranLock默认的锁也是不公平的，但是也可以是公平的 绑定条件；一个RentranLock可以绑定多个Condition对象。 在一个锁中使用多个条件（Condition)]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>同步，锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象思想]]></title>
    <url>%2F2019%2F02%2F27%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[三大特性 封装 继承 多态编译时多态：主要指方法的重载运行时多态：三个条件（继承，重写，向上转型） 类图 泛化关系：描述继承关系，extend 实现关系：实现一个接口，implement 聚合关系：整体和部分不是强依赖，整体不存在，部分可以存在 组合关系：整体和部分强依赖，整体消失，部分跟着消失 关联关系：表示不同类对象之间的关联，这是一种静态关系，与运行过程无关，如1对1，1对多… 依赖关系：在运行过程中起作用，有三种形式：A 类是 B 类方法的局部变量；A 类是 B 类方法当中的一个参数；A 类向 B 类发送消息，从而影响 B 类发生变化 设计原则（S.O.L.I.D) S：单一责任原则 修改一个类的原因只有一个 让一个类只负责一件事，当这个类需要做过多的事情，应该分解这个类；如果一个类承担职责过多，就等于把这些职责耦合在一起，一个职责的变化可能削弱该类完成其他职责的能力。 O：开放封闭原则 类对扩展开放，对修改关闭 添加新功能时不修改代码；装饰者模式，动态地将责任附加到对象上而不用修改代码。 L：里氏替换原则 子类必须可以替换所有父类对象 I：接口分离原则 不应该强迫客户依赖于它们不用的方法。 因此使用多个专门的接口比使用单一的总接口要好 D：依赖倒置原则 高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节依赖于抽象 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。 依赖于抽象意味着： 任何变量都不应该持有一个指向具体类的指针或者引用； 任何类都不应该从具体类派生； 任何方法都不应该覆写它的任何基类中的已经实现的方法。 其他常见原则 迪米特法则迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。 合成复用原则尽量使用对象组合，而不是通过继承来达到复用的目的。 共同封闭原则一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。 稳定抽象原则最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。 稳定依赖原则包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。 参考： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/面向对象思想.md]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>类关系</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据量处理]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？方案1：可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。s 遍历文件a，对每个url求取 ，然后根据所取得的值将url分别存储到1000个小文件（记为 ）中。这样每个小文件的大约为300M。s 遍历文件b，采取和a相同的方式将url分别存储到1000各小文件（记为 ）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。s 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloomfilter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloomfilter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。方案1：s 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。s 找一台内存在2G左右的机器，依次对 用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为 ）。s 对 这10个文件进行归并排序（内排序与外排序相结合）。方案2：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。方案3：与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。方案1：顺序读文件中，对于每个词x，取 ，然后按照该值存到5000个小文件（记为 ）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。 海量日志数据，提取出某日访问百度次数最多的那个IP。方案1：首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有 个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存 内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。 海量数据分布在100台电脑中，想个办法高校统计出这批数据的TOP10。方案1：s 在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大。s 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。 怎么在海量数据中找出重复次数最多的一个？方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成。 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？方案1：这题用trie树比较合适，hash_map也应该能行。 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n _ le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n _ lg10)。所以总的时间复杂度，是O(n _ le)与O(n _ lg10)中较大的哪一个。 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。 100w个数中找出最大的100个数。方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w _ lg100)。方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w_ 100)。方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。(1) 请描述你解决这个问题的思路；(2) 请给出主要的处理流程，算法，以及算法的复杂度。方案1：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到 个数中的中数？方案1：先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有 个）。我们把0到 的整数划分为N个范围段，每个段包含个整数。比如，第一个段位0到 ，第二段为 到 ，…，第N个段为 到 。然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于 ，而在第k-1个机器上的累加数小于 ，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第 位。然后我们对第k个机器的数排序，并找出第个数，即为所求的中位数。复杂度是 的。方案2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第n个便是所求。复杂度是n(i)的。 最大间隙问题给定n个实数 ，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。方案1：最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：s 找到n个数据中最大和最小数据max和min。s 用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为 ，且桶的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为： 。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为），且认为将min放入第一个桶，将max放入第n-1个桶。s 将n个数放入n-1个桶中：将每个元素 分配到某个桶（编号为index），其中 ，并求出分到每个桶的最大最小数据。s 最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶i的上界和桶j的下界之间产生 。一遍扫描即可完成。 将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如： 。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出 。(1) 请描述你解决这个问题的思路；(2) 给出主要的处理流程，算法，以及算法的复杂度；(3) 请描述可能的改进。方案1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于 ，首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。 最大子序列与最大子矩阵问题数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。方案1：这个问题可以动态规划的思想解决。设 表示以第i个元素 结尾的最大子序列，那么显然 。基于这一点可以很快用代码实现。最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。方案1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。 转自： https://sunjia-704471770-qq-com.iteye.com/blog/1628359]]></content>
      <categories>
        <category>待办</category>
        <category>大数据量</category>
      </categories>
      <tags>
        <tag>海量数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays.asList()的坑]]></title>
    <url>%2F2018%2F12%2F18%2FArrays.asList()%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[避免使用基本数据类型数组转换为列表123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; asList接收的参数是一个泛型的变长参数，因为基本数据类型是无法泛型化的，也就是说8个基本类型无法作为asList的参数，要想作为泛型参数必须使用对应的包装类型 asList产生的列表不可操作对asList产生的列表不可操作，如add,remove等操作，否则会抛出UnsupportedOperationException异常（表示list不支持该操作） 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 注意： 这里asList返回的ArrayList其实不是java.util.ArrayList，而是Arrays的一个内部类，该内部类提供了size、toArray、get、set、indexOf、contains 方法，而像 add、remove 等改变 list 结果的方法从 AbstractList父类继承过来，而且AbstractList 父类的add,remove等方法会直接抛出UnsupportedOperationException异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return a.clone(); &#125; @Override @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125; &#125; 参考文章： http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java容器</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector与ArrayList]]></title>
    <url>%2F2018%2F12%2F18%2FVector%E4%B8%8EArrayList%2F</url>
    <content type="text"><![CDATA[Vector的实现 与ArrayList的实现类似，但是使用了synchronized进行同步。 ArrayList的实现 12345678910111213public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 与ArrayList的比较 Vector是同步的，因此开销就比ArrayList要大，访问速度更慢。最好使用ArrayList，因为同步操作完全可以由程序员自己控制。 Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。 替代方案 可以使用 Collections.synchronizedList()；得到一i个线程安全的ArrayList 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); 也可以使用concurrent并发包下的CopyOnWriteArrayList类 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java容器</tag>
        <tag>ArrayList</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2018%2F12%2F18%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList类的定义，父类及实现的接口：123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 继承AbstractList类，该类中实现了get，add，remove，clear，indexOf，lastIndexOf，和获取迭代器等方法，其中indexOf和lastIndexOf查找元素是用ListIterator实现的； 实现RandomAccess接口，该接口空的，即标记接口，那么它的作用是什么？ * Marker interface used by List implementations to indicate that * they support fast (generally constant time) random access. The primary * purpose of this interface is to allow generic algorithms to alter their * behavior to provide good performance when applied to either random or * sequential access lists. * 以上是jdk官方文档的解释，即RandomAccess是List实现锁使用的标记接口， * 用来表明其支持快速（通常是固定时间）随机访问。 * 此接口的主要目的是允许一般的算法更改其行为， * 从而在将其应用到随机或连续访问列表时能提供良好的性能 RandomAccess 这个标记接口就是标记能够随机访问元素的集合， 简单来说就是底层是数组实现的集合。更具体的可以看看这篇文章： https://juejin.im/post/5a26134af265da43085de060 实现了 Cloneable 接口，以指示 Object.clone() 方法可以合法地对该类实例进行按字段复制。 如果在没有实现 Cloneable接口的实例上调用 Object 的 clone 方法，则会导致抛出CloneNotSupportedException异常。 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。 扩容 数组的默认大小为10 1private static final int DEFAULT_CAPACITY = 10; 添加元素时使用ensureCapacityInternal()方法来保证容量足够，如果不够时，需要使用grow()方法进行扩容，新容量的大小为oldCapacity + (oldCapacity &gt;&gt; 1) ，也就是旧容量的1.5倍。 扩容操作需要调用 Array.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建ArrayList对象时就指定大概容量大小，减少扩容操作的次数。 12345678910111213141516171819202122232425262728293031public boolean add(E e)&#123; ensureCapacityInternal(size + 1); //increments modCount!! elementData[size++] = e; return true;&#125;public void ensureCapacityInternal(int minCapacity)&#123; if(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)&#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;public void ensureExplicitCapacity(int minCapacity)&#123; modCount++; //overflow-conscious code if(minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;public void grow(int minCapacity)&#123; //overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if(newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if(newCapacity - MAX_ARRAAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //minCapacity is usually close to size, so this is a win elementData = Arrays.copyOf(elementData, newCapacity);;&#125; 删除元素 需要调用System.arraycopy()将index+1后面的元素都复制到index位置上，该操作的时间复杂度为O(N)，可以看出ArrayList删除元素的代价是非常高的。 12345678910public E remove(int index)&#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index -1;; if(numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved) elementData[--size] = null; //clear to let GC do its work return oldValue;&#125; 部分序列化 ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组elementData使用transient修饰，该关键词声明数组默认不会被序列化。 1transient Object[] elementData; // non-private to simplify nested class access ArrayList实现了writeObject()和readObject()来控制只序列化数组中有元素填充那部分内容 12345678910111213141516171819202122232425262728293031323334353637383940private void writeObject(java.io.ObjectOutputStream s) throws java.io.Exception&#123; //write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); //write out size as capacity for behavioural compatibility with clone() s.writeInt(size); //write out all elements in the proper order for(int i=0; i&lt;size; i++)&#123; s.writeObject(elementData[i]) &#125; if(modCount != expectedModCount)&#123; throw new ConcurrentModificationException(); &#125;&#125;private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; * 序列化时需要要使用`ObjectOutputStream`的`writeObject()`将对象转换为字节流并输出。而`writeObject()`方法在传入的对象存在`writeObject()`存在`writeObject()`的时候会去反射调用该对象的`writeObject()`来实现序列化。 * 反序列化使用的是`ObjectInputStream`的`readObject()`方法，原理类似。比如下面的例子，oos的`writeObject(list)`方法，传入的对象list存在自己的`writeObject()`方法，则反射调用list对象的`writeObject()`方法来实现部分序列化（有内容的数组部分） 123ArrayList list = new ArrayList();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));oos.writeObject(list); Fail-Fast fail-fast，快速失败，是Java集合的一种错误检测机制。迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。 详细可见： https://blog.csdn.net/chenssy/article/details/38151189 modCount用来记录ArrayList结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组大小，仅仅只是设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较操作前后modCount是否改变，如果改变了需要抛出ConcurrentModificationException。 toArray()异常问题 ArrayList中提供了2个toArray()方法： 12Object[] toArray()&lt;T&gt; T[] toArray(T[] contents) 调用toArray()函数会抛出”java.lang.ClassCastException”异常，但是调用toArray(T[] contents)能正常返回T[]。toArray()会抛出异常是因为toArray()返回的是Object[]数组，将Object[]转换为其它类型（比如将Object[]转换为Integer[]）则会抛出”java.lang.ClassCastException”异常，因为java不支持向下转型。解决该问题的办法是调用T[] toArray(T[] contents)，而不是Object[] toArray()。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java容器</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式与Java容器]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8EJava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器模式迭代器模式，提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示，属于行为型模式。把在元素之间游走地责任交给迭代器，而不是聚合对象，并可以以不同方式来遍历整个聚合对象。 优点： 支持以不同方式遍历一个聚合对象； 将存储数据和遍历数据地职责分离，简化了聚合类； 在同一聚合上可以拥有多个遍历。 缺点： 将存储数据和遍历数据地职责分离，增加新地聚合类时，需要增加对应的迭代器，类的个数成对增加，在一定程度上提高了系统的复杂性。 实现 思路： 创建一个叙述导航方法的Iterator接口和一个返回迭代器的Container接口；实现了Container接口的实体类负责实现Iterator接口; IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的Names。 Iterator接口： 1234public interface Iterator &#123; public boolean hasNext(); public Object next();&#125; Container接口 123public interface Container &#123; public Iterator getIterator();&#125; 创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator 1234567891011121314151617181920212223242526272829public class NameRepository implements Container &#123; public String names[] = &#123;"Robert" , "John" ,"Julie" , "Lora"&#125;; @Override public Iterator getIterator() &#123; return new NameIterator(); &#125; private class NameIterator implements Iterator &#123; int index; @Override public boolean hasNext() &#123; if(index &lt; names.length)&#123; return true; &#125; return false; &#125; @Override public Object next() &#123; if(this.hasNext())&#123; return names[index++]; &#125; return null; &#125; &#125;&#125; 使用 NameRepository 来获取迭代器，并打印名字 1234567891011public class IteratorPatternDemo &#123; public static void main(String[] args) &#123; NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123; String name = (String)iter.next(); System.out.println("Name : " + name); &#125; &#125;&#125; 执行程序，输出结果： Name : Robert Name : John Name : Julie Name : Lora java容器中的迭代器模式 其中ListIterator和Iterable接口中定义了获取迭代器的方法iterator()； Collection接口继承了Iterable接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历Collection 中的元素； 关于ListIterator和Iterator的异同点： 一．相同点 都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。 1 二．不同点 使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能 用于List及其子类型。 ListIterator有add方法，可以向List中添加对象，而Iterator不能。 ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevi ous()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。 ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。 详细可去： https://www.cnblogs.com/a842297171/p/5379130.html]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML各种线的含义]]></title>
    <url>%2F2018%2F12%2F18%2FUML%E5%90%84%E7%A7%8D%E7%BA%BF%E7%9A%84%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[点击原文： http://www.cnblogs.com/me115/p/4092632.html 内容目录： 从一个示例开始 类之间的关系 时序图 附录：《图说设计模式》 看懂UML类图和时序图这里不会将UML的各种元素都提到，我只想讲讲类图中各个类之间的关系； 能看懂类图中各个类之间的线条、箭头代表什么意思后，也就足够应对 日常的工作和交流；同时，我们应该能将类图所表达的含义和最终的代码对应起来； 有了这些知识，看后面章节的设计模式结构图就没有什么问题了； 本章所有图形使用Enterprise Architect 9.2来画,所有示例详见根目录下的design_patterns.EAP 从一个示例开始请看以下这个类图，类之间的关系是我们需要关注的： 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 下面详细介绍这六种关系； 类之间的关系泛化关系(generalization)类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）； eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 注：最终代码中，泛化关系表现为继承非抽象类； 实现关系(realize)实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 注：最终代码中，实现关系表现为继承抽象类； 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系(composition)组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系处理临时知道对方外，还是“使用”对方的方法和属性； 时序图为了展示对象之间的交互细节，后续章节对设计模式中每个模式的介绍，都会用到时序图； 时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。 时序图包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。 关于时序图，以下这篇文章将概念介绍的比较详细，更多实例应用，参加后续章节中的模式中的时序图； http://smartlife.blog.51cto.com/1146871/284874 附录：《图说设计模式》本文为开源书籍 《图说设计模式》 的第一篇，目前这本书基本完成； 这本书使用图形和代码结合的方式来解析设计模式；每个模式都有相应的对象结构图，同时为了展示对象间的交互细节， 我会用到时序图来介绍其如何运行；（在状态模式中，还会用到状态图，这种图的使用对于理解状态的转换非常直观） 详情请见： https://github.com/me115/design_patterns （github中包含书中所有源代码及各个模式的类图）]]></content>
      <categories>
        <category>待办</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>uml</tag>
        <tag>类关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式介绍及分类]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述设计模式是针对某一类问题的最优解决方案，是从许多优秀的软件系统总结出来的。Java中设计模式通常有23种。模式可以分成3大类： 创建型、行为型、结构型 创建型模式创建型模式涉及 对象的实例化 ，特点是不让用户代码依赖于对象的创建或排列方式，避免用户直接使用new创建对象创建型模式有以下5种： 工厂方法模式、抽象工厂方法模式、生成器模式、单例模式。 行为型模式行为型模式涉及怎样合理的设计对象之间的 交互通信 ，以及怎样合理为对象 分配职责 ，让设计富有弹性，易维护，易复用行为型模式有以下11种： 责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。 结构型模式结构型模式涉及如何 组合类和对象以形成更大的结构 ，和类有关的结构型模式涉及如何 合理使用继承机制 ，和对象有关的结构型模式涉及如何合理地使用对象组合机制 。结构型模式有以下7种： 适配器模式、代理模式、组合模式、享元模式、外观模式、桥接模式、装饰模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F12%2F18%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义适配器模式的定义：将某个类的接口转换为接口客户所需类型，适配器模式解决的问题是：使得原本由于接口不兼容而不能一起工作、不能统一管理的那些类可以一起工作、可以进行同意管理。 举例实现这里有教师接口ITeacher、程序员接口IProgrammer，分别用于定义他们各自工种的具体工作。然后定义深圳大学的教师SZUTeacher、腾讯的程序员TcProgrammer。这些不同的工种所作的工作都各自不同，无法进行统一管理，协同工作。我们要做的是将这些不同工种的工作内容全部输出。 ITeacher接口 12345public interface ITeacher &#123; void teach();&#125; IProgrammer接口 12345public interface IProgrammer &#123; void code();&#125; SZUTeacher实现类 1234567891011public class SZUTeacher implements ITeacher &#123; @Override public void teach() &#123; System.out.println("教离散数学！");; &#125;&#125; TcProgrammer实现类 1234567891011public class TcProgrammer implements IProgrammer &#123; @Override public void code() &#123; System.out.println("编php程序！");; &#125;&#125; 不使用适配器模式不使用适配器模式，调用者需要定义出所有工作的对象，然后逐个对象调用自己的工作方法。 ​123456789public class Test1 &#123; public static void main(String[] args) &#123; ITeacher teacher = new SZUTeacher(); IProgrammer programmer = new TcProgrammer(); //逐个对象调用自己的工作方法 teacher.teach(); programmer.code(); &#125;&#125; 只定义一个适配器实现类这种方式类似与多功能充电器，一个电源插头上接着多种类型的充电接口。用户使用充电器充电时，需要使用电器接口与多功能充电器的充电插口逐个对比，接口匹配则可以开始充电。 适配器接口 1234567public interface IWorkerAdapter &#123; //为了兼容所有工种员工，这里的参数必须是Object类型 void work(Object worker);&#125; 单个适配器实现类 1234567891011121314151617181920public class WorkerAdapter implements IWorkerAdapter &#123; @Override public void work(Object worker) &#123; if(worker instanceof ITeacher)&#123; ((ITeacher) worker).teach(); &#125; if(worker instanceof IProgrammer)&#123; ((IProgrammer) worker).code(); &#125; &#125;&#125; 调用者 123456789101112131415161718192021public class Test2 &#123; public static void main(String[] args) &#123; ITeacher teacher = new SZUTeacher(); IProgrammer programmer = new TcProgrammer(); Object[] workers = &#123;teacher, programmer&#125;; IWorkerAdapter workerAdapter = new WorkerAdapter(); for(Object worker:workers)&#123; workerAdapter.work(worker); &#125; &#125;&#125; 为每一个工种定义一个适配器为每一个工种定义一个适配器 适配器接口 123456789public interface IWorkerAdapter2 &#123; void work(Object worker); //判断当前适配器是否支持指定工种对象 boolean supprots(Object worker);&#125; Teacher适配器实现类 123456789101112131415public class TeacherAdapter implements IWorkerAdapter2 &#123; @Override public void work(Object worker) &#123; ((ITeacher)worker).teach(); &#125; @Override public boolean supprots(Object worker) &#123; return (worker instanceof ITeacher); &#125;&#125; Programmer适配器实现类 123456789101112131415public class ProgrammerAdapter implements IWorkerAdapter2 &#123; @Override public void work(Object worker) &#123; ((IProgrammer)worker).code(); &#125; @Override public boolean supprots(Object worker) &#123; return (worker instanceof IProgrammer); &#125;&#125; 调用者 1234567891011121314151617181920212223242526272829303132333435public class Test3 &#123; public static void main(String[] args) &#123; ITeacher teacher = new SZUTeacher(); IProgrammer programmer = new TcProgrammer(); Object[] workers = &#123;teacher, programmer&#125;; for(Object worker:workers)&#123; IWorkerAdapter2 adapter = getAdapter(worker); adapter.work(worker); &#125; &#125; private static IWorkerAdapter2 getAdapter(Object worker) &#123; IWorkerAdapter2 teacherAdapter = new TeacherAdapter(); IWorkerAdapter2 programmerAdapter = new ProgrammerAdapter(); //获取所有工种适配器 IWorkerAdapter2[] allAdapter = &#123;teacherAdapter, programmerAdapter&#125;; //遍历每一个适配器，尝试哪一个适配器是对应工种 for(IWorkerAdapter2 adapter:allAdapter)&#123; if(adapter.supprots(worker))&#123; return adapter; &#125; &#125; return null; &#125;&#125; 补充：缺省适配器模式 缺省适配器模式是由适配器模式简化而来，省略了适配器模式中目标接口，也就是源接口和目标接口相同，原接口为接口，目标接口为类 典型的缺省适配器模式是JavaEE规范中的Servlet接口与GenericServlet抽象类 Servlet接口中包含五个抽象方法，而其中的service()方法才是用于实现业务逻辑的、必须要实现的方法，另外四个方法一般都是空实现，或简单实现 GenericServlet抽象类实现了Servlet接口的service()方法以外的另外四个方法，所以自定义的Servlet只需要继承GenericServlet抽象类，实现service()方法即可，无需再实现Servlet接口。]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F12%2F17%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.对代理模式的理解 代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介作用。 百度百科《代理模式》 使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑；客户类真正想要访问的是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。 我们可以用生活中的“代理律师”来理解“代理模式”： 当事人打官司，由于当事人并不非常了解官司过程，需要聘请律师来替他完成整个打官司的所有事务。所以整个打官司的过程，其实都是由律师完成，当事人均可不出现； 打官司（主业务），当事人（目标对象），律师（代理对象）；律师用自己的专业知识增强主业务； 需要注意的点：1.当事人与代理律师是为同一件事努力——代理类和目标类要实现同一接口，即业务接口；2.打官司所有的具体事务都是通过律师完成——客户类对目标类的调用均是通过代理类完成的；3.在打官司过程中需要当事人完成某些工作时，律师通知当事人，并出谋划策——代理类的执行既执行了对目标类的增强业务逻辑，又调用了目标类的主业务逻辑。 2.代理模式分类根据代理关系建立的时间不同，可以将代理分为两类：静态代理和动态代理；如同法律顾问和代理律师。 静态代理：静态代理，代理类是在程序运行之前就定义好的；类似于企业与企业的法律顾问，法律顾问是在企业打官司之前就已经存在的。 静态代理 动态代理：动态代理，程序在整个运行过程中根本不存在目标类的代理类，目标对象的代理对象是在程序运行时由jvm根据反射等机制由代理生成工具（如代理工厂类）动态生成的；类似于当事人需要打官司时临时聘请代理律师。常用的动态代理： JDK动态代理 CGLIB动态代理]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CGLIB动态代理]]></title>
    <url>%2F2018%2F12%2F17%2FCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[原理 不管是静态代理还是jdk动态代理，代理的条件之一就是要求目标类和代理类实现同一业务接口；所以，对于无接口类的代理，我们就不能再用之前的代理方式； CGLIB动态代理的生成原理是 生成目标类的子类，而子类是增强过的，即子类就是目标类的代理类 。所以，使用CGLIB动态代理，要求目标类必须能够被继承，即不能是final的类 实现 导入CDLIB的jar包：cglib-full.jar 定义目标类，不用实现任何接口 1234567891011public class AccountService &#123; //目标方法 public void transfer()&#123; System.out.println("转账！"); &#125;&#125; 创建代理类的工厂，该类需实现MethodInterceptor接口 声明目标类的成员变量，并创建接受该参数的构造器 定义代理生成方法，用于创建代理对象，即目标类的子类 定义回调接口方法，在这里对目标类进行增强 12345678910111213141516171819202122232425262728293031323334353637383940public class AccountServiceCglibProxyFactory implements MethodInterceptor &#123; //1. 声明目标类的成员变量，并创建接受该参数的构造器 private AccountService targer; public AccountServiceCglibProxyFactory(AccountService targer) &#123; this.targer = targer; &#125; public AccountServiceCglibProxyFactory() &#123; &#125; //2. 定义代理生成方法，用于创建代理对象，即目标类的子类 public AccountService createProxy()&#123; //创建增强器 Enhancer enhancer = new Enhancer(); //初始化增强器，将目标类指定为父类 enhancer.setSuperclass(AccountService.class); //初始化增强器，设置回调方法,因为MethodInterceptor接口继承自Callback，因此可以使用this enhancer.setCallback(this); //使用增强器创建代理对象 return (AccountService) enhancer.create(); &#125; //3. 定义回调接口方法，在这里对目标类进行增强； //本类中调用了Enhance类的setCallback(this)方法，并将回调对象this作为实参传递给了Enhancer类； //Enhancer类在后续的执行过程中，会调用本类的intercept方法； //这个intercept()方法就是回调方法 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; //若为transfer方法，则进行增强 if("transfer".equals(method.getName()))&#123; //直接调用目标对象的业务方法执行 Object result = method.invoke(targer, objects); return result; &#125; return method.invoke(targer, objects); &#125;&#125; 定义客户类 12345678910public class Client &#123; public static void main(String[] args) &#123; //创建目标对象 AccountService target = new AccountService(); //创建代理对象 AccountService proxy = new AccountServiceCglibProxyFactory(target).createProxy(); //执行增强后的业务方法 proxy.transfer(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>CGLIB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK动态代理]]></title>
    <url>%2F2018%2F12%2F17%2FJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[原理 通过JDK的java.lang.reflect.Proxy类实现动态代理，使用其静态方法newProxyInstance()，依据目标对象，业务接口和业务逻辑增强三者动态生成代理对象。 12345678910111213141516/**- @param loader the class loader to define the proxy class - 目标类的类加载器，通过目标对象的发射可获取- @param interfaces the list of interfaces for the proxy class- to implement - 目标类实现的接口数组，通过反射可获取- @param h the invocation handler to dispatch method invocations to - 业务增强逻辑，需要再定义- @return a proxy instance with the specified invocation handler of a- proxy class that is defined by the specified class loader- and that implements the specified interfaces */ public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) InvocationHandler是个接口，实现该接口的类用于增强目标类的主业务逻辑。接口中定义了一个invoke()方法，具体加强的代码逻辑定义在该方法中。程序在调用主业务逻辑时自动调用invoke()方法。 12345678910111213141516171819202122232425262728293031323334353637/** * @param proxy the proxy instance that the method was invoked on * 生成的代理对象 * @param method the &#123;@code Method&#125; instance corresponding to * the interface method invoked on the proxy instance. The declaring * class of the &#123;@code Method&#125; object will be the interface that * the method was declared in, which may be a superinterface of the * proxy interface that the proxy class inherits the method through. * 目标方法 * @param args an array of objects containing the values of the * arguments passed in the method invocation on the proxy instance, * or &#123;@code null&#125; if interface method takes no arguments. * Arguments of primitive types are wrapped in instances of the * appropriate primitive wrapper class, such as * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;. * 目标方法的参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 由于该方法是由代理对象自动调用，所以三个参数不需程序员给出； 第二个参数Method类对象，该类中也有一个方法invoke()，可以 调用目标类的目标方法 ，该方法的具体作用是：调用执行obj对象所属类的方法。 实现 定义业务接口，简单的转账业务 1234567public interface IAccountService &#123; //主业务逻辑，转账 void transfer();&#125; 定义目标类，该类实现业务接口，并实现接口定义的目标方法（只实现主业务逻辑转账） 12345678910111213public class AccountServiceImpl implements IAccountService &#123; //目标方法 @Override public void transfer() &#123; System.out.println("完成转账功能"); &#125;&#125; 定义主业务增强逻辑类，该类需实现InvokeHandler接口，在invoke()方法中增加增强业务的代码 123456789101112131415161718192021public class MyExtension implements InvocationHandler &#123; //目标对象 private Object target; //将目标对象引入，以便在invoke()中调用目标对象的目标方法 public MyExtension(Object target) &#123; this.target = target; &#125; public MyExtension() &#123; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //增强业务逻辑的代码 System.out.println("对转账人身份进行了验证！"); //无论主业务方法有无参数，有无返回值，下面的写法均可兼顾到 return method.invoke(target, args); &#125;&#125; 定义客户类 1234567891011121314151617181920212223242526public class Client &#123; public static void main(String[] args) &#123; //定义目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象，并使用目标对象对其初始化 IAccountService proxy = (IAccountService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new MyExtension(target) ); //执行增强业务之后的方法 proxy.transfer(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理]]></title>
    <url>%2F2018%2F12%2F17%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[静态代理，代理类是在程序运行之前就定义好的 定义业务接口，简单的转账业务 1234567public interface IAccountService &#123; //主业务逻辑，转账 void transfer();&#125; 定义目标类，该类实现业务接口，并实现接口定义的目标方法（只实现主业务逻辑转账） 12345678910111213public class AccountServiceImpl implements IAccountService &#123; //目标方法 @Override public void transfer() &#123; System.out.println("完成转账功能"); &#125;&#125; 定义代理类，该类实现业务接口。并且将接口对象作为一个成员变量，还要定义一个带参数（接口对象）的构造器，因为要将目标对象引入代理类，以便代理类调用目标类的目标方法 123456789101112131415161718192021public class AccountProxy implements IAccountService &#123; //声明业务接口对象 private IAccountService target; public AccountProxy() &#123; &#125; // 业务接口对象作为构造器参数 public AccountProxy(IAccountService target) &#123; this.target = target; &#125; /** * 代理方法，实现对目标方法的功能增强 */ @Override public void transfer() &#123; //对目标方法的增强 System.out.println("对转账人身份进行了验证！！"); target.transfer(); &#125;&#125; 定义客户类实现使用代理类转账。 123456789101. public class Client &#123; public static void main(String[] args) &#123; //创建目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象 IAccountService proxy = new AccountProxy(target); //执行增强过的业务 proxy.transfer(); &#125; &#125;]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git远程仓库与本地仓库关联错了？]]></title>
    <url>%2F2018%2F10%2F29%2Fgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E9%94%99%E4%BA%86%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[远程仓库与本地仓库关联 1.git remote add origin git@github.com:github_username/reposity_name.git 2.git remote add origin https://github.com:github_username/reposity_name.git 远程仓库与本地仓库取消 git remote remove origin]]></content>
      <categories>
        <category>待办</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logback]]></title>
    <url>%2F2018%2F10%2F24%2Flogback%2F</url>
    <content type="text"><![CDATA[logback介绍 使用logback的目的 故障定位 显示程序运行状态，定位为题的依据 三大模块 logback-access 与servlet容器集成，提供通过http访问日志功能，意思就是第三方软件可以通过这个模块来访问logback记录的日志 logback-classic log4j的改良版本，完整实现了slf4j的API，可以让我们很方便地更换成其他日志系统，比如说log4j等； logback-core 为前面两个模块提供基础模块 logback配置 当我们使用logback-classic.jar时，应用启动，logback加载顺序： 在系统配置文件System Properties中寻找是否有logback.configurationFile对应的value 在classpath下寻找是否有logback.groovy（即logback支持groovy与xml两种配置方式） 在classpath下寻找是否有logback-test.xml 在classpath下寻找是否有logback.xml logback主要标签介绍 &lt;configuration&gt;，只有三个属性，分别是： scan：当scan被设置为true时，当配置文件发生改变，将会被重新加载，默认为true scanPeriod：检测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认为毫秒，当scan=true时这个值生效，默认时间间隔为1分钟 debug：当被设置为true时，将打印出logback内部日志信息，实时查看logback运行信息，默认为false； &lt;appender&gt;，指定日志输出目的地，即日志输出的媒介，可以是控制台、文件、远程套接字服务器等 ConsoleAppender，将日志输出到控制台 123456&lt;!-- 控制台设置 --&gt;&lt;appender name="consoleAppender" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; FileAppender，将日志输出到文件中 1234567&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt; &lt;file&gt;D:/123.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; RollingFileAppender，滚动记录文件，先将日志记录到指定文件，当符合某个条件时再讲日志记录到其他文件 1234567891011121314151617181920212223&lt;!-- DEBUG --&gt;&lt;appender name="debugAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;log.filePath&#125;/debug.log&lt;/file&gt; &lt;!-- &lt;rollingPolicy&gt;的作用是当发生滚动时，定义RollingFileAppender的行为，其中上面的TimeBasedRollingPolicy是最常用的滚动策略，它根据时间指定滚动策略，既负责滚动也负责触发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;log.filePath&#125;/debug/debug.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 输出格式 --&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 在当前给到的日志级别下再进行一次过滤 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt;&lt;/appender&gt; &lt;logger&gt;，作为日志的记录器，主要用于存放日志对象，还可以定义日志类型、级别等；其中有&lt;root&gt;标签，也是&lt;logger&gt;元素，是根logger，只有一个level属性；logger有三个属性： 123456789&lt;logger name="com.enpong.o2o" level="$&#123;log.level&#125;" additivity="true"&gt;&lt;appender-ref ref="debugAppender"/&gt;&lt;appender-ref ref="infoAppender"/&gt;&lt;appender-ref ref="errorAppender"/&gt;&lt;/logger&gt;&lt;root level="info"&gt;&lt;appender-ref ref="consoleAppender"/&gt;&lt;/root&gt; name：用来指定受此logger约束的某一个包或者具体的某一个类 level（可选）：用来设置打印级别，五个常用打印级别从低至高依次为TRACE、DEBUG、INFO、WARN、ERROR，如果未设置此级别，那么当前logger会继承上级的级别 additivity（可选）：是否向上级logger传递打印信息，默认为true 全部配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义参数常量 --&gt; &lt;!-- TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR --&gt; &lt;!-- logger.trace("msg") logger.debug... --&gt; &lt;property name="log.level" value="debug" /&gt; &lt;property name="log.maxHistory" value="30" /&gt; &lt;property name="log.filePath" value="$&#123;catalina.base&#125;/logs/webapps" /&gt; &lt;property name="log.pattern" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n" /&gt; &lt;!-- 控制台设置 --&gt; &lt;appender name="consoleAppender" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- DEBUG --&gt; &lt;appender name="debugAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;log.filePath&#125;/debug.log&lt;/file&gt; &lt;!-- &lt;rollingPolicy&gt;的作用是当发生滚动时，定义RollingFileAppender的行为，其中上面的TimeBasedRollingPolicy是最常用的滚动策略，它根据时间指定滚动策略，既负责滚动也负责触发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;log.filePath&#125;/debug/debug.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- INFO --&gt; &lt;appender name="infoAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;log.filePath&#125;/info.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;log.filePath&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- ERROR --&gt; &lt;appender name="errorAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;log.filePath&#125;/erorr.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;log.filePath&#125;/error/error.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;logger name="com.enpong.o2o" level="$&#123;log.level&#125;" additivity="true"&gt; &lt;appender-ref ref="debugAppender"/&gt; &lt;appender-ref ref="infoAppender"/&gt; &lt;appender-ref ref="errorAppender"/&gt; &lt;/logger&gt; &lt;root level="info"&gt; &lt;appender-ref ref="consoleAppender"/&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>后端</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2018%2F10%2F23%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[安装git 创建版本库 多了.git目录，这个目录是git来跟踪管理版本库的，切记不可修改里面的文件，以防破坏仓库 把文件放到git仓库 用命令git add把文件添加到仓库 用git commit把文件提交到仓库 git commit -m，-m后面是本次提交的说明 继续修改readme.txt文件 git status命令让我们掌握仓库当前的状态，可以知道某些文件被修改了，但无法看到修改的具体内容 用git diff命令查看修改的具体内容 查看修改内容后，提交到仓库，谨慎的步骤 git add git status查看 git commit -m git status 版本回退 git log命令查看提交记录，记录从最近到最远排列 git reset HEAD^，回退到HEAD^版本（^表示上一个版本，^^表示上上版本，……） git reset+（版本号），可以找到某个版本，这是在窗口未关闭前的 如果git关闭后，想找到之前的版本，还可以git reflog获取之前每一次命令 工作区，暂存区，版本库概念，只有先放在暂存区的修改才会被提交 撤销修改（git checkout –file，让文件回到最近一次git commit或git add时的状态，用版本库里的版本替换工作区的版本） 一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset命令既可以回退版本，也可以把暂存区的修改撤销掉，重新返回工作区 远程仓库 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴 id_rsa.pub 文件的内容 3. 添加远程库 1. 在github上创建一个新的git仓库（目前还是空的，因为没关联到本地仓库） 2. git remote add origin git@github.com:enpong/git.git（远程仓库与本地仓库的关联） 1. ![](https://img-blog.csdn.net/20181023172916608?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 3. git push -u origin master，把当前分支master推送到远程，-u把本地的master分支与远程的master分支关联起来；在以后的提交中不需-u 分支管理 创建与合并分支 （git checkout -b + 分支）或 （git branch + 分支，git checkout + 分支），创建并切换分支 （git branch）查看所有分支，（git checkout + 分支）切换分支 （git merge + 分支），把指定分支的工作合并到当前分支 （git branch -d + 分支），删除指定分支 解决冲突 分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先， master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在 dev 分支上，也就是说， dev 分支是不稳定的，到某个时候，比如1.0版本发布时，再把 dev分支合并到 master 上，在 master 分支发布1.0版本； 你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 保存工作现场去做其他工作后接着继续原来的工作 （git stash），把当前工作现场保存起来 （git stash list），查看保存的工作现场 恢复工作现场 （git stash apply）恢复，（git stash drop）删除 （git stash pop），恢复同时删除]]></content>
      <categories>
        <category>待办</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
