<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode---241. 为运算表达式设计优先级]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode---241.%20%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88742790 回溯搜索。该问题牵涉到括号的组合问题，一般使用递归+回溯的思想。主要想法： 递归回溯。可以产生所有的组合方式。 每个小组合方式相当于一个子集，不断的将计算结果返回给上一层。 举例：a + (b - (c d))会不断的变成a + (b - (res1 res2))-&gt; a + (res1 - res2) -&gt; res1 res2 计算结果需要for循环！！！其实有这种情况，a + (b - (c d))和a + (b - c) d))，这里 a +res2，res2就可能有多种情况。 class Solution { public List&lt;Integer&gt; diffWaysToCompute(String input) { List&lt;Integer&gt; ways = new ArrayList&lt;&gt;(); for(int i=0; i&lt;input.length(); i++){ char c = input.charAt(i); if(c==&apos;+&apos; || c==&apos;-&apos; || c==&apos;*&apos;){ List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0, i)); List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+1)); for(Integer l : left){ for(Integer r : right){ switch(c){ case &apos;+&apos;: ways.add(l+r); break; case &apos;-&apos;: ways.add(l-r); break; case &apos;*&apos;: ways.add(l*r); break; } } } } } if(ways.size()==0) ways.add(Integer.valueOf(input)); return ways; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode---二分查找]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode---%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88741847 //二分查找基本实现 public int binarySearch(int[] nums, int key){ int l = 0, h = nums.length-1; while(l&lt;=h){ int mid = l+(h-l)/2; //防止(h+l)/2加法溢出 if(nums[mid]==key) return mid; else if(nums[mid]&gt;key) h = mid-1; else l = mid+1; } return -1; } /** * 变种二分查找，找出数组中key重复元素最左位置(注意边界) */ public int binarySearch(int[] nums, int key){ int l=0, h=nums.length-1; while(l&lt;h){ int mid = l+(h-l)/2; if(nums[mid]&gt;=key) h = mid; else l = mid+1; } if(nums[l]==key) return l; else return -1; } //求开方 69. Sqrt(x) (Easy) public int mySqrt(int x){ if(x&lt;=1) return x; int l=1,h=x; while(l&lt;=h){ int mid = l+(h-l)/2; int sqrt = x/mid; if(sqrt==mid) return mid; else if(mid&gt;sqrt) h = mid-1; else l = mid+1; } return h; } //给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符 //744. Find Smallest Letter Greater Than Target (Easy) public char nextGreatestLetter(char[] letters, char target){ int l=0, h=letters.length-1; while(l&lt;=h){ int mid = l+(h-l)/2; if(letters[mid]&lt;=target) l = mid+1; else h = mid-1; } return l&lt;letters.length ? letters[l] : letters[0]; } //以O(logN)时间复杂度找出有序数组中唯一不出现2次的元素 //540. Single Element in a Sorted Array (Medium) //假设index是该元素所在位置，mid是偶数，则当(mid+1&lt;index)时，nums[m]==nums[m+1]; //当(mid+1&gt;=index),nums[m]!=nums[m+1] //因此，m为偶数的情况下，当nums[m]==nums[m+1],index所在区间应该为[m+2,h];否则，index在[l,m]; public int singleNonDuplicate(int[] nums){ int l=0, h=nums.length-1; while(l&lt;h){ int mid = l+(h-l)/2; if(mid%2==1) mid--; //保证mid是偶数 if(nums[mid]==nums[mid+1) l = m+2; else h = m; } return h; } //旋转数组中的最小数字 153. Find Minimum in Rotated Sorted Array (Medium) public int findMin(int[] nums){ int l=0, h=nums.length-1; while(l&lt;h){ int mid = l+(h-l)/2; if(nums[mid]&lt;=nums[h]) h = mid; else l = mid+1; } return nums[l]; } //查找区间，找到最左位置，找到最右位置 //34. Search for a Range (Medium) public int findRange(int[] nums, int target){ int first=0, last=0; int l=0, h=nums.length-1; //找最左位置 while(l&lt;h){ int mid = l+(h-l)/2; if(nums[mid]&gt;=target) h = mid; else l = mid+1; } if(nums[l]!=target) return new int{-1,-1}; else{ first = l; //找最右位置 l=0, h=nums.length-1; while(l&lt;h){ int mid = l+(h-l+1)/2;//这里mid选择向上取整，否则会死循环 if(nums[mid]&lt;=target) l = mid; else h = mid-1; } last = h; return new int{first, last}; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统---线程同步]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88718474 进程中线程同步的四种常用方式：临界区（CCriticalSection)当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区对象的线程可以访问被保护的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程释放临界区为止。 定义临界区对象CCriticalSection g_CriticalSection； 在访问共享资源之前，先获取临界区对象，g_CriticalSection； 访问资源结束后，释放临界区对象，g_CriticalSection.unLock(); 事件（CEvent）事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。每个Cevent对象可以有两种状态：有信号状态和无信号状态。Cevent类对象有两种类型：人工事件和自动事件。自动事件对象，在被至少一个线程释放后自动返回到无信号状态；人工事件对象，获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。在创建Cevent对象时，默认创建的是自动事件。 互斥量（CMutex）互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。 信号量（CSemphore）当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现LRU策略缓冲]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%AE%9E%E7%8E%B0LRU%E7%AD%96%E7%95%A5%E7%BC%93%E5%86%B2%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88358466 1.基于”双向链表+HashMap“实现： 访问某个节点时，将该节点从双向链表中原位置删除，并重新插入链表头。这样可以保证链表尾部节点就是最近最久未被使用的，当节点数量大于缓存空间就淘汰链表尾部节点； 为了能在O(1)时间内从链表删除某个节点，不能通过遍历链表查找该节点。需要借助HashMap存储key与节点的映射，通过key在O(1)时间内找到节点，并在O(1)时间内删除该节点。 public class LRU&lt;K, V&gt; implements Iterable&lt;K&gt; { private Node head; private Node tail; private HashMap&lt;K, Node&gt; map; private int maxSize; private class Node { Node pre; Node next; K k; V v; public Node(K k, V v) { this.k = k; this.v = v; } } public LRU(int maxSize) { this.maxSize = maxSize; this.map = new HashMap&lt;&gt;(maxSize * 4 / 3); head = new Node(null, null); tail = new Node(null, null); head.next = tail; tail.pre = head; } public V get(K key) { if (!map.containsKey(key)) { return null; } Node node = map.get(key); unlink(node); appendHead(node); return node.v; } public void put(K key, V value) { if (map.containsKey(key)) { Node node = map.get(key); unlink(node); } Node node = new Node(key, value); map.put(key, node); appendHead(node); if (map.size() &gt; maxSize) { Node toRemove = removeTail(); map.remove(toRemove.k); } } private void unlink(Node node) { Node pre = node.pre; Node next = node.next; pre.next = next; next.pre = pre; node.pre = null; node.next = null; } private void appendHead(Node node) { Node next = head.next; node.next = next; next.pre = node; node.pre = head; head.next = node; } private Node removeTail() { Node node = tail.pre; Node pre = node.pre; tail.pre = pre; pre.next = tail; node.pre = null; node.next = null; return node; } @Override public Iterator&lt;K&gt; iterator() { return new Iterator&lt;K&gt;() { private Node cur = head.next; @Override public boolean hasNext() { return cur != tail; } @Override public K next() { Node node = cur; cur = cur.next; return node.k; } }; } } 2.使用Java容器中的LinkedHashMap LinkedHashMap继承自HashMap，因此具有和HashMap一样的快速查找特性； 内部维护了一个双向链表，用来维护插入顺序或者LRU顺序；accessOrder字段决定了顺序，默认为false（插入顺序）； 因此，LinkedHashMap = ”双向链表”+HashMap. 但是LinkedHashMap实现的LRU缓存与第1个实现方式有一点 区别，即LinkedHashMap的链表首部才是最近最久未使用节点 ；当然，这个区别对于双向链表来说不是事儿，只是寓意上的区别而已（在我看来）。 访问一个节点时，调用get()方法，get()中有一个函数afterNodeAccess()；该方法用于将该节点移到链表尾部（最近访问节点） void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) { LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } } 在put等操作之后执行afterNodeInsertion()，当removeEldestEntry()方法返回true时会移除最晚的节点，也就是链表首部节点；evict只有在构建Map时才为false，在这里为true. void afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) { K key = first.key; removeNode(hash(key), key, null, false, true); } } removeEldestEntry()默认为false，也就是说put操作后执行的afterNodeInsertion()并没有移除首部节点，也就没有LRU缓存淘汰的说法了；如果需要让它为true，需要继承LinkedHashMap并且覆盖该方法； protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) { return false; } 因此，要用LinkedHashMap来实现一个LRU缓存，需要：1.设定最大缓存空间MAX_ENTRIES2.使用LinkedHashMap的构造方法将accessOrder设置为true，开启LRU顺序；3.覆盖removeEldestEntry（）方法实现，在节点多于MAX_ENTRIES就会将最近最久未使用的节点删除。 class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; { private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) { return size() &gt; MAX_ENTRIES; } LRUCache() { super(MAX_ENTRIES, 0.75f, true); } } public class LRUTest{ public static void main(String[] args) { LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, &quot;a&quot;); cache.put(2, &quot;b&quot;); cache.put(3, &quot;c&quot;); cache.get(1); cache.put(4, &quot;d&quot;); System.out.println(cache.keySet()); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>LRU</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程的中断操作]]></title>
    <url>%2F2019%2F03%2F06%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88238190 InterruptedException如果一个线程处于阻塞、限期等待或无限期等待状态时，调用该线程的interrupt()方法中断线程，就会抛出InterruptedException，从而提前结束该线程；（注意：不能中断IO阻塞和Synchronized锁阻塞） Interupted 如果一个线程的run()方法执行一个循环体，并且循环体中没有会抛出InterruptedException的操作（如sleep())，那么该线程调用interrupted()就无法中断线程； 由于一个线程调用interrupt()会设置线程中断标志，该标志可以通过interrupted()来获取；因此可以在run()方法的循环体中以该标志来判断线程是否处于中断状态，以结束线程。 Executor中断操作 Executor的shutDown()会等待所有线程执行完毕之后再关闭；而调用shutDownNow()，相当于调用每个线程的interrupt()方法，中断所有线程； 如果只想中断Executor中的一个线程，可以使用submit()提交一个线程，该方法返回一个Future&lt;?&gt;对象，通过调用该对象的cancel(true)方法中断线程。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web页面请求过程]]></title>
    <url>%2F2019%2F03%2F06%2FWeb%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[转自： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/计算机网络.md#web-页面请求过程 DHCP配置主机信息 假设主机最开始没有IP地址以及其他信息，那么就需要先使用DHCP来获取； 主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中； 该报文段则被放入在一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中； 该数据报则被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备； 连接在交换机的DHCP服务器收到广播帧之后，不断向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中； 该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧； 主机收到该帧后，不断向上分解得到DHCP报文。之后就配置它的IP地址，子网掩码和DNS服务器IP地址，并在其IP转发表中安装默认网关． ARP解析MAC地址 主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成该套接字，主机需要知道网站的域名对应的IP地址。 主机生成一个DNS查询报文，该报文具有53端口，因为DNS服务器的端口号时53； 该DNS查询报文被放入目的地址为DNS服务器的IP数据报中； 该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器； DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议； 主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将该ARP查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器； 网关路由器接收到该帧后，不断向上分解得到ARP报文，发现其中的IP地址与其接口的IP地址匹配，因此就发送ARP回答报文，包含了它的MAC地址，发回给主机。 DNS解析域名 知道了网关路由器的MAC地址之后，就可以继续DNS的解析过程了； 网关路由器接收到包含DNS查询报文的以太网帧后，抽取出IP数据报，并根据转发表决定该IP数据报应该转发的路由器； 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达DNS服务器的路由表项； 到达DNS服务器后，DNS服务器抽取出DNS查询报文，并在DNS数据库中查找待解析的域名； 找到DNS记录之后，发送DNS回答报文，将该回答报文放入UDP报文段中，然后放入IP数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 HTTP请求页面 有了HTTP服务器的IP地址，主机就能够生成TCP套接字，该套接字将用于向Web服务器发送HTTP GET报文； 在生成TCP套接字之前，必须先与HTTP服务器进行三次握手来建立连接。生成一个具有目的端口80的TCP SYN报文段，并向HTTP服务器发送该报文段； HTTP服务器接到该报文段之后，生成TCP SYN ACK报文段，发回给主机； 连接建立之后，浏览器生成HTTP GET报文，并交付给HTTP服务器； HTTP服务器从TCP套接字中读取HTTP GET报文，生成一个HTTP响应报文，将Web页面内容放入报文体中，发回给主机； 浏览器收到HTTP响应报文后，抽取出Web页面内容，之后进行渲染，显示Web页面。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五种IO模型]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88177447 一个输入操作通常有两个阶段： 等待数据准备，即从存储介质（磁盘，网络等）拷贝到内核； 从内核向进程复制数据 阻塞I/O 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回 非阻塞I/O 应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。 I/O复用 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中； 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。 信号驱动I/O 通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的； 当数据报准备好被读时，就为该进程生成一个SIGIO信号； 应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。 异步I/O 应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号； 调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。 对比五种I/O模型 同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞； 异步I/O：在I/O操作未完成前，请求进程未被阻塞。 阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>I</tag>
        <tag>O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中BitSet]]></title>
    <url>%2F2019%2F03%2F02%2FJAVA%E4%B8%ADBitSet%2F</url>
    <content type="text"><![CDATA[JAVA中BitSet就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个数据结构KEY和Value的保存需要消耗较多的内存，不适合保存较多的数据，即大数据场景；比如在有10亿条URL中判定一个（ www.baidu.com ）是否存在，如果我们使用常规的hashmap来保存将是不现实的，因为URL本身需要占据较多的内存而无法直接操作。如果我们使用bitset来保存，那么可以对一条URL求hashcode，并将数字映射在bitset上，那么事实上它只需要bitset上的一个bit位即可，即我们1位空间即可表达一个URL字符串的存在性。 所谓“存在性”，就是通过BitSet来检测一个数字是否存在。 BitSet原理JAVA中，一个long型数字占用64位空间，根据上述“位图”的概念，那么一个long型数字（4个字节）就可以保存64个数字的“存在性”状态(无碰撞冲突时，即true、false状态)。比如50个数字{0,1,10,…63}，判定“15”是否存在，那么我们通常会首先将这些数字使用数组或者hashmap保存，然后再去判定，那么保存这些这些数据需要占用64 * 64位；如果使用位图，那么一个long型数字即可。（如果换成50个字符串，那么其节约的空间可能更大）。 BitSet只面向数字比较，比如set(int a,boolean value)方法，将数字a在bitSet中设定为true或者false；此后可以通过get(int a)方法检测结果。对于string类型的数据，如果像使用BitSet，那么可以将其hashcode值映射在bitset中。 首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 数字范围 [0,63] [64,127] [128,191] … long数组索引 0 1 2 … bitSet内部的long[]数组是基于向量的，即随着set的最大数字而动态扩展。数组的最大长度计算： (maxValue - 1) &gt;&gt; 6 + 1 BitSet中set方法伪代码： public void set(int number) { int index = number &gt;&gt; 6;//找到number需要映射的数组的index。 if(index + 1 &gt; length) { ensureCapacity(index + 1);//重新扩展long[]数组 } long[index] |= (1L &lt;&lt; number);//冲突解决} 使用BitSet本例中使用bitSet做String字符串的存在性校验。 BitSet bitSet = new BitSet(Integer.MAX_VALUE);//hashcode的值域 //0x7FFFFFFF String url = &quot;http://baidu.com/a&quot;; int hashcode = url.hashCode() &amp; 0x7FFFFFFF; bitSet.set(hashcode); System.out.println(bitSet.cardinality());//着色位的个数 System.out.println(bitSet.get(hashcode));//检测存在性 bitSet.clear(hashcode);//清除位数据 BitSet与Hashcode冲突因为BitSet API只能接收int型的数字，即只能判定int数字是否在bitSet中存在。所以，对于String类型，我们通常使用它的hashcode，但这有一种隐患，java中hashcode存在冲突问题，即不同的String可能得到的hashcode是一样的（即使不重写hashcode方法），如果我们不能很好的解决这个问题，那么就会出现“数据抖动”—不同的hashcode算法、运行环境、bitSet容量，会导致判断的结果有所不同。比如A、B连个字符串，它们的hashcode一样，如果A在BitSet中“着色”(值为true)，那么检测B是否在BitSet存在时，也会得到true。 这个问题该如何解决或者缓解呢？ 调整hashcode生成算法：我们可以对一个String使用多个hashcode算法，生成多个hashcode，然后在同一个BitSet进行多次“着色”，在判断存在性时，只有所有的着色位为true时，才判定成功 String url = “http://baidu.com/a&quot;;int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF;bitSet.set(hashcode1); int hashcode2 = (url + “-seed-“).hashCode() &amp; 0x7FFFFFFF;bitSet.set(hashcode2);System.out.println(bitSet.get(hashcode1) &amp;&amp; bitSet.get(hashcode2));//也可以在两个不同的bitSet上进行2次“着色”，这样冲突性更小。但会消耗双倍的内存 其实我们能够看出，这种方式降低了误判的概率。但是如果BitSet中存储了较多的数字，那么互相覆盖着色，最终数据冲突的可能性会逐渐增加，最终仍然有一定概率的判断失误。所以在hashcode算法的个数与实际String的个数之间有一个权衡，我们建议: “hashcode算法个数 String字符串的个数” &lt;Integer.MAX_VALUE 0.8 多个BitSet并行保存：改良1)中的实现方式，我们仍然使用多个hashcode生成算法，但是每个算法生成的值在不同的BitSet中着色，这样可以保持每个BitSet的稀疏度(降低冲突的几率)。在实际结果上，比1)的误判率更低，但是它需要额外的占用更多的内存，毕竟每个BitSet都需要占用内存。这种方式，通常是缩小hashcode的值域，避免内存过度消耗。 BitSet bitSet1 = new BitSet(Integer.MAX_VALUE);//127M BitSet bitSet2 = new BitSet(Integer.MAX_VALUE); String url = &quot;http://baidu.com/a&quot;; int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF; bitSet1.set(hashcode1); int hashcode2 = (url + &quot;-seed-&quot;).hashCode() &amp; 0x7FFFFFFF; bitSet2.set(hashcode2); System.out.println(bitSet1.get(hashcode1) &amp;&amp; bitSet2.get(hashcode2)); 是否有必要完全避免误判？如果做到100%的正确判断率，在原理上说BitSet是无法做的，BitSet能够保证“如果判定结果为false，那么数据一定是不存在；但是如果结果为true，可能数据存在，也可能不存在(冲突覆盖)”,即“false == YES，true ==Maybe”。有人提出将冲突的数据保存在类似于BTree的额外数据结构中，事实上这种方式增加了设计的复杂度，而且最终仍然没有良好的解决内存占用较大的问题。 BloomFilter(布隆姆过滤器)BloomFilter 的设计思想和BitSet有较大的相似性，目的也一致，它的核心思想也是使用多个Hash算法在一个“位图”结构上着色，最终提高“存在性”判断的效率。请参见Guava BloomFilter。如下为代码样例： Charset charset = Charset.forName(&quot;utf-8&quot;); BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(charset),2&lt;&lt;21);//指定bloomFilter的容量 String url = &quot;www.baidu.com/a&quot;; bloomFilter.put(url); System.out.println(bloomFilter.mightContain(url)); 内存消耗据上所述，BitSet可以有效的降低内存的使用量，但是它的内存使用量是有内部long数组的大小决定，所以在创建BitSet时指定的值域非常重要，过大的值域将会导致OOM（比如指定Long.MAX_VALUE）,在一个BitMap上存储Integer.MAX_VALUE个“着色”（注意，BitSet只能对正数操作），大概消耗128M内存。 转自： https://shift-alt-ctrl.iteye.com/blog/2194519]]></content>
      <categories>
        <category>java</category>
        <category>大数据量</category>
      </categories>
      <tags>
        <tag>BitSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode---208.实现Trie前缀树]]></title>
    <url>%2F2019%2F03%2F02%2FLeetcode---208.%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88079131 Java非递归版 class Trie { private class Node{ boolean isTrie; Map&lt;Character, Node&gt; children = new HashMap&lt;&gt;(); } private Node root = new Node(); /** Initialize your data structure here. */ public Trie() { } /** Inserts a word into the trie. */ public void insert(String word) { Node node = root; for(int i=0; i&lt;word.length(); i++){ char c = word.charAt(i); if(!node.children.containsKey(c)){ node.children.put(c, new Node()); } node = node.children.get(c); } node.isTrie = true; return; } /** Returns if the word is in the trie. */ public boolean search(String word) { Node node = root; for(int i=0; i&lt;word.length(); i++){ char c = word.charAt(i); Node temp = node.children.get(c); if(temp == null) return false; node = temp; } return node.isTrie; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Node node = root; for(int i=0; i&lt;prefix.length(); i++){ char c = prefix.charAt(i); Node temp = node.children.get(c); if(temp == null) return false; node = temp; } return node!=null; } } 关于Trie 核心思想：空间换取时间 Trie 树又叫又叫字典树、前缀树、单词查找树，它是一颗多叉查找树。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。 如果 海量数据 是字符串数据，那么就可以用很小的空间开销构建一颗 Trie 树，空间开销和树高有关。 {“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 基本性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 优点 插入和查询效率很高，都是O(m)，m是待插入/查询字符串长度；（关于查询，会有人认为hash表时间复杂度O(1)不是更快？确实，但是哈希搜索的效率通常取决于hash函数的好坏，因为这决定着冲突的概率）。 Trie树中不同关键字不会冲突； 可以对关键字按字典排序。 缺点 当hash函数很好时，Trie树的查找效率会低于哈希查找； 空间消耗比较大。 主要应用：字符串检索、词频统计、字符串排序、前缀匹配等]]></content>
      <categories>
        <category>undefined</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---删除链表中重复的结点]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%89%91%E6%8C%87offer---%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88075375 😊题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为1-&gt;2-&gt;5 解题思路（递归） 代码//这里不对节点删除是因为Java有回收机制，当然手动删除也可以啦 public class Solution { public ListNode deleteDuplication(ListNode pHead) { if(pHead==null || pHead.next==null) return pHead; ListNode node = pHead.next; if(pHead.val == node.val){ while(node!=null &amp;&amp; pHead.val==node.val) node = node.next; return deleteDuplication(node); }else{ pHead.next = deleteDuplication(pHead.next);//当前节点的后继指针指向后继链表的去重链表 return pHead; } } }]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode869---重新排序得到2的幂]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode869---%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88074612 😍题目描述从正整数 N 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回false。 😘解题思路 先将数值N中的每个数字独立存储并排序为list，长度记作n；在2的幂中找出长度为n的所有数值，并同样对每个数字存储排序,得到list2，判断list与list2是否逐位相等 对于2的幂的正整数，有个规律：位数每隔3都有对应的整数个数4、3、3， 位数 个数 整数 幂指数 1 4 1，2，4，8 0，1，2，3 2 3 16，32，64 4，5，6 3 3 128，256，512 7，8，9 4 4 1024，2048，4096，8192 10，11，12，13 5 3 16384，32768，65536 14，15，16 6 3 … 17，18，19 7 4 … 20，21，22，23 8 3 … 24，25，26 9 3 … 27，28，29 … … … … 😱示例代码class Solution { public boolean reorderedPowerOf2(int N) { String num = N+&quot;&quot;; int len = num.length(); int n;//位数为len的整数（2的幂)的个数 int m;//位数为len的整数的幂指数 if(len%3 == 0){ m = (len/3)*10-3; n = 3; }else if(len%3 == 1){ m = (len/3)*10; n = 4; }else{ m = (len/3)*10+4; n = 3; } String[] pows = new String[n]; for(int i=0; i&lt;n; i++){ pows[i] = (int)Math.pow(2, m+i) + &quot;&quot;; char[] powlist = pows[i].toCharArray(); Arrays.sort(powlist); char[] numlist = num.toCharArray(); Arrays.sort(numlist); if(Arrays.equals(powlist, numlist)) return true; } return false; } }]]></content>
      <categories>
        <category>undefined</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统---进程通信]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88071041 对进程通信的理解进程是资源分配的基本单位，所以说某块资源分配给一个进程后，该资源只能是该进程独占，所以进程之间的通信就会比较麻烦，因为需要让不同的进程间能够看到一份公共的资源。所以交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。 实现进程通信的方式匿名管道（pipe） 管道是通过调用 pipe 函数创建的，是在内核中开辟出的一块缓冲区，fd[0] 用于读，fd[1] 用于写。 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 父进程关闭读端（fd[0]）,子进程关闭写端(fd[1])，则此时父进程可以往管道中进行写操作，子进程可以从管道中读，从而实现了通过管道的进程间通信 示例代码#include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;string.h&gt; int main(){ int fd[2]; int ret = pipe(fd); //开启匿名管道 if(ret&lt;0) perror(&quot;pipe\n&quot;); //开启失败 pid_t id = fork(); //创建子进程 if(id&lt;0) perror(&quot;fork\n&quot;); //创建失败 else if(id==0){ //子进程 close(fd[0]); //子进程关闭读端 int i=0; char *mesg = NULL; while(i&lt;100){ mesg = &quot;child&quot;; write(fd[1], mesg, strlen(mesg)+1); //向管道另一端写数据 sleep(1); i++; } } else{ //父进程 close(fd[1]); //父进程关闭写端 int i=0; char mesg[100]; while(i&lt;100){ memset(mesg, &apos;\0&apos;, sizeof(mesg)); read(fd[0], mesg, sizeof(mesg)); //从管道另一端读数据 printf(&quot;%s\n&quot;, mesg); j++; } } return 0; } 命名管道（FIFO） 命名管道，去除了管道只能在父子进程中使用的限制。 命名管道创建后就可以使用了，使用方法和匿名管道基本相同。只是使用命名管道时，必须先调用open()将其打开，因为命名管道是一个存在于硬盘的文件，而匿名管道是存在于内存中的特殊文件 调用open()打开命名管道的进程可能会被阻塞。但如果同时用读写方式（ O_RDWR）打开，则一定不会导致阻塞；如果以只读方式（ O_RDONLY）打开，则调用open()函数的进程将会被阻塞直到有写方打开管道；同样以写方式（ O_WRONLY）打开也会阻塞直到有读方式打开管道。 示例代码 😜Client.c文件，向管道写数据 #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/types.h&gt; #include&lt;string.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; #define _PATH_NAME_ &quot;/tmp/file.tmp&quot; #define _SIZE_ 100 int main(){ int ret=mkfifo(_PATH_NAME_,S_IFIFO|0666); //第一个参数是命名管道存储路径，第二个是命名管道的存取权限 if(ret==-1){ printf(&quot;make fifo error\n&quot;); return 1; } char buf[_SIZE_]; memset(buf,&apos;\0&apos;,sizeof(buf)); int fd=open(_PATH_NAME_,O_WRONLY); //打开命名管道，因为其是硬盘上的文件 while(1) { //scanf(&quot;%s&quot;,buf); fgets(buf,sizeof(buf)-1,stdin); int ret=write(fd,buf,strlen(buf)+1); if(ret&lt;0){ printf(&quot;write error&quot;); break; } } close(fd); return 0; } 😜Server.c文件，从管道读数据并输出 #include&lt;stdio.h&gt; #include&lt;sys/stat.h&gt; #include&lt;unistd.h&gt; #include&lt;fcntl.h&gt; #include&lt;sys/types.h&gt; #include&lt;string.h&gt; #define _PATH_NAME &quot;/tmp/file.tmp&quot; #define _SIZE_ 100 int main(){ int fd=open(_PATH_NAME,O_RDONLY); if(fd&lt;0){ printf(&quot;open file error&quot;); return 1; } char buf[_SIZE_]; memset(buf,&apos;\0&apos;,sizeof(buf)); while(1){ int ret=read(fd,buf,sizeof(buf)); if(ret&lt;0){ printf(&quot;read end or error\n&quot;); break; } printf(&quot;%s&quot;,buf); } close(fd); return 0; } 消息队列 消息队列可以独立于读写进程存在，从而避免了FIFO中为了同步管道的打开和关闭可能产生的困难； 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收. int msgget(key_t key, int msgflg); ssize_t msgrcv(int msqid, void msgp, size_t msgsz, long msgtyp, int msgflg);int msgsnd(int msqid, const void msgp, size_t msgsz, int msgflg);int msgctl ( int msgqid, int cmd, struct msqid_ds *buf ); 创建消息队列用系统调用msgget()来实现，这一步工作也被称为消息队列的初始化。 在进行通信时，消息队列的发送和接收分别用系统调用msgsnd()和msgrcv()来实现.。 在需要改变队列的使用权限及其它一些特性时，用msgclt()来实现。 示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10287879）](https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89) 😘msgreceive.c #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;sys/msg.h&gt; struct msg_st { long int msg_type; char text[BUFSIZ]; }; int main() { int running = 1; int msgid = -1; struct msg_st data; long int msgtype = 0; //注意1 //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if(msgid == -1) { fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno); exit(EXIT_FAILURE); } //从队列中获取消息，直到遇到end消息为止 while(running) { if(msgrcv(msgid, (void*)&amp;data, BUFSIZ, msgtype, 0) == -1) { fprintf(stderr, &quot;msgrcv failed with errno: %d\n&quot;, errno); exit(EXIT_FAILURE); } printf(&quot;You wrote: %s\n&quot;,data.text); //遇到end结束 if(strncmp(data.text, &quot;end&quot;, 3) == 0) running = 0; } //删除消息队列 if(msgctl(msgid, IPC_RMID, 0) == -1) { fprintf(stderr, &quot;msgctl(IPC_RMID) failed\n&quot;); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } 😘msgsend.c文件 #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/msg.h&gt; #include &lt;errno.h&gt; #define MAX_TEXT 512 struct msg_st { long int msg_type; char text[MAX_TEXT]; }; int main() { int running = 1; struct msg_st data; char buffer[BUFSIZ]; int msgid = -1; //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if(msgid == -1) { fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno); exit(EXIT_FAILURE); } //向消息队列中写消息，直到写入end while(running) { //输入数据 printf(&quot;Enter some text: &quot;); fgets(buffer, BUFSIZ, stdin); data.msg_type = 1; //注意2 strcpy(data.text, buffer); //向队列发送数据 if(msgsnd(msgid, (void*)&amp;data, MAX_TEXT, 0) == -1) { fprintf(stderr, &quot;msgsnd failed\n&quot;); exit(EXIT_FAILURE); } //输入end结束输入 if(strncmp(buffer, &quot;end&quot;, 3) == 0) running = 0; sleep(1); } exit(EXIT_SUCCESS); } 信号量 它是一个计数器，用于为多个进程提供对共享数据对象的访问 semget()用于创建一个新信号量或返回一个已有信号量（根据IPCkey） semop()用于改变信号量的值，用于对信号量增减操作，即PV操作 semclt()用于直接控制信号量的值，用于对信号量初始化操作 int semget(key_t key, int num_sems, int sem_flags); int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);int semctl(int sem_id, int sem_num, int command, …); 示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10243617）](https://blog.csdn.net/ljianhui/article/details/10243617%EF%BC%89) #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/sem.h&gt; union semun { int val; struct semid_ds *buf; unsigned short *arry; }; static int sem_id = 0; static int set_semvalue(); static void del_semvalue(); static int semaphore_p(); static int semaphore_v(); int main(int argc, char *argv[]) { char message = &apos;X&apos;; int i = 0; //创建信号量 sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT); if(argc &gt; 1) { //程序第一次被调用，初始化信号量 if(!set_semvalue()) { fprintf(stderr, &quot;Failed to initialize semaphore\n&quot;); exit(EXIT_FAILURE); } //设置要输出到屏幕中的信息，即其参数的第一个字符 message = argv[1][0]; sleep(2); } for(i = 0; i &lt; 10; ++i) { //进入临界区 if(!semaphore_p()) exit(EXIT_FAILURE); //向屏幕中输出数据 printf(&quot;%c&quot;, message); //清理缓冲区，然后休眠随机时间 fflush(stdout); sleep(rand() % 3); //离开临界区前再一次向屏幕输出数据 printf(&quot;%c&quot;, message); fflush(stdout); //离开临界区，休眠随机时间后继续循环 if(!semaphore_v()) exit(EXIT_FAILURE); sleep(rand() % 2); } sleep(10); printf(&quot;\n%d - finished\n&quot;, getpid()); if(argc &gt; 1) { //如果程序是第一次被调用，则在退出前删除信号量 sleep(3); del_semvalue(); } exit(EXIT_SUCCESS); } static int set_semvalue() { //用于初始化信号量，在使用信号量前必须这样做 union semun sem_union; sem_union.val = 1; if(semctl(sem_id, 0, SETVAL, sem_union) == -1) return 0; return 1; } static void del_semvalue() { //删除信号量 union semun sem_union; if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1) fprintf(stderr, &quot;Failed to delete semaphore\n&quot;); } static int semaphore_p() { //对信号量做减1操作，即等待P（sv） struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1;//P() sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) { fprintf(stderr, &quot;semaphore_p failed\n&quot;); return 0; } return 1; } static int semaphore_v() { //这是一个释放操作，它使信号量变为可用，即发送信号V（sv） struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1;//V() sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) { fprintf(stderr, &quot;semaphore_v failed\n&quot;); return 0; } return 1; } 共享内存 允许多个进程共享一个给定的存储区 因为数据不需要进程之间的复制，而是直接访问内存，所以这是最快的一种IPC。 由于共享内存并不提供同步操作，所以在使用共享内存这种通信方式时，需要借助其他手段进行进程间的同步工作，可以使用信号量等 shmget()用来创建共享内存，返回一个与key相关的共享内存标识符 shmat()用来启动对共享内存的访问，并把共享内存连接到当前进程的地址空间（第一次创建完共享内存时，还不能被任何进程访问），返回指向共享内存的指针 shmclt()用来控制共享内存，与信号量的semclt()函数一样 shmdt()用于将共享内存从当前进程中分离，注意分离不等于删除共享内存 int shmget(key_t key, size_t size, int shmflg); void shmat(int shm_id, const void shm_addr, int shmflg);int shmctl(int shm_id, int command, struct shmid_ds buf);int shmdt(const void shmaddr); 示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10253345）](https://blog.csdn.net/ljianhui/article/details/10253345%EF%BC%89) 😀shmdata.h文件，定义共享内存结构 //shmdata.h文件，定义共享内存结构 #ifndef _SHMDATA_H_HEADER #define _SHMDATA_H_HEADER #define TEXT_SZ 2048 struct shared_use_st { int written;//作为一个标志，非0：表示可读，0表示可写 char text[TEXT_SZ];//记录写入和读取的文本 }; #endif 😀shmread.c文件，创建共享内存，并读取其中信息 #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/shm.h&gt; #include &quot;shmdata.h&quot; int main() { int running = 1;//程序是否继续运行的标志 void *shm = NULL;//分配的共享内存的原始首地址 struct shared_use_st *shared;//指向shm int shmid;//共享内存标识符 //创建共享内存 shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT); if(shmid == -1) { fprintf(stderr, &quot;shmget failed\n&quot;); exit(EXIT_FAILURE); } //将共享内存连接到当前进程的地址空间 shm = shmat(shmid, 0, 0); if(shm == (void*)-1) { fprintf(stderr, &quot;shmat failed\n&quot;); exit(EXIT_FAILURE); } printf(&quot;\nMemory attached at %X\n&quot;, (int)shm); //设置共享内存 shared = (struct shared_use_st*)shm; shared-&gt;written = 0; while(running)//读取共享内存中的数据 { //没有进程向共享内存定数据有数据可读取 if(shared-&gt;written != 0) { printf(&quot;You wrote: %s&quot;, shared-&gt;text); sleep(rand() % 3); //读取完数据，设置written使共享内存段可写 shared-&gt;written = 0; //输入了end，退出循环（程序） if(strncmp(shared-&gt;text, &quot;end&quot;, 3) == 0) running = 0; } else//有其他进程在写数据，不能读取数据 sleep(1); } //把共享内存从当前进程中分离 if(shmdt(shm) == -1) { fprintf(stderr, &quot;shmdt failed\n&quot;); exit(EXIT_FAILURE); } //删除共享内存 if(shmctl(shmid, IPC_RMID, 0) == -1) { fprintf(stderr, &quot;shmctl(IPC_RMID) failed\n&quot;); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } 😀shmwrite.c文件，向共享内存写入数据 #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/shm.h&gt; #include &quot;shmdata.h&quot; int main() { int running = 1; void *shm = NULL; struct shared_use_st *shared = NULL; char buffer[BUFSIZ + 1];//用于保存输入的文本 int shmid; //创建共享内存 shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT); if(shmid == -1) { fprintf(stderr, &quot;shmget failed\n&quot;); exit(EXIT_FAILURE); } //将共享内存连接到当前进程的地址空间 shm = shmat(shmid, (void*)0, 0); if(shm == (void*)-1) { fprintf(stderr, &quot;shmat failed\n&quot;); exit(EXIT_FAILURE); } printf(&quot;Memory attached at %X\n&quot;, (int)shm); //设置共享内存 shared = (struct shared_use_st*)shm; while(running)//向共享内存中写数据 { //数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本 while(shared-&gt;written == 1) { sleep(1); printf(&quot;Waiting...\n&quot;); } //向共享内存中写入数据 printf(&quot;Enter some text: &quot;); fgets(buffer, BUFSIZ, stdin); strncpy(shared-&gt;text, buffer, TEXT_SZ); //写完数据，设置written使共享内存段可读 shared-&gt;written = 1; //输入了end，退出循环（程序） if(strncmp(buffer, &quot;end&quot;, 3) == 0) running = 0; } //把共享内存从当前进程中分离 if(shmdt(shm) == -1) { fprintf(stderr, &quot;shmdt failed\n&quot;); exit(EXIT_FAILURE); } sleep(2); exit(EXIT_SUCCESS); } 套接字 与其它通信机制不同的是，它可用于不同机器间的进程通信 因特网提供了两种通信机制：流（stream）和数据报（datagram），因而套接字的类型也就分为流套接字和数据报套接字。 一种套接字域是AF_INET，它指的是Internet网络，结构中有IP地址和端口 另一种域AF_UNIX，表示UNIX文件系统，它就是文件输入/输出，结构中有文件路径名 socket()用于创建一个套接字，三个参数分别为套接字域、通信机制、协议类型 bind()函数把通过socket调用创建的套接字命名，从而让它可以被其他进程使用。对于AF_UNIX，调用该函数后套接字就会关联到一个文件系统路径名，对于AF_INET，则会关联到一个IP端口号 listen()用来创建一个队列来保存未处理的请求 accept()用来等待客户建立对该套接字的连接，阻塞直到有客户建立连接 connect()用来让客户程序通过在一个未命名套接字和服务器监听套接字之间建立连接的方法来连接到服务器 close()用来终止服务器和客户上的套接字连接，我们应该总是在连接的两端（服务器和客户）关闭套接字 int socket(int domain, int type, int protocol); int bind( int socket, const struct sockaddr address, size_t address_len);int listen(int socket, int backlog);int accept(int socket, struct sockaddr address, size_t address_len);int connect(int socket, const struct sockaddr address, size_t address_len); 示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10477427）](https://blog.csdn.net/ljianhui/article/details/10477427%EF%BC%89) 😡sockserver.c文件，服务器端 #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int server_sockfd = -1; int client_sockfd = -1; int client_len = 0; struct sockaddr_in server_addr; struct sockaddr_in client_addr; //创建流套接字 server_sockfd = socket(AF_INET, SOCK_STREAM, 0); //设置服务器接收的连接地址和监听的端口 server_addr.sin_family = AF_INET;//指定网络套接字 server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//接受所有IP地址的连接 server_addr.sin_port = htons(9736);//绑定到9736端口 //绑定（命名）套接字 bind(server_sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)); //创建套接字队列，监听套接字 listen(server_sockfd, 5); //忽略子进程停止或退出信号 signal(SIGCHLD, SIG_IGN); while(1) { char ch = &apos;\0&apos;; client_len = sizeof(client_addr); printf(&quot;Server waiting\n&quot;); //接受连接，创建新的套接字 client_sockfd = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len); if(fork() == 0) { //子进程中，读取客户端发过来的信息，处理信息，再发送给客户端 read(client_sockfd, &amp;ch, 1); sleep(5); ch++; write(client_sockfd, &amp;ch, 1); close(client_sockfd); exit(0); } else { //父进程中，关闭套接字 close(client_sockfd); } } } 😡sockclient.c文件，客户端 #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int sockfd = -1; int len = 0; struct sockaddr_in address; int result; char ch = &apos;A&apos;; //创建流套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); //设置要连接的服务器的信息 address.sin_family = AF_INET;//使用网络套接字 address.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//服务器地址 address.sin_port = htons(9736);//服务器所监听的端口 len = sizeof(address); //连接到服务器 result = connect(sockfd, (struct sockaddr*)&amp;address, len); if(result == -1) { perror(&quot;ops:client\n&quot;); exit(1); } //发送请求给服务器 write(sockfd, &amp;ch, 1); //从服务器获取数据 read(sockfd, &amp;ch, 1); printf(&quot;char form server = %c\n&quot;, ch); close(sockfd); exit(0); } 关于System V IPCSystem V IPC指的是AT&amp;T在System V.2发行版中引入的三种进程间通信工具： 信号量，用来管理对共享资源的访问 共享内存，用来高效地实现进程间的数据共享 共享内存，用来高效地实现进程间的数据共享 消息队列，用来实现进程间数据的传递。 我们把这三种工具统称为System VIPC的对象，每个对象都具有一个唯一的IPC标识符(identifier)。要保证不同的进程能够获取同一个IPC对象，必须提供一个IPC关键字(IPCkey)，内核负责把IPC关键字转换成IPC标识符。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统---进程同步经典问题]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[生产者-消费者问题问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty =0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 #define N 100 typedef int semaphore; semaphore mutex = 1; semaphore empty = N; semaphore full = 0; void producer(){ while(TRUE){ int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); } } void consumer(){ while(TRUE){ down(&amp;full); down(&amp;mutex); int item = remove_item(); consume_item(item); up(&amp;mutex); up(&amp;empty); } } 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex用于对读写的数据加锁。 读者优先策略：当读者进行读取时，如果后面一直有读者进入，那么写者就会阻塞，直到所有读者完成之后，写者才可以进入。 typedef int semaphore; semaphore count_mutex = 1; semaphore data_mutex = 1; int count = 0; void writer(){ while(TRUE){ down(&amp;data_mutex); write(); up(&amp;data_mutex); } } void reader(){ while(TRUE){ down(&amp;count_mutex); if(count==0) down(&amp;data_mutex);//如果是第一个读者，阻塞写者 count++; up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count==0) up(&amp;data_mutex);//最后一个读者出来，释放写者 up(&amp;count_mutex); } } 写者优先：置一个WriterMutex信号量来实现优先读。我们可以看到，当有写者进入时，通过P(WriterMutex)阻塞了读者 typedef int semaphore; semaphore count_mutex = 1; semaphore data_mutex = 1; semaphore write_mutex = 1;//实现写者优先 int count = 0; void writer(){ while(TRUE){ down(&amp;write_mutex); down(&amp;data_mutex); write(); up(&amp;data_mutex); up(&amp;write_mutex); } } void reader(){ while(TRUE){ down(&amp;write_mutex);//无写者进入时 down(&amp;count_mutex); if(count==0) down(&amp;data_mutex);//如果是第一个读者，阻塞写者 count++; up(&amp;write_mutex);//恢复对共享资源的访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count==0) up(&amp;data_mutex);//最后一个读者出来，释放写者 up(&amp;count_mutex); } } 哲学家进餐问题五个哲学家（A~E）围着一张圆桌就餐，他们每个人面前都有一盘通心粉。由于通心粉很滑，所以需要两只筷子才能夹住，但每两个盘子之间只放着一只筷子，如下图。哲学家只有两个动作：要么就餐，要么思考。而且他们之间从不交谈。当一个哲学家饿了的时候，就拿起盘子左右两边的筷子开始就餐（不能同时拿起两只筷子）。就餐完以后，就把筷子放回盘子左右，继续思考。由于他们之间互不交谈，所以很容易出现“死锁”：假如每个人都拿着左边的筷子，则所有人都在等右边的筷子，谁都吃不了。为了防止死锁的发生，可以设置两个条件： 必须同时拿起左右两根筷子；只有在两个邻居都没有进餐的情况下才允许进餐。 #define N 5 #define LEFT (i + N - 1) % N // 左邻居 #define RIGHT (i + 1) % N // 右邻居 #define THINKING 0 #define HUNGRY 1 #define EATING 2 typedef int semaphore; int state[N]; // 跟踪每个哲学家的状态 semaphore mutex = 1; // 临界区的互斥 semaphore s[N]; // 每个哲学家一个信号量 void philosopher(int i) { while(TRUE) { think(); take_two(i); eat(); put_two(i); } } void take_two(int i) { down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]); } void put_two(i) { down(&amp;mutex); state[i] = THINKING; test(LEFT); test(RIGHT); up(&amp;mutex); } void test(i) { // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) { state[i] = EATING; up(&amp;s[i]); } } 其他解决方案（ https://blog.csdn.net/Sunflowerfiona/article/details/52756819）]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM---对Spring的理解]]></title>
    <url>%2F2019%2F03%2F01%2FSSM---%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88057759 概述Spring是一个开源框架，为简化企业级应用开发而生。Spring可以是使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和AOP容器框架。 主要核心 控制反转（IOC），传统的Java开发模式中，当需要一个对象时，我们会自己使用new或者getInstance等直接或者间接调用构造方法创建一个对象，而在Spring开发模式中，spring容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring提供的对象就可以了，这是控制反转的思想。控制反转主要的实现方式有两种：依赖查找、依赖注入。 依赖注入（DI），spring使用JavaBean对象的set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。 面向切面编程（AOP），在面向对象编程(oop)思想中，我们将事物纵向抽成一个个对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事务管理、记录日志等公用操作处理的过程就是面向切面编程的思想。AOP底层是动态代理，如果是接口采用JDK动态代理，如果是类采用CGLIB方式实现动态代理。 结构spring由20多个模块组成，可以分为数据访问/集成、Web、面向切面编程、应用服务器设备管理、消息发送、核心容器和测试 Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换和常用的工具类； Beans模块：提供框架的基础部分，包括控制反转和依赖注入。其中BeanFactory是容器核心。 Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化等；核心接口是ApplicationContext。]]></content>
      <categories>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>IOC</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统---概述]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88043694 基本特征 并发一段时间内运行多个程序为并发；同一时刻运行多条指令为并行；并行需要硬件支持，比如多核处理器、分布式系统操作系统引入进程和线程，使得程序能够并发运行 共享指系统资源可以被多个并发进程使用两种共享方式：互斥共享、同时共享 虚拟两种虚拟技术：时分复用技术，多个进程在同一个处理器上并发执行空分复用技术，虚拟内存 异步指一个进程不是一次执行完毕，而是走走停停 基本功能 进程管理进程控制、进程同步、进程调度、死锁处理、处理机调度等 内存管理内存分配、地址映射、内存保护与共享、虚拟内存等 文件管理文件存储空间管理、目录管理、文件读写管理与保护等 设备管理帮助用户完成IO请求，包括缓冲管理、设备分配、设备处理、虚拟设备等 系统调用如果一个进程在用户态需要使用内核态的功能，需要通过系统调用陷入内核态，有操作系统代为完成。 中断 外中断，如IO完成请求、时钟中断、控制台中断等 异常，由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等 陷入，进程使用系统调用由用户态陷入内核态 参考： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/计算机操作系统.md#一概述]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO---字符操作]]></title>
    <url>%2F2019%2F02%2F28%2FJavaIO---%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[编码与解码编码就是把字符转换为字节，而解码是把字节重新组合成字符。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。 Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。 String 的编码方式String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。 String str1 = &quot;中文&quot;; byte[] bytes = str1.getBytes(&quot;UTF-8&quot;); String str2 = new String(bytes, &quot;UTF-8&quot;); System.out.println(str2); 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为UTF-8。 Reader 与 Writer不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从字节流解码成字符流；OutputStreamWriter 实现字符流编码成为字节流。 实现逐行输出文本文件的内容 public static void readFileContent(String filePath) throws IOException { FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close(); } 参考： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java IO.md]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>字符</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88040936 定义在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象 组成部分 抽象构件(Component)它是具体构件和抽象装饰类的共同祖先，声明了具体构件需要实现的业务方法 具体构件(ConcreteComponent)它是抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的业务方法 抽象装饰类(Decorator)它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 具体装饰类(ConcreteDecorator)它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为 代码实现假设有两个程序员他们原来只会各自的技能，现在需要让Android程序猿具备设计模式技能，那就给他装饰一下。说明一下： 抽象构件：掌握技能的程序员 具体构件：一个掌握写Android代码技能的程序员，一个掌握写php代码技能的程序员 抽象装饰类： 具体装饰类： 在业务方法中添加设计模式的技能 //Component（抽象构件） interface ProgramMonkey { void skills(); } //ConcreteComponent（具体构件） class AndroidProgramMonkey implements ProgramMonkey { @Override public void skills() { System.out.println(&quot;会写Android代码！&quot;); } } //ConcreteComponent（具体构件） class PHPProgramMonkey implements ProgramMonkey { @Override public void skills() { System.out.println(&quot;会写PHP代码！&quot;); } } //Decorator（抽象装饰类） class ProgramMonkeyDecorator implements ProgramMonkey { protected ProgramMonkey mProgramMonkey; public ProgramMonkeyDecorator(ProgramMonkey mProgramMonkey) { this.mProgramMonkey = mProgramMonkey; } public void skills() { mProgramMonkey.skills(); } } //ConcreteDecorator（具体装饰类） class PatternDecorator extends ProgramMonkeyDecorator { public PatternDecorator(ProgramMonkey mProgramMonkey) { super(mProgramMonkey); } @Override public void skills() { super.skills(); System.out.println(&quot;会设计模式！&quot;); } } public class Main { public static void main(String[] args) { //有一个Android程序猿只会写Android代码 ProgramMonkey programMonkey = new AndroidProgramMonkey(); programMonkey.skills(); //装饰一下他，装逼的技能，他竟然除了写Android还懂设计模式 programMonkey = new PatternDecorator(programMonkey); programMonkey.skills(); programMonkey = new PHPProgramMonkey(); programMonkey.skills(); } } Java I/O中的装饰模式 InputStream是抽象构件 FileInputStream是InputStream的子类，属于其中一个具体构件，提供字节流输入的操作；PipedInputStream、ByteArrayInputStream也是具体构件 FilterInputStream是InputStream的子类，属于抽象装饰类，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 DataInputStream、BufferedInputStream、PushBackInputStream都是具体装饰者]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F02%2F28%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88036891 基本数据类型，byte/8、short/16、char/16、int/32、float/32、long/62、double/16、boolean（只有两个值，可以用1bit来表示，但是具体大小没有明确规定，JVM在编译时期将boolean类型的数据转成int类型） 包装数据类型，基本数据类型都有对应的包装数据类型，两者之间的转换过程为装箱拆箱，装箱：基本数据类型–&gt;包装数据类型； 缓存池：new Integer(123)每次都会新建一个对象，而使用Integer.valueOf(123)创建实例时，会先判断该值是否在缓存池中，如果在直接返回缓存池中的内容，因此多次调用会取得同一个对象的引用；在自动装箱过程中，编译器会自动调用valueOf()，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象；每个基本数据类型都有对应的缓存池，使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象，但是有大小限制； String Pool(字符串常量池)：在String Pool中添加字符串有两种方法，一种是字符串字面量”abc”在编译时期就确定，另一种是通过调用intern()在程序运行时将字符串对象添加到String Pool并返回该字符串的引用。在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误 switch：从Java7开始，可以在switch条件判断语句中使用String对象；switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适 抽象类与接口：抽象类可以有构造方法而接口不行；接口的成员（字段和方法）默认都是public而抽象类可以是任意访问权限；接口的字段默认都是static和final修饰的而抽象类可以有普通成员变量 重写的两个限制：子类方法访问权限必须大于等于父类的；子类方法返回值类型必须是父类的返回值类型或子类型 重载：返回值类型、方法名相同；参数类型、个数、顺序不同 equal(Object o)的实现：1.判断是否为同一对象的引用，如果是直接返回true；2.判断是否为同一类型（getClass())，如果不是直接返回false；3.将参数Object对象进行转型；4.判断每个关键域是否相等。 hashCode()：hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等； clone()：1.Object的一个protected方法，如果一个类不显式重写该方法，那该类就不能调用clone()方法；而且该类要实现Cloneable()标记接口，要不然调用时会抛出CloneNotSupportedException。2.使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 深拷贝与浅拷贝：区别在于浅拷贝拷贝时碰到对象只是复制了对象的引用。 异常： Java与C++： 参考： CS-Note/Java基础]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发---互斥同步]]></title>
    <url>%2F2019%2F02%2F28%2FJava%E5%B9%B6%E5%8F%91---%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88019011 Java提供两种锁机制控制多线程对互斥资源的互斥访问，一种是JVM实现的synchronized，一种是JDK实现的RentranLock. synchronized 同步一个代码块；只作用于一个对象，如果调用两个不同的对象上的同步代码块，不会进行同步； public class SynchronizedExample { public void func1() { synchronized (this) { for (int i = 0; i &lt; 10; i++) { System.out.print(i + &quot; &quot;); } } } } 同步一个方法；和同步代码块一样，只作用于相同对象； public synchronized void func () { // ... } 同步一个类；作用于整个类，即两个线程调用同一类的不同对象上的同步语句，也会进行同步； public void func() { synchronized (SynchronizedExample.class) { // ... } } 同步一个静态方法；作用于整个类 public synchronized static void fun() { // ... } RentranLockRentranLock是java.util.concurrent(J.U.C)包中的锁； Java并发之ReentrantLock详解 两者的异同 锁的实现；synchronized是JVM实现，RentranLock是JDK实现 性能：由于新版本Java对synchronized进行了很多 优化 ，例如自旋锁等，两者性能大致相同 等待可中断；当一个线程长期不释放锁时，其他在等待的线程可以放弃等待去处理其他事情；RentranLock可中断，而synchronized不行 公平锁；即当多个线程在等待同一锁时，必须按照申请锁的时间顺序获得锁；synchronized中的锁是非公平的；RentranLock默认的锁也是不公平的，但是也可以是公平的 绑定条件；一个RentranLock可以绑定多个Condition对象。 在一个锁中使用多个条件（Condition)]]></content>
      <categories>
        <category>undefined</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---数组中只出现一次地数字]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%89%91%E6%8C%87offer---%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E5%9C%B0%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/88016727 题目描述一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字 解题思路 两个相同的数异或的结果为0；利用这点将数组的所有元素异或得到的结果即是不存在重复的两个元素异或的结果； diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来 假设两个元素在位级表示上不同的那一位是第N位，可以将原数组分为两个子数组，则两个子数组中各包含一个不同的元素以及若干对第N位一样的相同元素，分别对子数组所有元素异或得到的结果就是那位元素； num&amp;diff可将数组分成两个子数组。 public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) { int diff = 0; for(int num : array){ diff ^= num; } diff &amp;= -diff; for(int num : array){ if((num&amp;diff) == 0){ num1[0] ^= num; }else{ num2[0] ^= num; } } }]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---求1+2+3+...+n]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%89%91%E6%8C%87offer---%E6%B1%821%2B2%2B3%2B...%2Bn%2F</url>
    <content type="text"><![CDATA[题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解法使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。 条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp;的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。 本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是(sum += Sum_Solution(n - 1)) &gt; 0。 public int Sum_Solution(int n) { int sum = n; boolean b = (n&gt;0) &amp;&amp; (sum += Sum_Solution(n-1))&gt;0; return sum; }]]></content>
      <categories>
        <category>剑指offer</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>短路原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象思想]]></title>
    <url>%2F2019%2F02%2F27%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[三大特性 封装 继承 多态编译时多态：主要指方法的重载运行时多态：三个条件（继承，重写，向上转型） 类图 泛化关系：描述继承关系，extend 实现关系：实现一个接口，implement 聚合关系：整体和部分不是强依赖，整体不存在，部分可以存在 组合关系：整体和部分强依赖，整体消失，部分跟着消失 关联关系：表示不同类对象之间的关联，这是一种静态关系，与运行过程无关，如1对1，1对多… 依赖关系：在运行过程中起作用，有三种形式：A 类是 B 类方法的局部变量；A 类是 B 类方法当中的一个参数；A 类向 B 类发送消息，从而影响 B 类发生变化 设计原则（S.O.L.I.D) S：单一责任原则 修改一个类的原因只有一个 让一个类只负责一件事，当这个类需要做过多的事情，应该分解这个类；如果一个类承担职责过多，就等于把这些职责耦合在一起，一个职责的变化可能削弱该类完成其他职责的能力。 O：开放封闭原则 类对扩展开放，对修改关闭 添加新功能时不修改代码；装饰者模式，动态地将责任附加到对象上而不用修改代码。 L：里氏替换原则 子类必须可以替换所有父类对象 I：接口分离原则 不应该强迫客户依赖于它们不用的方法。 因此使用多个专门的接口比使用单一的总接口要好 D：依赖倒置原则 高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节依赖于抽象 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。 依赖于抽象意味着： 任何变量都不应该持有一个指向具体类的指针或者引用； 任何类都不应该从具体类派生； 任何方法都不应该覆写它的任何基类中的已经实现的方法。 其他常见原则 迪米特法则迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。 合成复用原则尽量使用对象组合，而不是通过继承来达到复用的目的。 共同封闭原则一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。 稳定抽象原则最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。 稳定依赖原则包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。 参考： https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/面向对象思想.md]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---第一个只出现一次的字符]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87980784 使用 HashMap 对出现次数进行统计 public int FirstNotRepeatingChar(String str) { if(str==null || str.length()==0) return -1; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;str.length(); i++){ char c = str.charAt(i); if(map.containsKey(c)){ map.put(c, map.get(c)+1); }else{ map.put(c, 1); } } for(int i=0; i&lt;str.length(); i++){ if(map.get(str.charAt(i)) == 1) return i; } return -1; } 考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap public int FirstNotRepeatingChar(String str) { if(str==null || str.length()==0) return -1; int[] cnt = new int[256]; for(int i=0; i&lt;str.length(); i++){ cnt[str.charAt(i)]++; } for(int i=0; i&lt;str.length(); i++){ if(cnt[str.charAt(i)] == 1) return i; } return -1; } 以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息 public int FirstNotRepeatingChar(String str) { if(str==null || str.length()==0) return -1; BitSet bs1 = new BitSet(256); BitSet bs2 = new BitSet(256); for(char c : str.toCharArray()){ // 00--&gt;01 if(!bs1.get(c) &amp;&amp; !bs2.get(c)) bs1.set(c); // 01--&gt;11 else if(bs1.get(c) &amp;&amp; !bs2.get(c)) bs2.set(c); } for(int i=0; i&lt;str.length(); i++){ char c = str.charAt(i); // 01 if(bs1.get(c) &amp;&amp; !bs2.get(c)) return i; } return -1; }]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---丑数]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[来源牛客网： https://www.nowcoder.com/profile/835689/codeBookDetail?submissionId=1522621 通俗易懂的解释：首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x 3 ^ y 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：（1）丑数数组： 1乘以2的队列：2乘以3的队列：3乘以5的队列：5选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；（2）丑数数组：1,2乘以2的队列：4乘以3的队列：3，6乘以5的队列：5，10选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；（3）丑数数组：1,2,3乘以2的队列：4,6乘以3的队列：6,9乘以5的队列：5,10,15选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；（4）丑数数组：1,2,3,4乘以2的队列：6，8乘以3的队列：6,9,12乘以5的队列：5,10,15,20选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；（5）丑数数组：1,2,3,4,5乘以2的队列：6,8,10，乘以3的队列：6,9,12,15乘以5的队列：10,15,20,25选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；……………………疑问：1.为什么分三个队列？丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；2.为什么比较三个队列头部最小的数放入丑数数组？因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。实现思路：我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；（1）1|2|3|5目前指针指向0,0,0，队列头arr[0] 2 = 2, arr[0] 3 = 3, arr[0] 5 = 5（2）1 22 |4|3 6|5 10目前指针指向1,0,0，队列头arr[1] 2 = 4, arr[0] 3 = 3, arr[0] 5 = 5（3）1 2 32| 4 63 |6 9|5 10 15目前指针指向1,1,0，队列头arr[1] 2 = 4, arr[1] 3 = 6, arr[0] * 5 = 5……………… public int GetUglyNumber_Solution(int index) { if(index&lt;=6) return index; int i2=0,i3=0,i5=0; int[] dp = new int[index]; dp[0] = 1; for(int i=1; i&lt;index; i++){ int next2 = dp[i2]*2; int next3 = dp[i3]*3; int next5 = dp[i5]*5; dp[i] = Math.min(next2, Math.min(next3, next5)); if(next2 == dp[i]) i2++; if(next3 == dp[i]) i3++; if(next5 == dp[i]) i5++; } return dp[index-1]; }]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---整数中1出现的次数]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[来源：牛客网 https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6 主要思路：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析 根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i 当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a/10+1)*100个点的百位为1 当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1 当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30 综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点， 之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1) ；还有当百位为1(a%10==1)，需要增加局部点b+1. public int NumberOf1Between1AndN_Solution(int n) { int cnt = 0; for(int i=1; i&lt;=n; i*=10){ int a = n/i; int b = n%i; cnt += (a+8)/10*i + (a%10==1 ? b+1 : 0); } return cnt; }]]></content>
      <categories>
        <category>undefined</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---最小的K个数]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87974471 解法一：最小堆 复杂度：O(NlogK) + O(K) 特别适合处理海量数据 应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的堆顶大小大于该元素，那么需要将大顶堆的堆顶元素与该元素交换，重新调整最大堆。 public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) { ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(k==0 || k&gt;input.length) return ret; int[] ks = new int[k]; for(int i=0; i&lt;k; i++){ ks[i] = input[i]; } buildMaxHeap(ks); for(int i=k; i&lt;input.length; i++){ if(input[i] &lt; ks[0]){ ks[0] = input[i]; maxHeap(ks, ks.length, 0); } } for(int val : ks) ret.add(val); return ret; } private void buildMaxHeap(int[] array){ if(array==null || array.length&lt;=1) return; int half = (array.length-1)/2; for(int i=half; i&gt;=0; i--){ maxHeap(array, array.length, i); } } private void maxHeap(int[] array, int heapSize, int index){ int left = index*2+1; int right = index*2+2; int largest = index; if(left&lt;heapSize &amp;&amp; array[left]&gt;array[largest]) largest = left; if(right&lt;heapSize &amp;&amp; array[right]&gt;array[largest]) largest = right; if(largest != index){ int temp = array[largest]; array[largest] = array[index]; array[index] = temp; maxHeap(array, array.length, largest); } } 这里可以使用Java的优先队列PriorityQueue来维护最大堆，代码如下： public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) { if(k==0 || k&gt;input.length) return new ArrayList&lt;&gt;(); PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); for(int val : input){ maxHeap.add(val); if(maxHeap.size() &gt; k){ maxHeap.poll(); } } return new ArrayList&lt;&gt;(maxHeap); } 解法二：快速选择算法 复杂度：O(N) + O(1) 只有当允许修改数组元素时才可以使用 快速排序的 partition() 方法，会返回一个整数 j 使得 a[l…j-1] 小于等于 a[j]，且 a[j+1…h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。 public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) { if(k==0 || k&gt;input.length) return new ArrayList&lt;&gt;(); int start = 0; int end = input.length-1; int index = partition(input, start, end); while(index!=(k-1)){ if(index&gt;k-1){ end = index-1; index = partition(input, start, end); }else{ start = index+1; index = partition(input, start, end); } } ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for(int i=0; i&lt;k; i++){ ret.add(input[i]); } return ret; } private int partition(int[] array, int begin, int end){ int low = begin; int high = end; int pivot = array[low]; while(low&lt;high){ while(low&lt;high &amp;&amp; array[high]&gt;=pivot) high--; array[low] = array[high]; while(low&lt;high &amp;&amp; array[low]&lt;=pivot) low++; array[high] = array[low]; } array[low] = pivot; return low; }]]></content>
      <categories>
        <category>剑指offer</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小堆</tag>
        <tag>快速选择</tag>
        <tag>topK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87967818 一般解法 ：1.先对数组进行排序，然后取数组中间位置元素，再对数据扫描一趟来判断此元素是否为多数元素。时间复杂度O(nlog(n))，空间复杂度O(1)。2.使用一个hash表，对数组进行一趟扫描统计每个元素出现的次数，即可得到多数元素。时间复杂度O(n)，空间复杂度O(n) 多数投票问题解法：可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。 使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt–。如果前面查找了 i 个元素，且 cnt ==0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。 public int MoreThanHalfNum_Solution(int [] array) { int majority=array[0]; for(int i=1,cnt=1; i&lt;array.length; i++){ cnt = (majority==array[i]) ? cnt+1 : cnt-1; if(cnt==0){ majority = array[i]; cnt = 1; } } int cnt = 0; for(int val : array){ if(val == majority){ cnt++; } } return (cnt&gt;array.length/2) ? majority : 0; }]]></content>
      <categories>
        <category>剑指offer</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多数投票问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据量处理]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？方案1：可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。s 遍历文件a，对每个url求取 ，然后根据所取得的值将url分别存储到1000个小文件（记为 ）中。这样每个小文件的大约为300M。s 遍历文件b，采取和a相同的方式将url分别存储到1000各小文件（记为 ）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。s 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloomfilter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloomfilter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。方案1：s 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。s 找一台内存在2G左右的机器，依次对 用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为 ）。s 对 这10个文件进行归并排序（内排序与外排序相结合）。方案2：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。方案3：与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。方案1：顺序读文件中，对于每个词x，取 ，然后按照该值存到5000个小文件（记为 ）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。 海量日志数据，提取出某日访问百度次数最多的那个IP。方案1：首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有 个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存 内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。 海量数据分布在100台电脑中，想个办法高校统计出这批数据的TOP10。方案1：s 在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大。s 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。 怎么在海量数据中找出重复次数最多的一个？方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成。 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？方案1：这题用trie树比较合适，hash_map也应该能行。 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n _ le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n _ lg10)。所以总的时间复杂度，是O(n _ le)与O(n _ lg10)中较大的哪一个。 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。 100w个数中找出最大的100个数。方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w _ lg100)。方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w_ 100)。方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。(1) 请描述你解决这个问题的思路；(2) 请给出主要的处理流程，算法，以及算法的复杂度。方案1：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到 个数中的中数？方案1：先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有 个）。我们把0到 的整数划分为N个范围段，每个段包含个整数。比如，第一个段位0到 ，第二段为 到 ，…，第N个段为 到 。然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于 ，而在第k-1个机器上的累加数小于 ，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第 位。然后我们对第k个机器的数排序，并找出第个数，即为所求的中位数。复杂度是 的。方案2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第n个便是所求。复杂度是n(i)的。 最大间隙问题给定n个实数 ，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。方案1：最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：s 找到n个数据中最大和最小数据max和min。s 用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为 ，且桶的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为： 。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为），且认为将min放入第一个桶，将max放入第n-1个桶。s 将n个数放入n-1个桶中：将每个元素 分配到某个桶（编号为index），其中 ，并求出分到每个桶的最大最小数据。s 最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶i的上界和桶j的下界之间产生 。一遍扫描即可完成。 将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如： 。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出 。(1) 请描述你解决这个问题的思路；(2) 给出主要的处理流程，算法，以及算法的复杂度；(3) 请描述可能的改进。方案1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于 ，首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。 最大子序列与最大子矩阵问题数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。方案1：这个问题可以动态规划的思想解决。设 表示以第i个元素 结尾的最大子序列，那么显然 。基于这一点可以很快用代码实现。最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。方案1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。 转自： https://sunjia-704471770-qq-com.iteye.com/blog/1628359]]></content>
      <categories>
        <category>大数据量</category>
      </categories>
      <tags>
        <tag>海量数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---字符串的排列]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87966485 基于回溯法思想（排列树）： 第一次交换：字符串首字母与其他位置字母分别交换，形成多个子树；再第一次交换基础上，发生第二次交换，第二次交换是字符串第二个字母与其他位置字母交换；…直到最后一个字母结束； public ArrayList&lt;String&gt; Permutation(String str) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(str!=null &amp;&amp; str.length()&gt;0){ PermutationHelper(str.toCharArray(), 0, res); Collections.sort(res); } return (ArrayList)res; } private void PermutationHelper(char[] cs, int i, List&lt;String&gt; res){ if(i==cs.length-1){ String val = String.valueOf(cs); if(!res.contains(val)){ res.add(val); } }else{ for(int j=i; j&lt;cs.length; j++){ swap(cs, i, j); PermutationHelper(cs, i+1, res); swap(cs, i, j); } } } private void swap(char[] cs, int i, int j){ char temp = cs[i]; cs[i] = cs[j]; cs[j] = temp; }]]></content>
      <categories>
        <category>剑指offer</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回溯</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---二进制中的个数]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87945433 题目描述输入一个整数，输出该数二进制表示中 1 的个数。 n&amp;(n-1)该位运算去除 n 的位级表示中最低的那一位。 n : 10110100n-1 : 10110011n&amp;(n-1) : 10110000时间复杂度：O(M)，其中 M 表示 1 的个数。 public int NumberOf1(int n) { int count = 0; while(n!=0){ count++; n = n&amp;(n-1); } return count; } 或者也可以用Integer.bitCount()来直接计算]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---数值的整数次方]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87946665 高效解法：下面的讨论中 x 代表 base，n 代表 exponent。 因为 (x*x)n/2 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。 比如：我们的目标是求出一个数字的32次方，如果我们已经知道了它的16次方，那么只要16次放的基础上再平方一次就可以了。而16次方又是8次方的平方。这样以此类推，我们求32次方只需要5次乘方：先求平方，在平方的基础上求4次方，在4次方的基础上求8次方，在8次方的基础上求16次方，最后在16此方的基础上求32次方。 public class Solution { public double Power(double base, int exponent) { if(exponent == 0) return 1; if(exponent == 1) return base; boolean isNegative = false; if(exponent &lt; 0){ exponent = -exponent; isNegative = true; } double result = Power(base*base, exponent&gt;&gt;1); if((exponent &amp; 0x1) == 1){ result = result * base; } return isNegative ? 1/result : result; } } PS：最后，除以2可以用位运算右移代替，判断奇偶可以用(exponent &amp; 0x1)]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---链表中倒数第k个节点]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87947852 解题思路：设链表的长度为 N。设两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节点。 public ListNode FindKthToTail(ListNode head,int k) { if(head==null) return null; ListNode p1 = head; while(p1!=null &amp;&amp; k--&gt;0){ p1 = p1.next; } if(k&gt;0) return null; ListNode p2 = head; while(p1!=null){ p1 = p1.next; p2 = p2.next; } return p2; }]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---反转链表]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87948855 递归： public ListNode FindKthToTail(ListNode head,int k) { if(head==null) return null; ListNode p1 = head; while(p1!=null &amp;&amp; k--&gt;0){ p1 = p1.next; } if(k&gt;0) return null; ListNode p2 = head; while(p1!=null){ p1 = p1.next; p2 = p2.next; } return p2; } 非递归： public ListNode ReverseList(ListNode head) { ListNode newList = new ListNode(-1); while (head != null) { ListNode next = head.next; head.next = newList.next; newList.next = head; head = next; } return newList.next; }]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---复制链表的复制]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E5%A4%8D%E5%88%B6%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[第一步，在每个节点的后面插入复制的节点。第二步，对复制节点的 random 链接进行赋值。第三步，拆分 public RandomListNode Clone(RandomListNode pHead) { if(pHead == null){ return null; } //插入复制节点 RandomListNode cur = pHead; while(cur!=null){ RandomListNode clone = new RandomListNode(cur.label); clone.next = cur.next; cur.next = clone; cur = clone.next; } //为复制节点建立random连接 cur = pHead; while(cur!=null){ RandomListNode clone = cur.next; if(cur.random!=null) clone.random = cur.random.next; cur = clone.next; } //拆分两个链表 cur = pHead; RandomListNode pCloneHead = pHead.next; while(cur.next!=null){ //此处temp在拆分过程中交替表示复制节点 RandomListNode temp = cur.next; cur.next = temp.next; cur = temp; } return pCloneHead; }]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer---二叉搜索树与双向链表]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%89%91%E6%8C%87offer---%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/87959329 题目描述:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 递归法，中序遍历： private TreeNode pre = null; private TreeNode head = null; public TreeNode Convert(TreeNode pRootOfTree) { inOrder(pRootOfTree); return head; } private void inOrder(TreeNode node){ if(node == null) return; inOrder(node.left); node.left = pre; if(pre!=null){ pre.right = node; } pre = node; if(head == null) head = node; inOrder(node.right); }]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>遍历</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays.asList()的坑]]></title>
    <url>%2F2018%2F12%2F18%2FArrays.asList()%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85082537 避免使用基本数据类型数组转换为列表 public static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;&gt;(a); } asList接收的参数是一个泛型的变长参数，因为基本数据类型是无法泛型化的，也就是说8个基本类型无法作为asList的参数，要想作为泛型参数必须使用对应的包装类型 asList产生的列表不可操作对asList产生的列表不可操作，如add,remove等操作，否则会抛出UnsupportedOperationException异常（表示list不支持该操作） public static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;&gt;(a); } 注意：这里asList返回的ArrayList其实不是java.util.ArrayList，而是Arrays的一个内部类，该内部类提供了size、toArray、get、set、indexOf、contains 方法，而像 add、remove 等改变 list 结果的方法从 AbstractList父类继承过来，而且AbstractList 父类的add,remove等方法会直接抛出UnsupportedOperationException异常。 private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable { private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) { a = Objects.requireNonNull(array); } @Override public int size() { return a.length; } @Override public Object[] toArray() { return a.clone(); } @Override @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) { int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; } @Override public E get(int index) { return a[index]; } @Override public E set(int index, E element) { E oldValue = a[index]; a[index] = element; return oldValue; } @Override public int indexOf(Object o) { E[] a = this.a; if (o == null) { for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; } else { for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; } return -1; } @Override public boolean contains(Object o) { return indexOf(o) != -1; } @Override public Spliterator&lt;E&gt; spliterator() { return Spliterators.spliterator(a, Spliterator.ORDERED); } @Override public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) { Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) { a[i] = operator.apply(a[i]); } } @Override public void sort(Comparator&lt;? super E&gt; c) { Arrays.sort(a, c); } } 参考文章： http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
        <tag>Arrays</tag>
        <tag>asList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector与ArrayList]]></title>
    <url>%2F2018%2F12%2F18%2FVector%E4%B8%8EArrayList%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85081462 Vector的实现- 与ArrayList的实现类似，但是使用了synchronized进行同步。 ArrayList的实现 public synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } public synchronized E get(int index) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); } 与ArrayList的比较 Vector是同步的，因此开销就比ArrayList要大，访问速度更慢。最好使用ArrayList，因为同步操作完全可以由程序员自己控制。 Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。 替代方案- 可以使用 Collections.synchronizedList()；得到一i个线程安全的ArrayList List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; synList = Collections.synchronizedList(list); - 也可以使用concurrent并发包下的CopyOnWriteArrayList类 List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
        <tag>容器</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2018%2F12%2F18%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85080586 ArrayList类的定义，父类及实现的接口： public class ArrayList extends AbstractList implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable - 继承AbstractList类，该类中实现了get，add，remove，clear，indexOf，lastIndexOf，和获取迭代器等方法，其中indexOf和lastIndexOf查找元素是用ListIterator实现的；- 实现RandomAccess接口，该接口空的，即标记接口，那么它的作用是什么？ * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that * they support fast (generally constant time) random access. The primary * purpose of this interface is to allow generic algorithms to alter their * behavior to provide good performance when applied to either random or * sequential access lists. * 以上是jdk官方文档的解释，即RandomAccess是List实现锁使用的标记接口， * 用来表明其支持快速（通常是固定时间）随机访问。 * 此接口的主要目的是允许一般的算法更改其行为， * 从而在将其应用到随机或连续访问列表时能提供良好的性能 RandomAccess 这个标记接口就是标记能够随机访问元素的集合， 简单来说就是底层是数组实现的集合。 更具体的可以看看这篇文章： https://juejin.im/post/5a26134af265da43085de060 - 实现了 Cloneable 接口，以指示 Object.clone() 方法可以合法地对该类实例进行按字段复制。 如果在没有实现 Cloneable接口的实例上调用 Object 的 clone 方法，则会导致抛出 CloneNotSupportedException 异常。- 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。 扩容- 数组的默认大小为10 private static final int DEFAULT_CAPACITY = 10; - 添加元素时使用ensureCapacityInternal()方法来保证容量足够，如果不够时，需要使用grow()方法进行扩容，新容量的大小为oldCapacity + (oldCapacity &gt;&gt; 1) ，也就是旧容量的1.5倍。- 扩容操作需要调用 Array.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建ArrayList对象时就指定大概容量大小，减少扩容操作的次数。 public boolean add(E e){ ensureCapacityInternal(size + 1); //increments modCount!! elementData[size++] = e; return true; } public void ensureCapacityInternal(int minCapacity){ if(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA){ minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } public void ensureExplicitCapacity(int minCapacity){ modCount++; //overflow-conscious code if(minCapacity - elementData.length &gt; 0) grow(minCapacity); } public void grow(int minCapacity){ //overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if(newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if(newCapacity - MAX_ARRAAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //minCapacity is usually close to size, so this is a win elementData = Arrays.copyOf(elementData, newCapacity);; } 删除元素- 需要调用System.arraycopy()将index+1后面的元素都复制到index位置上，该操作的时间复杂度为O(N)，可以看出ArrayList删除元素的代价是非常高的。 public E remove(int index){ rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index -1;; if(numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved) elementData[--size] = null; //clear to let GC do its work return oldValue; } 部分序列化- ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组elementData使用transient修饰，该关键词声明数组默认不会被序列化。 transient Object[] elementData; // non-private to simplify nested class access - ArrayList实现了writeObject()和readObject()来控制只序列化数组中有元素填充那部分内容 private void writeObject(java.io.ObjectOutputStream s) throws java.io.Exception{ //write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); //write out size as capacity for behavioural compatibility with clone() s.writeInt(size); //write out all elements in the proper order for(int i=0; i&lt;size; i++){ s.writeObject(elementData[i]) } if(modCount != expectedModCount){ throw new ConcurrentModificationException(); } } private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) { // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) { a[i] = s.readObject(); } } } - 序列化时需要要使用ObjectOutputStream的writeObject()将对象转换为字节流并输出。而writeObject()方法在传入的对象存在writeObject()存在writeObject()的时候会去反射调用该对象的writeObject()来实现序列化。反序列化使用的是ObjectInputStream的readObject()方法，原理类似。比如下面的例子，oos的writeObject(list)方法，传入的对象list存在自己的writeObject()方法，则反射调用list对象的writeObject()方法来实现部分序列化（有内容的数组部分） ArrayList list = new ArrayList(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(list); Fail-Fast- fail-fast，快速失败，是Java集合的一种错误检测机制。迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。详细可见： https://blog.csdn.net/chenssy/article/details/38151189 - modCount用来记录ArrayList结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组大小，仅仅只是设置元素的值不算结构发生变化。-在进行序列化或者迭代等操作时，需要比较操作前后modCount是否改变，如果改变了需要抛出ConcurrentModificationException。 toArray()异常问题- ArrayList中提供了2个toArray()方法： Object[] toArray() &lt;T&gt; T[] toArray(T[] contents) - 调用toArray()函数会抛出”java.lang.ClassCastException”异常，但是调用toArray(T[] contents)能正常返回T[]。toArray()会抛出异常是因为toArray()返回的是Object[]数组，将Object[]转换为其它类型（比如将Object[]转换为Integer[]）则会抛出”java.lang.ClassCastException”异常，因为java不支持向下转型。解决该问题的办法是调用T[] toArray(T[] contents)，而不是Object[] toArray()。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
        <tag>容器</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式与Java容器]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8EJava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85071787 迭代器模式迭代器模式，提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示，属于行为型模式。把在元素之间游走地责任交给迭代器，而不是聚合对象，并可以以不同方式来遍历整个聚合对象。 优点： 1.支持以不同方式遍历一个聚合对象；2.将存储数据和遍历数据地职责分离，简化了聚合类；3.在同一聚合上可以拥有多个遍历。 缺点： 1.将存储数据和遍历数据地职责分离，增加新地聚合类时，需要增加对应的迭代器，类的个数成对增加，在一定程度上提高了系统的复杂性。 实现 思路： 1.创建一个叙述导航方法的Iterator接口和一个返回迭代器的Container接口；实现了Container接口的实体类负责实现Iterator接口;2.IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的Names。 1.Iterator接口; public interface Iterator { public boolean hasNext(); public Object next(); } 2.Container接口 public interface Container { public Iterator getIterator(); } 3.创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator public class NameRepository implements Container { public String names[] = {&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;}; @Override public Iterator getIterator() { return new NameIterator(); } private class NameIterator implements Iterator { int index; @Override public boolean hasNext() { if(index &lt; names.length){ return true; } return false; } @Override public Object next() { if(this.hasNext()){ return names[index++]; } return null; } } } 4.使用 NameRepository 来获取迭代器，并打印名字 public class IteratorPatternDemo { public static void main(String[] args) { NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){ String name = (String)iter.next(); System.out.println(&quot;Name : &quot; + name); } } } 5.执行程序，输出结果： Name : Robert Name : John Name : Julie Name : Lora java容器中的迭代器模式其中ListIterator和Iterable接口中定义了获取迭代器的方法iterator()；Collection接口继承了Iterable接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历Collection 中的元素； 关于ListIterator和Iterator的异同点：一．相同点都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。二．不同点1.使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能 用于List及其子类型。2.ListIterator有add方法，可以向List中添加对象，而Iterator不能。3.ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。4.ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。5.都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。详细可去： https://www.cnblogs.com/a842297171/p/5379130.html]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
        <tag>迭代器模式</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML各种线的含义]]></title>
    <url>%2F2018%2F12%2F18%2FUML%E5%90%84%E7%A7%8D%E7%BA%BF%E7%9A%84%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[点击原文： http://www.cnblogs.com/me115/p/4092632.html 或者点击“阅读更多” 内容目录： 从一个示例开始 类之间的关系 时序图 附录：《图说设计模式》 看懂UML类图和时序图这里不会将UML的各种元素都提到，我只想讲讲类图中各个类之间的关系； 能看懂类图中各个类之间的线条、箭头代表什么意思后，也就足够应对 日常的工作和交流；同时，我们应该能将类图所表达的含义和最终的代码对应起来； 有了这些知识，看后面章节的设计模式结构图就没有什么问题了； 本章所有图形使用Enterprise Architect 9.2来画,所有示例详见根目录下的design_patterns.EAP 从一个示例开始请看以下这个类图，类之间的关系是我们需要关注的： 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 下面详细介绍这六种关系； 类之间的关系泛化关系(generalization)类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）； eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 注：最终代码中，泛化关系表现为继承非抽象类； 实现关系(realize)实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 注：最终代码中，实现关系表现为继承抽象类； 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系(composition)组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系处理临时知道对方外，还是“使用”对方的方法和属性； 时序图为了展示对象之间的交互细节，后续章节对设计模式中每个模式的介绍，都会用到时序图； 时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。 时序图包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。 关于时序图，以下这篇文章将概念介绍的比较详细，更多实例应用，参加后续章节中的模式中的时序图； http://smartlife.blog.51cto.com/1146871/284874 附录：《图说设计模式》本文为开源书籍 《图说设计模式》 的第一篇，目前这本书基本完成； 这本书使用图形和代码结合的方式来解析设计模式；每个模式都有相应的对象结构图，同时为了展示对象间的交互细节， 我会用到时序图来介绍其如何运行；（在状态模式中，还会用到状态图，这种图的使用对于理解状态的转换非常直观） 详情请见： https://github.com/me115/design_patterns （github中包含书中所有源代码及各个模式的类图）]]></content>
      <categories>
        <category>java</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>uml</tag>
        <tag>类关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式介绍及分类]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85063760 概述设计模式是针对某一类问题的最优解决方案，是从许多优秀的软件系统总结出来的。Java中设计模式通常有23种。模式可以分成3大类：创建型、行为型、结构型 创建型模式创建型模式涉及 对象的实例化 ，特点是不让用户代码依赖于对象的创建或排列方式，避免用户直接使用new创建对象创建型模式有以下5种： 工厂方法模式、抽象工厂方法模式、生成器模式、单例模式。 行为型模式行为型模式涉及怎样合理的设计对象之间的 交互通信 ，以及怎样合理为对象 分配职责 ，让设计富有弹性，易维护，易复用行为型模式有以下11种： 责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。 结构型模式结构型模式涉及如何 组合类和对象以形成更大的结构 ，和类有关的结构型模式涉及如何 合理使用继承机制 ，和对象有关的结构型模式涉及如何合理地使用对象组合机制 。结构型模式有以下7种： 适配器模式、代理模式、组合模式、享元模式、外观模式、桥接模式、装饰模式。]]></content>
      <categories>
        <category>undefined</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F12%2F18%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85063488 定义适配器模式的定义：将某个类的接口转换为接口客户所需类型，适配器模式解决的问题是：使得原本由于接口不兼容而不能一起工作、不能统一管理的那些类可以一起工作、可以进行同意管理。 举例实现这里有教师接口ITeacher、程序员接口IProgrammer，分别用于定义他们各自工种的具体工作。然后定义深圳大学的教师SZUTeacher、腾讯的程序员TcProgrammer。这些不同的工种所作的工作都各自不同，无法进行统一管理，协同工作。我们要做的是将这些不同工种的工作内容全部输出。 ITeacher接口 public interface ITeacher { void teach(); } IProgrammer接口 public interface IProgrammer { void code(); } SZUTeacher实现类 public class SZUTeacher implements ITeacher { @Override public void teach() { System.out.println(&quot;教离散数学！&quot;);; } } TcProgrammer实现类 public class TcProgrammer implements IProgrammer { @Override public void code() { System.out.println(&quot;编php程序！&quot;);; } } 不使用适配器模式不使用适配器模式，调用者需要定义出所有工作的对象，然后逐个对象调用自己的工作方法。 public class Test1 { public static void main(String[] args) { ITeacher teacher = new SZUTeacher(); IProgrammer programmer = new TcProgrammer(); //逐个对象调用自己的工作方法 teacher.teach(); programmer.code(); } } 只定义一个适配器实现类这种方式类似与多功能充电器，一个电源插头上接着多种类型的充电接口。用户使用充电器充电时，需要使用电器接口与多功能充电器的充电插口逐个对比，接口匹配则可以开始充电。 适配器接口 public interface IWorkerAdapter { //为了兼容所有工种员工，这里的参数必须是Object类型 void work(Object worker); } 单个适配器实现类 public class WorkerAdapter implements IWorkerAdapter { @Override public void work(Object worker) { if(worker instanceof ITeacher){ ((ITeacher) worker).teach(); } if(worker instanceof IProgrammer){ ((IProgrammer) worker).code(); } } } 调用者 public class Test2 { public static void main(String[] args) { ITeacher teacher = new SZUTeacher(); IProgrammer programmer = new TcProgrammer(); Object[] workers = {teacher, programmer}; IWorkerAdapter workerAdapter = new WorkerAdapter(); for(Object worker:workers){ workerAdapter.work(worker); } } } 为每一个工种定义一个适配器为每一个工种定义一个适配器 适配器接口 public interface IWorkerAdapter2 { void work(Object worker); //判断当前适配器是否支持指定工种对象 boolean supprots(Object worker); } Teacher适配器实现类 public class TeacherAdapter implements IWorkerAdapter2 { @Override public void work(Object worker) { ((ITeacher)worker).teach(); } @Override public boolean supprots(Object worker) { return (worker instanceof ITeacher); } } Programmer适配器实现类 public class ProgrammerAdapter implements IWorkerAdapter2 { @Override public void work(Object worker) { ((IProgrammer)worker).code(); } @Override public boolean supprots(Object worker) { return (worker instanceof IProgrammer); } } 调用者 public class Test3 { public static void main(String[] args) { ITeacher teacher = new SZUTeacher(); IProgrammer programmer = new TcProgrammer(); Object[] workers = {teacher, programmer}; for(Object worker:workers){ IWorkerAdapter2 adapter = getAdapter(worker); adapter.work(worker); } } private static IWorkerAdapter2 getAdapter(Object worker) { IWorkerAdapter2 teacherAdapter = new TeacherAdapter(); IWorkerAdapter2 programmerAdapter = new ProgrammerAdapter(); //获取所有工种适配器 IWorkerAdapter2[] allAdapter = {teacherAdapter, programmerAdapter}; //遍历每一个适配器，尝试哪一个适配器是对应工种 for(IWorkerAdapter2 adapter:allAdapter){ if(adapter.supprots(worker)){ return adapter; } } return null; } } 补充：缺省适配器模式 缺省适配器模式是由适配器模式简化而来，省略了适配器模式中目标接口，也就是源接口和目标接口相同，原接口为接口，目标接口为类 典型的缺省适配器模式是JavaEE规范中的Servlet接口与GenericServlet抽象类 Servlet接口中包含五个抽象方法，而其中的service()方法才是用于实现业务逻辑的、必须要实现的方法，另外四个方法一般都是空实现，或简单实现 GenericServlet抽象类实现了Servlet接口的service()方法以外的另外四个方法，所以自定义的Servlet只需要继承GenericServlet抽象类，实现service()方法即可，无需再实现Servlet接口。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F12%2F17%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85049273 1.对代理模式的理解 代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介作用。 百度百科《代理模式》 使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑；客户类真正想要访问的是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。 我们可以用生活中的“代理律师”来理解“代理模式”： 当事人打官司，由于当事人并不非常了解官司过程，需要聘请律师来替他完成整个打官司的所有事务。所以整个打官司的过程，其实都是由律师完成，当事人均可不出现； 打官司（主业务），当事人（目标对象），律师（代理对象）；律师用自己的专业知识增强主业务； 需要注意的点：1.当事人与代理律师是为同一件事努力——代理类和目标类要实现同一接口，即业务接口；2.打官司所有的具体事务都是通过律师完成——客户类对目标类的调用均是通过代理类完成的；3.在打官司过程中需要当事人完成某些工作时，律师通知当事人，并出谋划策——代理类的执行既执行了对目标类的增强业务逻辑，又调用了目标类的主业务逻辑。 2.代理模式分类根据代理关系建立的时间不同，可以将代理分为两类：静态代理和动态代理；如同法律顾问和代理律师。 静态代理：静态代理，代理类是在程序运行之前就定义好的；类似于企业与企业的法律顾问，法律顾问是在企业打官司之前就已经存在的。 静态代理 动态代理：动态代理，程序在整个运行过程中根本不存在目标类的代理类，目标对象的代理对象是在程序运行时由jvm根据反射等机制由代理生成工具（如代理工厂类）动态生成的；类似于当事人需要打官司时临时聘请代理律师。常用的动态代理： JDK动态代理 CGLIB动态代理]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CGLIB动态代理]]></title>
    <url>%2F2018%2F12%2F17%2FCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85050397 原理 不管是静态代理还是jdk动态代理，代理的条件之一就是要求目标类和代理类实现同一业务接口；所以，对于无接口类的代理，我们就不能再用之前的代理方式； CGLIB动态代理的生成原理是 生成目标类的子类，而子类是增强过的，即子类就是目标类的代理类 。所以，使用CGLIB动态代理，要求目标类必须能够被继承，即不能是final的类 实现 导入CDLIB的jar包：cglib-full.jar 定义目标类，不用实现任何接口 public class AccountService { //目标方法 public void transfer(){ System.out.println(&quot;转账！&quot;); } } 创建代理类的工厂，该类需实现MethodInterceptor接口 声明目标类的成员变量，并创建接受该参数的构造器 定义代理生成方法，用于创建代理对象，即目标类的子类 定义回调接口方法，在这里对目标类进行增强 public class AccountServiceCglibProxyFactory implements MethodInterceptor { //1. 声明目标类的成员变量，并创建接受该参数的构造器 private AccountService targer; public AccountServiceCglibProxyFactory(AccountService targer) { this.targer = targer; } public AccountServiceCglibProxyFactory() { } //2. 定义代理生成方法，用于创建代理对象，即目标类的子类 public AccountService createProxy(){ //创建增强器 Enhancer enhancer = new Enhancer(); //初始化增强器，将目标类指定为父类 enhancer.setSuperclass(AccountService.class); //初始化增强器，设置回调方法,因为MethodInterceptor接口继承自Callback，因此可以使用this enhancer.setCallback(this); //使用增强器创建代理对象 return (AccountService) enhancer.create(); } //3. 定义回调接口方法，在这里对目标类进行增强； //本类中调用了Enhance类的setCallback(this)方法，并将回调对象this作为实参传递给了Enhancer类； //Enhancer类在后续的执行过程中，会调用本类的intercept方法； //这个intercept()方法就是回调方法 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { //若为transfer方法，则进行增强 if(&quot;transfer&quot;.equals(method.getName())){ //直接调用目标对象的业务方法执行 Object result = method.invoke(targer, objects); return result; } return method.invoke(targer, objects); } } 定义客户类 public class Client { public static void main(String[] args) { //创建目标对象 AccountService target = new AccountService(); //创建代理对象 AccountService proxy = new AccountServiceCglibProxyFactory(target).createProxy(); //执行增强后的业务方法 proxy.transfer(); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
        <tag>代理模式</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK动态代理]]></title>
    <url>%2F2018%2F12%2F17%2FJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85050381 原理 通过JDK的java.lang.reflect.Proxy类实现动态代理，使用其静态方法newProxyInstance()，依据目标对象，业务接口和业务逻辑增强三者动态生成代理对象。 /** * @param loader the class loader to define the proxy class * 目标类的类加载器，通过目标对象的发射可获取 * @param interfaces the list of interfaces for the proxy class * to implement * 目标类实现的接口数组，通过反射可获取 * @param h the invocation handler to dispatch method invocations to * 业务增强逻辑，需要再定义 * @return a proxy instance with the specified invocation handler of a * proxy class that is defined by the specified class loader * and that implements the specified interfaces */ public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) InvocationHandler是个接口，实现该接口的类用于增强目标类的主业务逻辑。接口中定义了一个invoke()方法，具体加强的代码逻辑定义在该方法中。程序在调用主业务逻辑时自动调用invoke()方法。 /** * @param proxy the proxy instance that the method was invoked on * 生成的代理对象 * @param method the {@code Method} instance corresponding to * the interface method invoked on the proxy instance. The declaring * class of the {@code Method} object will be the interface that * the method was declared in, which may be a superinterface of the * proxy interface that the proxy class inherits the method through. * 目标方法 * @param args an array of objects containing the values of the * arguments passed in the method invocation on the proxy instance, * or {@code null} if interface method takes no arguments. * Arguments of primitive types are wrapped in instances of the * appropriate primitive wrapper class, such as * {@code java.lang.Integer} or {@code java.lang.Boolean}. * 目标方法的参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 由于该方法是由代理对象自动调用，所以三个参数不需程序员给出；第二个参数Method类对象，该类中也有一个方法invoke()，可以 调用目标类的目标方法 ，该方法的具体作用是：调用执行obj对象所属类的方法。 实现 定义业务接口，简单的转账业务 public interface IAccountService { //主业务逻辑，转账 void transfer(); } 定义目标类，该类实现业务接口，并实现接口定义的目标方法（只实现主业务逻辑转账） public class AccountServiceImpl implements IAccountService { //目标方法 @Override public void transfer() { System.out.println(&quot;完成转账功能&quot;); } } 定义主业务增强逻辑类，该类需实现InvokeHandler接口，在invoke()方法中增加增强业务的代码 public class MyExtension implements InvocationHandler { //目标对象 private Object target; //将目标对象引入，以便在invoke()中调用目标对象的目标方法 public MyExtension(Object target) { this.target = target; } public MyExtension() { } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //增强业务逻辑的代码 System.out.println(&quot;对转账人身份进行了验证！&quot;); //无论主业务方法有无参数，有无返回值，下面的写法均可兼顾到 return method.invoke(target, args); } } 定义客户类 public class Client { public static void main(String[] args) { //定义目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象，并使用目标对象对其初始化 IAccountService proxy = (IAccountService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new MyExtension(target) ); //执行增强业务之后的方法 proxy.transfer(); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
        <tag>代理模式</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理]]></title>
    <url>%2F2018%2F12%2F17%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/85050367 静态代理，代理类是在程序运行之前就定义好的 定义业务接口，简单的转账业务 public interface IAccountService { //主业务逻辑，转账 void transfer(); } 定义目标类，该类实现业务接口，并实现接口定义的目标方法（只实现主业务逻辑转账） public class AccountServiceImpl implements IAccountService { //目标方法 @Override public void transfer() { System.out.println(&quot;完成转账功能&quot;); } } 定义代理类，该类实现业务接口。并且将接口对象作为一个成员变量，还要定义一个带参数（接口对象）的构造器，因为要将目标对象引入代理类，以便代理类调用目标类的目标方法 public class AccountProxy implements IAccountService { //声明业务接口对象 private IAccountService target; public AccountProxy() { } // 业务接口对象作为构造器参数 public AccountProxy(IAccountService target) { this.target = target; } /** * 代理方法，实现对目标方法的功能增强 */ @Override public void transfer() { //对目标方法的增强 System.out.println(&quot;对转账人身份进行了验证！！&quot;); target.transfer(); } } 定义客户类实现使用代理类转账。 public class Client { public static void main(String[] args) { //创建目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象 IAccountService proxy = new AccountProxy(target); //执行增强过的业务 proxy.transfer(); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
        <tag>代理模式</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git远程仓库与本地仓库关联错了？]]></title>
    <url>%2F2018%2F10%2F29%2Fgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E9%94%99%E4%BA%86%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/83504442 远程仓库与本地仓库关联 1.git remote add origin git@github.com:github_username/reposity_name.git 2.git remote add origin https://github.com:github_username/reposity_name.git 远程仓库与本地仓库取消 git remote remove origin]]></content>
      <categories>
        <category>undefined</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logback]]></title>
    <url>%2F2018%2F10%2F24%2Flogback%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/83350714 logback介绍 使用logback的目的 故障定位 显示程序运行状态，定位为题的依据 三大模块 logback-access 与servlet容器集成，提供通过http访问日志功能，意思就是第三方软件可以通过这个模块来访问logback记录的日志 logback-classic log4j的改良版本，完整实现了slf4j的API，可以让我们很方便地更换成其他日志系统，比如说log4j等； logback-core 为前面两个模块提供基础模块 logback配置 当我们使用logback-classic.jar时，应用启动，logback加载顺序： 在系统配置文件System Properties中寻找是否有logback.configurationFile对应的value 在classpath下寻找是否有logback.groovy（即logback支持groovy与xml两种配置方式） 在classpath下寻找是否有logback-test.xml 在classpath下寻找是否有logback.xml logback主要标签介绍 ，只有三个属性，分别是： scan：当scan被设置为true时，当配置文件发生改变，将会被重新加载，默认为true scanPeriod：检测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认为毫秒，当scan=true时这个值生效，默认时间间隔为1分钟 debug：当被设置为true时，将打印出logback内部日志信息，实时查看logback运行信息，默认为false； ，指定日志输出目的地，即日志输出的媒介，可以是控制台、文件、远程套接字服务器等1. ConsoleAppender，将日志输出到控制台 ${log.pattern} FileAppender，将日志输出到文件中 &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt; &lt;file&gt;D:/123.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; RollingFileAppender，滚动记录文件，先将日志记录到指定文件，当符合某个条件时再讲日志记录到其他文件 &lt;!-- DEBUG --&gt; &lt;appender name=&quot;debugAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;${log.filePath}/debug.log&lt;/file&gt; &lt;!-- &lt;rollingPolicy&gt;的作用是当发生滚动时，定义RollingFileAppender的行为，其中上面的TimeBasedRollingPolicy是最常用的滚动策略，它根据时间指定滚动策略，既负责滚动也负责触发滚动 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;${log.filePath}/debug/debug.%d{yyyy-MM-dd}.log.gz &lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;maxHistory&gt;${log.maxHistory}&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 输出格式 --&gt; &lt;encoder&gt; &lt;pattern&gt;${log.pattern}&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 在当前给到的日志级别下再进行一次过滤 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; ，作为日志的记录器，主要用于存放日志对象，还可以定义日志类型、级别等；其中有标签，也是元素，是根logger，只有一个level属性；logger有三个属性： &lt;logger name=&quot;com.enpong.o2o&quot; level=&quot;${log.level}&quot; additivity=&quot;true&quot;&gt; &lt;appender-ref ref=&quot;debugAppender&quot;/&gt; &lt;appender-ref ref=&quot;infoAppender&quot;/&gt; &lt;appender-ref ref=&quot;errorAppender&quot;/&gt; name：用来指定受此logger约束的某一个包或者具体的某一个类 level（可选）：用来设置打印级别，五个常用打印级别从低至高依次为TRACE、DEBUG、INFO、WARN、ERROR，如果未设置此级别，那么当前logger会继承上级的级别 additivity（可选）：是否向上级logger传递打印信息，默认为true 全部配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; ${log.pattern} ${log.filePath}/debug.log ${log.filePath}/debug/debug.%d{yyyy-MM-dd}.log.gz ${log.maxHistory} ${log.pattern} DEBUG ACCEPT DENY ${log.filePath}/info.log ${log.filePath}/info/info.%d{yyyy-MM-dd}.log.gz ${log.maxHistory} ${log.pattern} INFO ACCEPT DENY ${log.filePath}/erorr.log ${log.filePath}/error/error.%d{yyyy-MM-dd}.log.gz ${log.maxHistory} ${log.pattern} ERROR ACCEPT DENY]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>log日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm注解式开发]]></title>
    <url>%2F2018%2F10%2F24%2Fssm%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/83343834 将spring-mvc改为注解 修改spring-mvc.xml，将处理器的注册方式由原来的注册方式改为组件扫描器 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- &lt;bean id=&quot;/test/register.do&quot; class=&quot;com.enpong.web.StudentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;context:component-scan base-package=&quot;com.enpong.web&quot;&gt;&lt;/context:component-scan&gt; 修改处理器类，修改配置文件后，无法再通过配置文件完成service的注入，需要在处理器中以注解方式完成Service的注入 package com.enpong.web; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; import com.enpong.beans.Student; import com.enpong.service.IStudentService; @Controller @RequestMapping(“/test”) public class StudentController{ @Autowired @Qualifier(&quot;studentService&quot;) //ByName方式注入 private IStudentService studentService; @RequestMapping(&quot;/regiter.do&quot;) public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //接收请求参数 String name = request.getParameter(&quot;name&quot;); String ageStr = request.getParameter(&quot;age&quot;); Integer age = Integer.valueOf(ageStr); Student student = new Student(name, age); studentService.addStudent(student); return new ModelAndView(&quot;/WEB-INF/jsp/welcome.jsp&quot;); } } 将spring改为注解 将service改为注解，完成Dao的注入 修改spring-service.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- &lt;bean id=&quot;studentService&quot; class=&quot;com.enpong.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;IStudentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;context:component-scan base-package=&quot;com.enpong.service.impl&quot;&gt;&lt;/context:component-scan&gt; 修改Service实现类，对dao注入时可以用ByType方式或者ByName方式注入 package com.enpong.service.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import com.enpong.beans.Student; import com.enpong.dao.IStudentDao; import com.enpong.service.IStudentService; @Service public class StudentServiceImpl implements IStudentService { @Autowired //ByType方式注入 private IStudentDao studentDao; @Override @Transactional public void addStudent(Student student) { studentDao.insertStudent(student); } } 2. 将事务以注解方式织入到Service层 * 修改spring-tx.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册事务通知 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt; * 在service实现类中加入@Transactional 一般情况下，考虑性能问题，对于mybatis不建议使用注解式开发]]></content>
      <categories>
        <category>J2EE</category>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SSM开发环境]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%90%AD%E5%BB%BASSM%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/83212469 导入jar包 利用maven进行包管理，不用手动一个个添加需要的jar包，开发便利快捷 pom.xml： 4.0.0com.enpongssmwar0.0.1-SNAPSHOTssm Maven Webapphttp://maven.apache.org &lt;spring.version&gt;5.1.1.RELEASE&lt;/spring.version&gt; junit junit 3.8.1 test ch.qos.logback logback-classic 1.2.3 org.springframework spring-core ${spring.version} org.springframework spring-beans ${spring.version} org.springframework spring-context ${spring.version} org.springframework spring-jdbc ${spring.version} org.springframework spring-tx ${spring.version} org.springframework spring-web ${spring.version} org.springframework spring-webmvc ${spring.version} org.springframework spring-test ${spring.version} test javax.servlet javax.servlet-api 4.0.1 com.fasterxml.jackson.core jackson-databind 2.9.7 commons-collections commons-collections 3.2.2 org.mybatis mybatis 3.4.6 org.mybatis mybatis-spring 1.3.2 mysql mysql-connector-java 8.0.12 com.mchange c3p0 0.9.5.2 &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-compiler-plugin --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 配置Web.xml web.xml: &lt;!DOCTYPE web-app PUBLIC“-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN”“http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; contextConfigLocation classpath:spring-*.xml CharacterEncodingFilter org.springframework.web.filter.CharacterEncodingFilter &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; CharacterEncodingFilter /* org.springframework.web.context.ContextLoaderListener &lt;!-- 注册中央调度器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; * 指定spring配置文件位置 * 这里指定的配置文件，让tomcat在启动时根据spring配置文件创建spring容器； * 由于spring配置文件根据功能模块划分，拆分为多个配置文件（spring-*.xml） * 注册ServletContext监听器 * 注册ServletContext监听器的实现类ContextLoaderListener；用于创建spring容器以及将创建好的spring容器对象放入到ServletContext的域属性空间，保证spring容器的唯一性。 * 注册字符集过滤器 * 用于解决请求参数中携带的中文乱码问题 * 注册中央调度器（Dispatcher）]]></content>
      <categories>
        <category>J2EE</category>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm配置式开发]]></title>
    <url>%2F2018%2F10%2F24%2Fssm%E9%85%8D%E7%BD%AE%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/83343803 完成简单的表单注册功能 定义实体类和对应的数据表 Student实体类 Student表 定义页面和处理器 index页面 &lt;html&gt; &lt;body&gt; &lt;form action=&quot;test/register.do&quot; method=&quot;POST&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt; &lt;/form&gt; &lt;/body&gt; 处理器（实现Controller接口） package com.enpong.web; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import com.enpong.beans.Student; import com.enpong.service.IStudentService; public class StudentController implements Controller { private IStudentService studentService; public void setStudentService(IStudentService studentService) { this.studentService = studentService; } @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //接收请求参数 String name = request.getParameter(&quot;name&quot;); String ageStr = request.getParameter(&quot;age&quot;); Integer age = Integer.valueOf(ageStr); Student student = new Student(name, age); studentService.addStudent(student); return new ModelAndView(&quot;/WEB-INF/jsp/welcome.jsp&quot;); } } 定义Service 定义业务接口 package com.enpong.service; import com.enpong.beans.Student; public interface IStudentService { void addStudent(Student student); } * 实现类 package com.enpong.service.impl; import com.enpong.beans.Student; import com.enpong.dao.IStudentDao; import com.enpong.service.IStudentService; public class StudentServiceImpl implements IStudentService { private IStudentDao studentDao; public void setStudentDao(IStudentDao studentDao) { this.studentDao = studentDao; } @Override public void addStudent(Student student) { studentDao.insertStudent(student); } } 定义Dao接口，mapper配置文件 Dao接口 package com.enpong.dao; import com.enpong.beans.Student; public interface IStudentDao { void insertStudent(Student stu); } * 在Dao包中定义MyBatis的映射文件IStudentDao.xml，这里映射文件名最好与接口名一样，这是为了后面配置接口扫描时的方便 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.enpong.dao.IStudentDao&quot;&gt; &lt;insert id=&quot;insertStudent&quot;&gt; insert into student(name,age) value(#{name}, #{age}) &lt;/insert&gt; &lt;/mapper&gt; 定义jdbc.properties 在类路径下的resources目录中定义 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://172.31.71.207:3306/test jdbc.user= jdbc.password= 定义MyBatis的主配置文件 在类路径下的resources目录中定义，该配置文件中主要注册Mapper中所使用的类的别名及Mapper的位置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 定义spring的配置文件 spring的配置文件均在resources目录中定义 spring-db.xml，该配置文件中用于注册数据源相关bea n &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 注册数据源，C3P0 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册jdbc属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;/beans&gt; 2. spring-mybatis.xml，主要用于注册SqlSessionFactoryBean及Mapper动态代理生成器的bean &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 注册SqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 指定mybatis.xml文件位置 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册Mapper扫描配置器 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;!-- 指定Dao接口扫描包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.enpong.dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 3. spring-service.xml，用于进行Service的bean的注册,这里注入Dao属性时用的是Mapper映射文件的名字 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.enpong.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;IStudentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 4. spring-tx.xml，用于注册事务相关bean &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册事务通知 --&gt; &lt;tx:advice id=&quot;transactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 连接点 --&gt; &lt;tx:method name=&quot;add*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop配置 切面--&gt; &lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression=&quot;execution(* *..service.*.*(..))&quot; id=&quot;myPointcut&quot;/&gt; &lt;!-- 顾问 --&gt; &lt;aop:advisor advice-ref=&quot;transactionAdvice&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 5. spring-mvc.xml，用于注册SpringMVC的处理器，也可能需要配置处理器映射器、处理器适配器、视图解析器等与中央调度器（Dispatcher）有关的Bean &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;/test/register.do&quot; class=&quot;com.enpong.web.StudentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2018%2F10%2F23%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[版权声明：Enpong之家 https://blog.csdn.net/qq_40005950/article/details/83309047 安装git 创建版本库 多了.git目录，这个目录是git来跟踪管理版本库的，切记不可修改里面的文件，以防破坏仓库 把文件放到git仓库 用命令git add把文件添加到仓库 用git commit把文件提交到仓库 git commit -m，-m后面是本次提交的说明 继续修改readme.txt文件 git status命令让我们掌握仓库当前的状态，可以知道某些文件被修改了，但无法看到修改的具体内容 用git diff命令查看修改的具体内容 查看修改内容后，提交到仓库，谨慎的步骤 git add git status查看 git commit -m git status 版本回退 git log命令查看提交记录，记录从最近到最远排列 git reset HEAD^，回退到HEAD^版本（^表示上一个版本，^^表示上上版本，……） git reset+（版本号），可以找到某个版本，这是在窗口未关闭前的 如果git关闭后，想找到之前的版本，还可以git reflog获取之前每一次命令 工作区，暂存区，版本库概念，只有先放在暂存区的修改才会被提交 撤销修改（git checkout –file，让文件回到最近一次git commit或git add时的状态，用版本库里的版本替换工作区的版本） 一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset命令既可以回退版本，也可以把暂存区的修改撤销掉，重新返回工作区 远程仓库 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴 id_rsa.pub 文件的内容 3. 添加远程库 1. 在github上创建一个新的git仓库（目前还是空的，因为没关联到本地仓库） 2. git remote add origin git@github.com:enpong/git.git（远程仓库与本地仓库的关联） 1. ![](https://img-blog.csdn.net/20181023172916608?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 3. git push -u origin master，把当前分支master推送到远程，-u把本地的master分支与远程的master分支关联起来；在以后的提交中不需-u 分支管理 创建与合并分支 （git checkout -b + 分支）或 （git branch + 分支，git checkout + 分支），创建并切换分支 （git branch）查看所有分支，（git checkout + 分支）切换分支 （git merge + 分支），把指定分支的工作合并到当前分支 （git branch -d + 分支），删除指定分支 解决冲突 分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先， master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在 dev 分支上，也就是说， dev 分支是不稳定的，到某个时候，比如1.0版本发布时，再把 dev分支合并到 master 上，在 master 分支发布1.0版本； 你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 2. ![](https://img-blog.csdn.net/20181023180130628?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 4. 保存工作现场去做其他工作后接着继续原来的工作 1. （git stash），把当前工作现场保存起来 2. （git stash list），查看保存的工作现场 3. 恢复工作现场 1. （git stash apply）恢复，（git stash drop）删除 2. （git stash pop），恢复同时删除 4. ![](https://img-blog.csdn.net/20181023180946114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
