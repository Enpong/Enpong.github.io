<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enpong</title>
  
  <subtitle>成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://enpong.github.io/"/>
  <updated>2019-04-18T06:09:13.849Z</updated>
  <id>https://enpong.github.io/</id>
  
  <author>
    <name>Enpong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://enpong.github.io/2019/04/18/机器人的运动范围/</id>
    <published>2019-04-18T06:01:23.000Z</published>
    <updated>2019-04-18T06:09:13.849Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p><blockquote><p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>深度遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] digitSum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">    initDigitSum();</span><br><span class="line">    <span class="keyword">boolean</span>[][] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    dfs(marked, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] marked, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols || marked[r][c])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.digitSum[r][c] &gt; <span class="keyword">this</span>.threshold)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] n : next)</span><br><span class="line">        dfs(marked, r + n[<span class="number">0</span>], c + n[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDigitSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] digitSumOne = <span class="keyword">new</span> <span class="keyword">int</span>[Math.max(rows, cols)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digitSumOne.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digitSumOne[i] += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.digitSum = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++)</span><br><span class="line">            <span class="keyword">this</span>.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="dfs" scheme="https://enpong.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>矩阵中的路径</title>
    <link href="https://enpong.github.io/2019/04/18/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://enpong.github.io/2019/04/18/矩阵中的路径/</id>
    <published>2019-04-18T05:32:26.000Z</published>
    <updated>2019-04-18T06:01:00.140Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><p>例如下面的矩阵包含了一条 bfce 路径。</p><div align="center"><img src="//enpong.github.io/2019/04/18/矩阵中的路径/12_1.png"></div><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>回溯法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rows == <span class="number">0</span> || cols == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">boolean</span>[][] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = buildMatrix(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            <span class="keyword">if</span> (backtracking(matrix, str, marked, <span class="number">0</span>, i, j))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[][] marked, <span class="keyword">int</span> pathLen, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pathLen == str.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols || matrix[r][c] != str[pathLen] || marked[r][c])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] n : next)</span><br><span class="line">        <span class="keyword">if</span> (backtracking(matrix, str, marked, pathLen + <span class="number">1</span>, r + n[<span class="number">0</span>], c + n[<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] buildMatrix(<span class="keyword">char</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, idx = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            matrix[i][j] = array[idx++];</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="回溯" scheme="https://enpong.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="路径" scheme="https://enpong.github.io/tags/%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://enpong.github.io/2019/04/18/旋转数组的最小数字/</id>
    <published>2019-04-18T05:15:05.000Z</published>
    <updated>2019-04-18T05:26:41.398Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><blockquote><p>{3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为 O(logN)。</p><p>本题可以修改二分查找算法进行求解：</p><ul><li>当 nums[m] &lt;= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m；</li><li>否则解在 [m + 1, h] 之间，令 l = m + 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == nums[m] &amp;&amp; nums[m] == nums[h])</span><br><span class="line">            <span class="keyword">return</span> minNumber(nums, l, h);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; h; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二分查找" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>矩形覆盖</title>
    <link href="https://enpong.github.io/2019/04/18/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>https://enpong.github.io/2019/04/18/矩形覆盖/</id>
    <published>2019-04-18T04:55:15.000Z</published>
    <updated>2019-04-18T05:13:07.941Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ </p><div align="center"><img src="//enpong.github.io/2019/04/18/矩形覆盖/11_1.gif"></div><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>由于小矩形的尺寸是2×1，所以有大矩形为2×<em>n</em>的存在，那么我们第一步就可以有两种处理方式：</p><ul><li>第一步如果选择竖方向填充，那么该问题的规模就缩减为对于剩余的<code>2*(n-1)</code>的大矩形的填充 ；</li><li>第一步如果选择横方向的填充，则第二排的前面两个小矩形也只能如此填充，那么该问题的规模就缩减为对于剩余的<code>2*(n-2)</code>的大矩形的填充 。</li><li>结合上述分析，很容易得到递推的关系： <code>rectCover(n) = rectCover(n-1)+rectCover(n-2)</code>。当然此处也要注意递归跳出条件的判定 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> ret1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        ret = ret1 + ret2;</span><br><span class="line">        ret1 = ret2;</span><br><span class="line">        ret2 = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://enpong.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://enpong.github.io/2019/04/18/斐波那契数列/</id>
    <published>2019-04-18T04:44:42.000Z</published>
    <updated>2019-04-18T04:54:56.699Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>求斐波那契数列的第 n 项，n &lt;= 39。 </p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><div align="center"><img src="//enpong.github.io/2019/04/18/斐波那契数列/10_1.jpg"></div><ul><li><p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span>[] fib = <span class="keyword">new</span> fib[n+<span class="number">1</span>];</span><br><span class="line">    fib[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        fib[i] = fib[i-<span class="number">1</span>] + fib[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 <code>O(N)</code> 降低为 <code>O(1)</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> fib1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fib2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        result = fib1 + fib2;</span><br><span class="line">        fib1 = fib2;</span><br><span class="line">        fib2 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;求斐波那契数列的第 n 项，n &amp;lt;= 39。 &lt;/p&gt;
&lt;h5 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://enpong.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="空间优化" scheme="https://enpong.github.io/tags/%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://enpong.github.io/2019/04/18/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://enpong.github.io/2019/04/18/用两个栈实现队列/</id>
    <published>2019-04-17T19:42:52.000Z</published>
    <updated>2019-04-17T19:50:42.122Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。 </p><div align="center"><img src="//enpong.github.io/2019/04/18/用两个栈实现队列/9_1.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">            out.push(in.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span>(out.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty!"</span>);</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 &lt;/p&gt;
&lt;h4 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://enpong.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://enpong.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的下一个结点</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://enpong.github.io/2019/04/18/二叉树的下一个结点/</id>
    <published>2019-04-17T19:10:37.000Z</published>
    <updated>2019-04-17T19:42:10.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>该节点的右子树不为空，则下一节点是该节点右子树中最左节点；</p><div align="center"><img src="//enpong.github.io/2019/04/18/二叉树的下一个结点/8_1.gif"></div></li></ol><ol start="2"><li><p>该节点的右子树为空，则下一节点是包含该节点的最小左子树的子树根节点。</p><div align="center"><img src="//enpong.github.io/2019/04/18/二叉树的下一个结点/8_2.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getNext</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode temp = node.right;</span><br><span class="line">        <span class="keyword">while</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode parent = node.parent;</span><br><span class="line">            <span class="keyword">if</span>(parent.left==node)</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="中序" scheme="https://enpong.github.io/tags/%E4%B8%AD%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://enpong.github.io/2019/04/18/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://enpong.github.io/2019/04/18/重建二叉树/</id>
    <published>2019-04-17T18:07:54.000Z</published>
    <updated>2019-04-17T19:10:01.869Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder =  [9,3,15,20,7]</span><br></pre></td></tr></table></figure><div align="center"><img src="//enpong.github.io/2019/04/18/重建二叉树/7_1.gif"></div><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。 </p><div align="center"><img src="//enpong.github.io/2019/04/18/重建二叉树/7_2.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;<span class="keyword">this</span>.val = val; left = <span class="keyword">null</span>; right = <span class="keyword">null</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存中序遍历数组每个值对应的索引</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; indexForInOrder = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">        indexForInOrder.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBianryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：前序遍历数组、前序部分数组左边界，前序部分数组右边界、中序部分数组左边界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> leftTreeSize = indexForInOrder(root.val) - inL;</span><br><span class="line">    <span class="comment">//对于preL和preR的计算：DLR</span></span><br><span class="line">    <span class="comment">//对于inL的计算：LDR</span></span><br><span class="line">    root.left = reConstructBinaryTree(pre, preL+<span class="number">1</span>, preL+leftTreeSize, inL);<span class="comment">//D(L)R</span></span><br><span class="line">    root.right = reConstructBinaryTree(pre, preL+leftSize+<span class="number">1</span>, preR, inL+leftTreeSize+<span class="number">1</span>);<span class="comment">//DL(R)</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>重建一棵二叉树：</p><ol><li><p>前序+中序</p></li><li><p>后序+中序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;<span class="keyword">this</span>.val = val; left = <span class="keyword">null</span>; right = <span class="keyword">null</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存中序遍历数组每个值对应的索引</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; indexForInOrder = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] next, <span class="keyword">int</span>[] in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">        indexForInOrder.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBianryTree(next, next.length-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：后序遍历数组、后序部分数组右边界，后序部分数组左边界、中序部分数组左边界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] next, <span class="keyword">int</span> nextR, <span class="keyword">int</span> nextL, <span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextL &gt; nextR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(next[nextR]);</span><br><span class="line">    <span class="keyword">int</span> rightTreeSize = indexForInOrder(root.val) - inL;</span><br><span class="line">    <span class="comment">//对于nextR和nextL的计算：LRD</span></span><br><span class="line">    <span class="comment">//对于inL的计算：LDR</span></span><br><span class="line">    root.right = reConstructBinaryTree(next, nextR-<span class="number">1</span>, nextR-rightTreeSize, inL);<span class="comment">//L(R)D</span></span><br><span class="line">    root.left = reConstructBinaryTree(pre, nextR-rightTreeSize-<span class="number">1</span>, nextL, inL+leftTreeSize+<span class="number">1</span>);<span class="comment">//(L)RD</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="前序" scheme="https://enpong.github.io/tags/%E5%89%8D%E5%BA%8F/"/>
    
      <category term="后序" scheme="https://enpong.github.io/tags/%E5%90%8E%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://enpong.github.io/2019/04/18/从尾到头打印链表/</id>
    <published>2019-04-17T17:12:02.000Z</published>
    <updated>2019-04-18T04:30:49.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>反转链表，返回反转后链表头部</p><blockquote><p>Input: 1-&gt;2-&gt;3</p><p>Output: 3-&gt;2-&gt;1</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)<span class="comment">//如果没有节点或者只有一个节点直接返回</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node cur = head.next;<span class="comment">//保存当前节点的下一个节点</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;<span class="comment">//打断当前节点的指针域，使之能够成为末尾节点</span></span><br><span class="line">    Node newHead = reverseList(cur); <span class="comment">//返回以pNext为头的反转链表，</span></span><br><span class="line">    <span class="comment">//返回之后newHead为新头，pNext为末节点</span></span><br><span class="line">    cur.next = head;<span class="comment">//在以newHead为头、以pNext为末的新链表中接上应该为末节点的head</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node newHead = <span class="keyword">null</span>;<span class="comment">//记录最后一个指针,即反转后头节点</span></span><br><span class="line">    <span class="keyword">while</span>(head.next!=<span class="keyword">null</span>)&#123;<span class="comment">//最后一个指针不入栈，方便出栈容易实现</span></span><br><span class="line">        s.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    newHead = head;</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">        head.next = s.pop();</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node newHead = <span class="keyword">null</span>;<span class="comment">//反转后的新头节点</span></span><br><span class="line">    Node cur = head; <span class="comment">//当前节点</span></span><br><span class="line">    Node pre = <span class="keyword">null</span>; <span class="comment">//当前节点前一节点</span></span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node next = cur.next; <span class="comment">//当前节点后一节点</span></span><br><span class="line">        <span class="keyword">if</span>(next==<span class="keyword">null</span>)</span><br><span class="line">            newHead = cur;</span><br><span class="line">        cur.next = pre;<span class="comment">//当前节点下一节点指向前节点，起到反转作用</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;<span class="comment">//三个指针整体向后移动，起到遍历效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>反转部分链表，反转[m,n]之间的链表</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6    [2,5]</p><p>Output: 1-&gt;5-&gt;4-&gt;3-&gt;2-&gt;6</p></blockquote><p>个人感觉递归实现困难，采用栈和遍历的方式应该简单（只要记录以下入栈节点个数或者遍历个数即可）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;反转链表，返回反转后链表头部&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://enpong.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="反转" scheme="https://enpong.github.io/tags/%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="递归" scheme="https://enpong.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="遍历" scheme="https://enpong.github.io/tags/%E9%81%8D%E5%8E%86/"/>
    
      <category term="栈" scheme="https://enpong.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://enpong.github.io/2019/04/18/替换空格/</id>
    <published>2019-04-17T17:00:45.000Z</published>
    <updated>2019-04-17T17:11:36.244Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个字符串中的空格替换成 “%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。</p><p>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</p><p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p><div align="center"><img src="//enpong.github.io/2019/04/18/替换空格/5.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> P1 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= P1; i++)</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">            str.append(<span class="string">"  "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> P2 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (P1 &gt;= <span class="number">0</span> &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(P1--);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'%'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;将一个字符串中的空格替换成 “%20”。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="字符串" scheme="https://enpong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="替换" scheme="https://enpong.github.io/tags/%E6%9B%BF%E6%8D%A2/"/>
    
      <category term="双指针" scheme="https://enpong.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://enpong.github.io/2019/04/18/二维数组中的查找/</id>
    <published>2019-04-17T16:36:41.000Z</published>
    <updated>2019-04-18T04:43:45.768Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。</p><p>该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><div align="center"> <img src="//enpong.github.io/2019/04/18/二维数组中的查找/4.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = col-<span class="number">1</span>;<span class="comment">//从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span>(r&lt;=row-<span class="number">1</span> &amp;&amp; c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == matrix[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="查找" scheme="https://enpong.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://enpong.github.io/2019/04/18/数组中重复的数字/</id>
    <published>2019-04-17T16:10:37.000Z</published>
    <updated>2019-04-17T16:30:22.058Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 </p><blockquote><p>Input:{2, 3, 1, 0, 2, 5}</p><p>Output:2</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。</p><p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><div align="center"> <img src="//enpong.github.io/2019/04/18/数组中重复的数字/3.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplicatin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[j] = nums[i];</span><br><span class="line">    nums[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="重复" scheme="https://enpong.github.io/tags/%E9%87%8D%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>为运算表达式设计优先级</title>
    <link href="https://enpong.github.io/2019/03/22/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://enpong.github.io/2019/03/22/为运算表达式设计优先级/</id>
    <published>2019-03-22T07:39:51.000Z</published>
    <updated>2019-04-17T19:56:50.081Z</updated>
    
    <content type="html"><![CDATA[<p>回溯搜索。该问题牵涉到括号的组合问题，一般使用递归+回溯的思想。主要想法：</p><ul><li>递归回溯。可以产生所有的组合方式。 </li><li>每个小组合方式相当于一个子集，不断的将计算结果返回给上一层。 </li></ul><p>举例：a + (b - (c <em> d))会不断的变成a + (b - (res1 </em> res2))-&gt; a + (res1 - res2) -&gt; res1</p><ul><li>res2</li></ul><p>计算结果需要for循环！！！其实有这种情况，a + (b - (c <em> d))和a + (b - c) </em> d))，这里 a +<br>res2，res2就可能有多种情况。</p><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ways = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'+'</span> || c==<span class="string">'-'</span> || c==<span class="string">'*'</span>)&#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(Integer l : left)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Integer r : right)&#123;</span><br><span class="line">                        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                                ways.add(l+r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                                ways.add(l-r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                                ways.add(l*r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ways.size()==<span class="number">0</span>)</span><br><span class="line">            ways.add(Integer.valueOf(input));</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回溯搜索。该问题牵涉到括号的组合问题，一般使用递归+回溯的思想。主要想法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归回溯。可以产生所有的组合方式。 &lt;/li&gt;
&lt;li&gt;每个小组合方式相当于一个子集，不断的将计算结果返回给上一层。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：a + (b - 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
    
      <category term="括号" scheme="https://enpong.github.io/tags/%E6%8B%AC%E5%8F%B7/"/>
    
      <category term="组合" scheme="https://enpong.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
      <category term="回溯" scheme="https://enpong.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://enpong.github.io/2019/03/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://enpong.github.io/2019/03/22/二分查找/</id>
    <published>2019-03-22T07:10:34.000Z</published>
    <updated>2019-04-18T05:31:09.480Z</updated>
    
    <content type="html"><![CDATA[<h5 id="二分查找基本实现"><a href="#二分查找基本实现" class="headerlink" title="二分查找基本实现"></a>二分查找基本实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;  <span class="comment">//防止(h+l)/2加法溢出</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]==key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;key)</span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变种二分查找，找出数组中key重复元素最左位置-注意边界"><a href="#变种二分查找，找出数组中key重复元素最左位置-注意边界" class="headerlink" title="变种二分查找，找出数组中key重复元素最左位置(注意边界)"></a>变种二分查找，找出数组中key重复元素最左位置(注意边界)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&gt;=key)</span><br><span class="line">h = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[l]==key)</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="leetcode上二分查找题"><a href="#leetcode上二分查找题" class="headerlink" title="leetcode上二分查找题"></a>leetcode上二分查找题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求开方   69. Sqrt(x) (Easy)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,h=x;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sqrt = x/mid;</span><br><span class="line"><span class="keyword">if</span>(sqrt==mid)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mid&gt;sqrt)</span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符</span></span><br><span class="line"><span class="comment">//744. Find Smallest Letter Greater Than Target (Easy)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=letters.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(letters[mid]&lt;=target)</span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l&lt;letters.length ? letters[l] : letters[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以O(logN)时间复杂度找出有序数组中唯一不出现2次的元素</span></span><br><span class="line"><span class="comment">//540. Single Element in a Sorted Array (Medium)</span></span><br><span class="line"><span class="comment">//假设index是该元素所在位置，mid是偶数，则当(mid+1&lt;index)时，nums[m]==nums[m+1];</span></span><br><span class="line"><span class="comment">//当(mid+1&gt;=index),nums[m]!=nums[m+1]</span></span><br><span class="line"><span class="comment">//因此，m为偶数的情况下，当nums[m]==nums[m+1],index所在区间应该为[m+2,h];否则，index在[l,m];</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(mid%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">mid--; <span class="comment">//保证mid是偶数</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>)</span><br><span class="line">l = m+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">h = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旋转数组中的最小数字 153. Find Minimum in Rotated Sorted Array (Medium)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;=nums[h])</span><br><span class="line">h = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找区间，找到最左位置，找到最右位置</span></span><br><span class="line"><span class="comment">//34. Search for a Range (Medium)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> first=<span class="number">0</span>, last=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//找最左位置</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">h = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[l]!=target)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">first = l;</span><br><span class="line"><span class="comment">//找最右位置</span></span><br><span class="line">l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//这里mid选择向上取整，否则会死循环</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">l = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = h;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>&#123;first, last&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>关于<code>while</code>里的判断条件，如果缩小区间的形式是<code>l = m-1 &amp;&amp; h = m+1</code>（即两边闭区间），那么判断条件是<code>l&lt;=h</code>；否则应该是<code>l&lt;h</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;二分查找基本实现&quot;&gt;&lt;a href=&quot;#二分查找基本实现&quot; class=&quot;headerlink&quot; title=&quot;二分查找基本实现&quot;&gt;&lt;/a&gt;二分查找基本实现&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
      <category term="查找" scheme="https://enpong.github.io/categories/leetcode/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="二分查找" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="https://enpong.github.io/2019/03/21/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://enpong.github.io/2019/03/21/线程同步/</id>
    <published>2019-03-21T08:22:46.000Z</published>
    <updated>2019-04-18T04:19:51.656Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程中线程同步的四种常用方式："><a href="#进程中线程同步的四种常用方式：" class="headerlink" title="进程中线程同步的四种常用方式："></a>进程中线程同步的四种常用方式：</h4><h6 id="临界区（CCriticalSection"><a href="#临界区（CCriticalSection" class="headerlink" title="临界区（CCriticalSection)"></a>临界区（CCriticalSection)</h6><p>当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区对象的线程可以访问被保护的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程释放临界区为止。</p><ol><li>定义临界区对象<code>CCriticalSection g_CriticalSection</code>； </li><li>在访问共享资源之前，先获取临界区对象，<code>g_CriticalSection</code>； </li><li>访问资源结束后，释放临界区对象，<code>g_CriticalSection.unLock()</code>; </li></ol><h6 id="事件（CEvent）"><a href="#事件（CEvent）" class="headerlink" title="事件（CEvent）"></a>事件（CEvent）</h6><p>事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。<br>每个Cevent对象可以有两种状态：  <code>信号状态</code>和<code>无信号状态</code>。<br>Cevent类对象有两种类型：<br>    <code>自动事件对象</code>：在被至少一个线程释放后自动返回到无信号状态；<br>    <code>人工事件对象</code>：获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。在创        建Cevent对象时，默认创建的是自动事件。</p><h6 id="互斥量（CMutex）"><a href="#互斥量（CMutex）" class="headerlink" title="互斥量（CMutex）"></a>互斥量（CMutex）</h6><p>互斥对象和临界区对象非常相似，只是<code>互斥量允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用</code>，但是更节省资源，更有效率。</p><font color="rosybrown">互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</font><h6 id="信号量（CSemphore）"><a href="#信号量（CSemphore）" class="headerlink" title="信号量（CSemphore）"></a>信号量（CSemphore）</h6><p>当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。<code>CSemaphore</code>类对象保存了对当前访问某一个指定资源的线程的计数值，该计数<br>值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个<code>CSemaphore</code>类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计<br>数值不为零为止。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;进程中线程同步的四种常用方式：&quot;&gt;&lt;a href=&quot;#进程中线程同步的四种常用方式：&quot; class=&quot;headerlink&quot; title=&quot;进程中线程同步的四种常用方式：&quot;&gt;&lt;/a&gt;进程中线程同步的四种常用方式：&lt;/h4&gt;&lt;h6 id=&quot;临界区（CCritical
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程管理" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="同步" scheme="https://enpong.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java实现LRU策略缓冲</title>
    <link href="https://enpong.github.io/2019/03/08/Java%E5%AE%9E%E7%8E%B0LRU%E7%AD%96%E7%95%A5%E7%BC%93%E5%86%B2/"/>
    <id>https://enpong.github.io/2019/03/08/Java实现LRU策略缓冲/</id>
    <published>2019-03-08T13:05:21.000Z</published>
    <updated>2019-04-17T21:32:46.494Z</updated>
    
    <content type="html"><![CDATA[<p>1.基于<code>双向链表+HashMap</code>实现：</p><ul><li><p>访问某个节点时，将该节点从双向链表中原位置删除，并重新插入链表头。这样可以保证链表尾部节点就是最近最久未被使用的，当节点数量大于缓存空间就淘汰链表尾部节点； </p></li><li><p>为了能在<code>O(1)</code>时间内从链表删除某个节点，不能通过遍历链表查找该节点。需要借助<code>HashMap</code>存储key与节点的映射，通过key在<code>O(1)</code>时间内找到节点，并在<code>O(1)</code>时间内删除该节点。 </p></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;(maxSize * <span class="number">4</span> / <span class="number">3</span>);</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        unlink(node);</span><br><span class="line">        appendHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            unlink(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        map.put(key, node);</span><br><span class="line">        appendHead(node);</span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt; maxSize) &#123;</span><br><span class="line">            Node toRemove = removeTail();</span><br><span class="line">            map.remove(toRemove.k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node next = head.next;</span><br><span class="line">        node.next = next;</span><br><span class="line">        next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = tail.pre;</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        tail.pre = pre;</span><br><span class="line">        pre.next = tail;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Node cur = head.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != tail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Node node = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> node.k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>2.使用Java容器中的<code>LinkedHashMap</code></p><ul><li><code>LinkedHashMap</code>继承自<code>HashMap</code>，因此具有和<code>HashMap</code>一样的快速查找特性； </li><li>内部维护了一个<code>双向链表</code>，用来维护插入顺序或者LRU顺序；<code>accessOrder</code>字段决定了顺序，默认为<code>false</code>（插入顺序）； </li><li>因此，<code>LinkedHashMap = 双向链表+HashMap</code>. </li><li>但是<code>LinkedHashMap</code>实现的LRU缓存与第1个实现方式有一点  区别，即<code>LinkedHashMap</code>的链表首部才是最近最久未使用节点  ；当然，这个区别对于双向链表来说不是事儿，只是寓意上的区别而已（在我看来）。 </li></ul><blockquote><p>访问一个节点时，调用<code>get()</code>方法，<code>get()</code>中有一个函数<code>afterNodeAccess()</code>；该方法用于将该节点移到链表尾部（最近访问节点）</p></blockquote><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在<code>put</code>等操作之后执行<code>afterNodeInsertion()</code>，当<code>removeEldestEntry()</code>方法返回true时会移除最晚的节点，也就是链表首<br>部节点；<code>evict</code>只有在构建Map时才为<code>false</code>，在这里为<code>true</code>.</p></blockquote><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>removeEldestEntry()</code>默认为false，也就是说put操作后执行的<code>afterNodeInsertion()</code>并没有移除首部节点，也就没有L<br>RU缓存淘汰的说法了；如果需要让它为true，需要继承<code>LinkedHashMap</code>并且覆盖该方法；</p></blockquote><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>因此，要用<code>LinkedHashMap</code>来实现一个LRU缓存，需要：<br>1.设定最大缓存空间<code>MAX_ENTRIES</code><br>2.使用<code>LinkedHashMap</code>的构造方法将<code>accessOrder</code>设置为true，开启LRU顺序；<br>3.覆盖<code>removeEldestEntry（）</code>方法实现，在节点多于<code>MAX_ENTRIES</code>就会将最近最久未使用的节点删除。</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUTest</span></span>&#123;</span><br><span class="line">    - <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">        cache.get(<span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(cache.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.基于&lt;code&gt;双向链表+HashMap&lt;/code&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;访问某个节点时，将该节点从双向链表中原位置删除，并重新插入链表头。这样可以保证链表尾部节点就是最近最久未被使用的，当节点数量大于缓存空间就淘汰链表尾部节点； &lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
    
      <category term="java容器" scheme="https://enpong.github.io/tags/java%E5%AE%B9%E5%99%A8/"/>
    
      <category term="LRU" scheme="https://enpong.github.io/tags/LRU/"/>
    
      <category term="缓存" scheme="https://enpong.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程的中断操作</title>
    <link href="https://enpong.github.io/2019/03/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C/"/>
    <id>https://enpong.github.io/2019/03/06/Java多线程的中断操作/</id>
    <published>2019-03-06T07:33:09.000Z</published>
    <updated>2019-04-18T04:30:04.939Z</updated>
    
    <content type="html"><![CDATA[<h5 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h5><p>如果一个线程处于阻塞、限期等待或无限期等待状态时，调用该线程的interrupt()方法中断线程，就会抛出<code>InterruptedException</code>，从而提前结束该线程；（注意：不能中断IO阻塞和Synchronized锁阻塞）</p><h5 id="Interupted"><a href="#Interupted" class="headerlink" title="Interupted"></a>Interupted</h5><ul><li>如果一个线程的<code>run()</code>方法执行一个循环体，并且循环体中没有会抛出<code>InterruptedException</code>的操作（如<code>sleep()</code>)，那么该线程调用<code>interrupted()</code>就无法中断线程； </li><li>由于一个线程调用<code>interrupt()</code>会设置线程中断标志，该标志可以通过<code>interrupted()</code>来获取；因此可以在<code>run()</code>方法的循环体中以该标志来判断线程是否处于中断状态，以结束线程。 </li></ul><h5 id="Executor中断操作"><a href="#Executor中断操作" class="headerlink" title="Executor中断操作"></a>Executor中断操作</h5><ol><li><code>Executor</code>的<code>shutDown()</code>会等待所有线程执行完毕之后再关闭；而调用<code>shutDownNow()</code>，相当于调用每个线程的<code>interrupt()</code>方法，中断所有线程； </li><li>如果只想中断<code>Executor</code>中的一个线程，可以使用<code>submit()</code>提交一个线程，该方法返回一个<code>Future&lt;?&gt;</code>对象，通过调用该对象的<code>cancel(true)</code>方法中断线程。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;InterruptedException&quot;&gt;&lt;a href=&quot;#InterruptedException&quot; class=&quot;headerlink&quot; title=&quot;InterruptedException&quot;&gt;&lt;/a&gt;InterruptedException&lt;/h5&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="多线程" scheme="https://enpong.github.io/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="中断" scheme="https://enpong.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Web页面请求过程</title>
    <link href="https://enpong.github.io/2019/03/06/Web%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://enpong.github.io/2019/03/06/Web页面请求过程/</id>
    <published>2019-03-06T06:23:37.000Z</published>
    <updated>2019-04-18T04:28:05.748Z</updated>
    
    <content type="html"><![CDATA[<p>转自： <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener"> https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/计算机网络.md#web-页面请求过程 </a></p><h5 id="DHCP配置主机信息"><a href="#DHCP配置主机信息" class="headerlink" title="DHCP配置主机信息"></a>DHCP配置主机信息</h5><ul><li>假设主机最开始没有IP地址以及其他信息，那么就需要先使用DHCP来获取； </li><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中； </li><li>该报文段则被放入在一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中； </li><li>该数据报则被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备； </li><li>连接在交换机的DHCP服务器收到广播帧之后，不断向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中； </li><li>该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧； </li><li>主机收到该帧后，不断向上分解得到DHCP报文。之后就配置它的IP地址，子网掩码和DNS服务器IP地址，并在其IP转发表中安装默认网关． </li></ul><h5 id="ARP解析MAC地址"><a href="#ARP解析MAC地址" class="headerlink" title="ARP解析MAC地址"></a>ARP解析MAC地址</h5><ul><li>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成该套接字，主机需要知道网站的域名对应的IP地址。 </li><li>主机生成一个DNS查询报文，该报文具有53端口，因为DNS服务器的端口号时53； </li><li>该DNS查询报文被放入目的地址为DNS服务器的IP数据报中； </li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器； </li><li>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议； </li><li>主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将该ARP查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器； </li><li>网关路由器接收到该帧后，不断向上分解得到ARP报文，发现其中的IP地址与其接口的IP地址匹配，因此就发送ARP回答报文，包含了它的MAC地址，发回给主机。 </li></ul><h5 id="DNS解析域名"><a href="#DNS解析域名" class="headerlink" title="DNS解析域名"></a>DNS解析域名</h5><ul><li>知道了网关路由器的MAC地址之后，就可以继续DNS的解析过程了； </li><li>网关路由器接收到包含DNS查询报文的以太网帧后，抽取出IP数据报，并根据转发表决定该IP数据报应该转发的路由器； </li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达DNS服务器的路由表项； </li><li>到达DNS服务器后，DNS服务器抽取出DNS查询报文，并在DNS数据库中查找待解析的域名； </li><li>找到DNS记录之后，发送DNS回答报文，将该回答报文放入UDP报文段中，然后放入IP数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 </li></ul><h5 id="HTTP请求页面"><a href="#HTTP请求页面" class="headerlink" title="HTTP请求页面"></a>HTTP请求页面</h5><ul><li>有了HTTP服务器的IP地址，主机就能够生成TCP套接字，该套接字将用于向Web服务器发送HTTP GET报文； </li><li>在生成TCP套接字之前，必须先与HTTP服务器进行三次握手来建立连接。生成一个具有目的端口80的TCP SYN报文段，并向HTTP服务器发送该报文段； </li><li>HTTP服务器接到该报文段之后，生成TCP SYN ACK报文段，发回给主机； </li><li>连接建立之后，浏览器生成HTTP GET报文，并交付给HTTP服务器； </li><li>HTTP服务器从TCP套接字中读取HTTP GET报文，生成一个HTTP响应报文，将Web页面内容放入报文体中，发回给主机； </li><li>浏览器收到HTTP响应报文后，抽取出Web页面内容，之后进行渲染，显示Web页面。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自： &lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#web-%E9%A1%B5%E9
      
    
    </summary>
    
      <category term="网络" scheme="https://enpong.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="DHCP" scheme="https://enpong.github.io/tags/DHCP/"/>
    
      <category term="ARP" scheme="https://enpong.github.io/tags/ARP/"/>
    
      <category term="DNS" scheme="https://enpong.github.io/tags/DNS/"/>
    
      <category term="HTTP" scheme="https://enpong.github.io/tags/HTTP/"/>
    
      <category term="Web" scheme="https://enpong.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="https://enpong.github.io/2019/03/05/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://enpong.github.io/2019/03/05/五种IO模型/</id>
    <published>2019-03-05T04:55:40.000Z</published>
    <updated>2019-04-18T04:26:32.265Z</updated>
    
    <content type="html"><![CDATA[<p>一个输入操作通常有两个阶段：</p><ul><li>等待数据准备，即从存储介质（磁盘，网络等）拷贝到内核；</li><li>从内核向进程复制数据</li></ul><h5 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124039713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回</li></ul><h5 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124240779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</li></ul><h5 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h5><p><img src="https://img-blog.csdnimg.cn/20190305124437547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中；</li><li>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</li></ul><h5 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124709590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的；</li><li>当数据报准备好被读时，就为该进程生成一个SIGIO信号；</li><li>应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</li></ul><h5 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305125019326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号；</li><li>调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><h5 id="对比五种I-O模型"><a href="#对比五种I-O模型" class="headerlink" title="对比五种I/O模型"></a>对比五种I/O模型</h5><p><img src="https://img-blog.csdnimg.cn/20190305125145450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞；</li><li>异步I/O：在I/O操作未完成前，请求进程未被阻塞。</li><li>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个输入操作通常有两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待数据准备，即从存储介质（磁盘，网络等）拷贝到内核；&lt;/li&gt;
&lt;li&gt;从内核向进程复制数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;阻塞I-O&quot;&gt;&lt;a href=&quot;#阻塞I-O&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="设备管理" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="IO" scheme="https://enpong.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>BitSet</title>
    <link href="https://enpong.github.io/2019/03/02/BitSet/"/>
    <id>https://enpong.github.io/2019/03/02/BitSet/</id>
    <published>2019-03-02T11:10:27.000Z</published>
    <updated>2019-04-18T04:24:53.386Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA中<code>BitSet</code>就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个数据结构KEY和Value的保存需要消耗较多的内存，不适合保存较多的数据，即大数据场景；比如在有10亿条URL中判定一个（ <a href="http://www.baidu.com" target="_blank" rel="noopener"> www.baidu.com </a>）是否存在，如果我们使用常规的hashmap来保存将是不现实的，因为URL本身需要占据较多的内存而无法直接操作。如果我们使用bitset来保存，那么可以对一条URL求hashcode，并将数字映射在bitset上，那么事实上它只需要bitset上的一个bit位即可，即我们1位空间即可表达一个URL字符串的存在性。</p><blockquote><p>所谓“存在性”，就是通过BitSet来检测一个数字是否存在。</p></blockquote><h4 id="BitSet原理"><a href="#BitSet原理" class="headerlink" title="BitSet原理"></a>BitSet原理</h4><p>JAVA中，一个long型数字占用64位空间，根据上述“位图”的概念，那么一个long型数字（4个字节）就可以保存64个数字的“存在性”状态(无碰撞冲突时，<br>即true、false状态)。比如50个数字{0,1,10,…63}，判定“15”是否存在，那么我们通常会首先将这些数字使用数组或者hashmap保存，然后<br>再去判定，那么保存这些这些数据需要占用64 * 64位；如果使用位图，那么一个long型数字即可。（如果换成50个字符串，那么其节约的空间可能更大）。</p><ol><li>BitSet只面向数字比较，比如set(int a,boolean value)方法，将数字a在bitSet中设定为true或者false；此后可以通过get(int a)方法检测结果。对于string类型的数据，如果像使用BitSet，那么可以将其hashcode值映射在bitset中。 </li><li>首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 </li></ol><table><thead><tr><th>数字范围</th><th style="text-align:center">[0,63]</th><th>[64,127]</th><th style="text-align:right">[128,191]</th><th style="text-align:right">…</th></tr></thead><tbody><tr><td>long数组索引</td><td style="text-align:center">0</td><td>1</td><td style="text-align:right">2</td><td style="text-align:right">…</td></tr></tbody></table><ol start="3"><li><p>bitSet内部的long[]数组是基于向量的，即随着set的最大数字而动态扩展。数组的最大长度计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(maxValue - <span class="number">1</span>) &gt;&gt; <span class="number">6</span>  + <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>BitSet中set方法伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> index = number &gt;&gt; <span class="number">6</span>;<span class="comment">//找到number需要映射的数组的index。  </span></span><br><span class="line">    <span class="keyword">if</span>(index + <span class="number">1</span> &gt; length) &#123;  </span><br><span class="line">        ensureCapacity(index + <span class="number">1</span>);<span class="comment">//重新扩展long[]数组  </span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">long</span>[index] |= (<span class="number">1L</span> &lt;&lt; number);<span class="comment">//冲突解决  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="使用BitSet"><a href="#使用BitSet" class="headerlink" title="使用BitSet"></a>使用BitSet</h4><p>本例中使用bitSet做String字符串的存在性校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BitSet bitSet = <span class="keyword">new</span> BitSet(Integer.MAX_VALUE);<span class="comment">//hashcode的值域  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//0x7FFFFFFF  </span></span><br><span class="line">String url = <span class="string">"http://baidu.com/a"</span>;  </span><br><span class="line"><span class="keyword">int</span> hashcode = url.hashCode() &amp; <span class="number">0x7FFFFFFF</span>;  </span><br><span class="line">bitSet.set(hashcode);  </span><br><span class="line">  </span><br><span class="line">System.out.println(bitSet.cardinality());<span class="comment">//着色位的个数  </span></span><br><span class="line">System.out.println(bitSet.get(hashcode));<span class="comment">//检测存在性  </span></span><br><span class="line">bitSet.clear(hashcode);<span class="comment">//清除位数据</span></span><br></pre></td></tr></table></figure><h4 id="BitSet与Hashcode冲突"><a href="#BitSet与Hashcode冲突" class="headerlink" title="BitSet与Hashcode冲突"></a>BitSet与Hashcode冲突</h4><p>因为BitSet API只能接收int型的数字，即只能判定int数字是否在bitSet中存在。所以，对于String类型，我们通常使用它的hashcode，但这有一种隐患，java中hashcode存在冲突问题，即不同的String可能得到的hashcode是一样的（即使不重写hashcode方法），如果我们不能很好的解决这个问题，那么就会出现“数据抖动”—不同的hashcode算法、运行环境、bitSet容量，会导致判断的结果有所不同。比如A、B连个字符串，它们的hashcode一样，如果A在BitSet中“着色”(值为true)，那么检测B是否在BitSet存在时，也会得到true。</p><p>这个问题该如何解决或者缓解呢？</p><ol><li><p>调整hashcode生成算法：我们可以对一个String使用多个hashcode算法，生成多个hashcode，然后在同一个BitSet进行多次“着色”，在判断存在性时，只有所有的着色位为true时，才判定成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://baidu.com/a"</span>;  </span><br><span class="line"><span class="keyword">int</span> hashcode1 = url.hashCode() &amp; <span class="number">0x7FFFFFFF</span>;  </span><br><span class="line">bitSet.set(hashcode1);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> hashcode2 = (url + <span class="string">"-seed-"</span>).hashCode() &amp; <span class="number">0x7FFFFFFF</span>;  </span><br><span class="line">bitSet.set(hashcode2);  </span><br><span class="line">System.out.println(bitSet.get(hashcode1) &amp;&amp; bitSet.get(hashcode2));  </span><br><span class="line"><span class="comment">//也可以在两个不同的bitSet上进行2次“着色”，这样冲突性更小。但会消耗双倍的内存</span></span><br></pre></td></tr></table></figure><p>其实我们能够看出，这种方式降低了误判的概率。但是如果BitSet中存储了较多的数字，那么互相覆盖着色，最终数据冲突的可能性会逐渐增加，最终仍然有一定概率的判断失误。所以在hashcode算法的个数与实际String的个数之间有一个权衡，我们建议:  “hashcode算法个数 <em> String字符串的个数”  &lt; Integer.MAX_VALUE </em> 0.8</p></li><li>多个BitSet并行保存：<br>改良1)中的实现方式，我们仍然使用多个hashcode生成算法，但是每个算法生成的值在不同的BitSet中着色，这样可以保持每个BitSet的稀疏度(降低冲突的几率)。在实际结果上，比1)的误判率更低，但是它需要额外的占用更多的内存，毕竟每个BitSet都需要占用内存。这种方式，通常是缩小hashcode的值域，避免内存过度消耗。</li></ol><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BitSet bitSet1 = <span class="keyword">new</span> BitSet(Integer.MAX_VALUE);<span class="comment">//127M  </span></span><br><span class="line">BitSet bitSet2 = <span class="keyword">new</span> BitSet(Integer.MAX_VALUE);  </span><br><span class="line">  </span><br><span class="line">String url = <span class="string">"http://baidu.com/a"</span>;  </span><br><span class="line"><span class="keyword">int</span> hashcode1 = url.hashCode() &amp; <span class="number">0x7FFFFFFF</span>;  </span><br><span class="line">bitSet1.set(hashcode1);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> hashcode2 = (url + <span class="string">"-seed-"</span>).hashCode() &amp; <span class="number">0x7FFFFFFF</span>;  </span><br><span class="line">bitSet2.set(hashcode2);  </span><br><span class="line">  </span><br><span class="line">System.out.println(bitSet1.get(hashcode1) &amp;&amp; bitSet2.get(hashcode2));</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li>是否有必要完全避免误判？<br>如果做到100%的正确判断率，在原理上说BitSet是无法做的，BitSet能够保证“如果判定结果为false，那么数据一定是不存在；但是如果结果为true，可能数据存在，也可能不存在(冲突覆盖)”,即“false == YES，true == Maybe”。有人提出将冲突的数据保存在类似于BTree的额外数据结构中，事实上这种方式增加了设计的复杂度，而且最终仍然没有良好的解决内存占用较大的问题。</li></ol><h4 id="BloomFilter-布隆姆过滤器"><a href="#BloomFilter-布隆姆过滤器" class="headerlink" title="BloomFilter(布隆姆过滤器)"></a>BloomFilter(布隆姆过滤器)</h4><p>BloomFilter 的设计思想和BitSet有较大的相似性，目的也一致，它的核心思想也是使用多个Hash算法在一个“位图”结构上着色，最终提高“存在性”判断的效率。请参见Guava  BloomFilter。如下为代码样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Charset charset = Charset.forName(<span class="string">"utf-8"</span>);  </span><br><span class="line">BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(charset),<span class="number">2</span>&lt;&lt;<span class="number">21</span>);<span class="comment">//指定bloomFilter的容量  </span></span><br><span class="line">String url = <span class="string">"www.baidu.com/a"</span>;  </span><br><span class="line">bloomFilter.put(url);  </span><br><span class="line">System.out.println(bloomFilter.mightContain(url));</span><br></pre></td></tr></table></figure><h4 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h4><p>据上所述，BitSet可以有效的降低内存的使用量，但是它的内存使用量是有内部long数组的大小决定，所以在创建BitSet时指定的值域非常重要，过大的值域将会导致OOM（比如指定Long.MAX_VALUE）,在一个BitMap上存储Integer.MAX_VALUE个“着色”（注意，BitSet只能对正数操作），大概消耗128M内存。</p><hr><p>转自：<a href="https://shift-alt-ctrl.iteye.com/blog/2194519" target="_blank" rel="noopener">https://shift-alt-ctrl.iteye.com/blog/2194519</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JAVA中&lt;code&gt;BitSet&lt;/code&gt;就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="其他" scheme="https://enpong.github.io/categories/java/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="BitSet" scheme="https://enpong.github.io/tags/BitSet/"/>
    
      <category term="大数据量" scheme="https://enpong.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/"/>
    
      <category term="hashcode" scheme="https://enpong.github.io/tags/hashcode/"/>
    
  </entry>
  
</feed>
