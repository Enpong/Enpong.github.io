<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enpong</title>
  
  <subtitle>成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://enpong.github.io/"/>
  <updated>2019-11-05T07:43:00.086Z</updated>
  <id>https://enpong.github.io/</id>
  
  <author>
    <name>Enpong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis与Memcached </title>
    <link href="https://enpong.github.io/2019/05/06/Redis%E4%B8%8EMemcached/"/>
    <id>https://enpong.github.io/2019/05/06/Redis与Memcached/</id>
    <published>2019-05-06T15:57:06.000Z</published>
    <updated>2019-11-05T07:43:00.086Z</updated>
    
    <content type="html"><![CDATA[<p>两者都是内存键值对数据库。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Memcached 只支持字符串类型；</p><p>Redis 支持5种不同数据类型，字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Memcacahed 不支持分布式，只能通过客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis Cluster 实现了分布式支持。</p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Memcached 不支持持久化；</p><p>Redis 有两种持久化策略：RDB、AOF。</p><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><ul><li>在 Redis 中，并不是所有数据都一直存在内存中，可以将一些很久没用的 value 交换到磁盘，而Memcached 的数据一直在内存中；</li><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是内存利用率不高</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两者都是内存键值对数据库。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;Memcached 只支持字符串类型；&lt;/p&gt;
&lt;p&gt;Redis 支持5种不同数据
      
    
    </summary>
    
      <category term="后端" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Redis" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"/>
    
    
      <category term="redis" scheme="https://enpong.github.io/tags/redis/"/>
    
      <category term="memcached" scheme="https://enpong.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>持久化</title>
    <link href="https://enpong.github.io/2019/05/06/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://enpong.github.io/2019/05/06/持久化/</id>
    <published>2019-05-06T15:38:24.000Z</published>
    <updated>2019-11-05T07:43:38.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 是内存型数据库，为了保证在断电之后数据不会丢失，需要将内存的数据持久化到硬盘上。</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>将某个时间点的所有<strong>数据</strong>都存到硬盘上。</p><p>可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生崩溃，将会丢失最后一次创建<strong>快照</strong>之后的数据。</p><p>如果数据量很大的话，保存快照的时间很长。</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>将<strong>写命令</strong>添加到 AOF 文件的末尾</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。</p><div align="center"><img src="//enpong.github.io/2019/05/06/持久化/5.png"></div><p>选项中由 always、everysec、no，决定服务器性能和丢失的数据量。</p><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h1&gt;&lt;p&gt;Redis 是内存型数据库，为了保证在断电之后数据不会丢失，需要将内存的数据持久化到硬盘上。&lt;/p&gt;
&lt;h2 id=&quot;RDB-持久化
      
    
    </summary>
    
      <category term="后端" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Redis" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"/>
    
    
      <category term="redis" scheme="https://enpong.github.io/tags/redis/"/>
    
      <category term="持久化" scheme="https://enpong.github.io/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis使用场景</title>
    <link href="https://enpong.github.io/2019/05/06/Redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://enpong.github.io/2019/05/06/Redis使用场景/</id>
    <published>2019-05-06T15:13:03.000Z</published>
    <updated>2019-11-05T07:43:52.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h1><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>将热点数据放到内存中：</p><p>设置内存的最大使用量以及淘汰策略来保证缓存的命中率；</p><p>通过设置过期时间来实现缓存的过期失效。</p><h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><p>例如 DNS 记录就很适合使用 Redis 来存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 </p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h1 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h1><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能；</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数器&quot;&gt;&lt;a href=&quot;#计数器&quot; class=&quot;headerlink&quot; title=&quot;计数器&quot;&gt;&lt;/a&gt;计数器&lt;/h1&gt;&lt;p&gt;可以对 String 进行自增自减运算，从而实现计数器功能。&lt;/p&gt;
&lt;p&gt;Redis 这种内存型数据库的读写性能非常高，很适合存储
      
    
    </summary>
    
      <category term="后端" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Redis" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"/>
    
    
      <category term="redis" scheme="https://enpong.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构及对象</title>
    <link href="https://enpong.github.io/2019/05/06/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AF%B9%E8%B1%A1/"/>
    <id>https://enpong.github.io/2019/05/06/Redis数据结构及对象/</id>
    <published>2019-05-06T13:12:48.000Z</published>
    <updated>2019-11-05T07:44:09.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象（数据类型）"><a href="#对象（数据类型）" class="headerlink" title="对象（数据类型）"></a>对象（数据类型）</h1><p>redis数据库存储的是一个个键值对(key-value)，每个键值对都是由对象组成</p><ul><li>键总是一个字符串对象</li><li>值可以是字符串对象(string)、列表对象(list)、哈希对象(hash)、集合对象(set)、有序集合对象(sorted set)</li></ul><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素  对单个或者多个元素 进行修剪，只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名</td></tr></tbody></table><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>SDS，类似于C++封装的string，Java封装的String，Redis 自己构建了一种简单动态字符串的抽象类型，用在Redis 的字符串类型；</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>列表键的底层实现之一；</li><li>发布与订阅、慢查询、监视器等功能也用到了链表；</li><li>Redis 服务器本身使用链表来保存多个客户端的状态信息；构建客户端输出缓冲区。</li></ol><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>又称符号表、关联数组、映射，一种保存键值对的抽象数据结构</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p>Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在字典的操作上的；</p><div align="center"><img src="//enpong.github.io/2019/05/06/Redis数据结构及对象/3"></div><p>在数据库中创建一个键为”msg”，值为”hello world“ 的键值对，保存在字典中。</p></li><li><p>字典也是哈希键的的底层实现；每个哈希键对应一个数据库，里面的键值对保存的地方就是字典</p></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>字典 (dict) 类似于Java的HashMap，具有一个散列表结构，散列表中存放键值对，使用拉链法解决哈希冲突；</p><p><code>dict</code> <strong>字典</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p><code>dictht</code> <strong>散列表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p><code>dictEntry</code>散列表中的<strong>键值对</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p><strong>rehash 扩容操作</strong></p><ul><li>字典包含两个哈希表<code>dictht</code>，这是为了方便扩容 rehash 操作；</li><li>扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上，完成之后释放空间并交换两个 dictht 的角色；</li><li>rehash 操作不是一次性完成，而是采用渐进式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担；</li></ul><p><strong>渐进式 rehash</strong></p><ul><li><code>rehashidx</code> ，字典结构中的一个属性，如果该值为 -1 ，字典不采用渐进式 rehash；</li><li>渐进式 rehash 通过记录 dict 的 rehashidx 完成，从0开始，然后每执行一次 rehash 都会递增；例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 中的 table[rehashidx] 的键值对 rehash 到 dict[1] 中，并令 dict[0] 的 table[rehashidx] 指向 null，rehashidx++；</li><li>在渐进式 rehash 期间，每次对字典增删改查操作时，都会执行一次 rehash；</li><li>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去查找。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点；</p><p>节点查找复杂度：平均<code>O(logN)</code>、最坏<code>O(N)</code>.</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>有序集合的底层实现之一；</li><li>在集群节点中用作内部数据结构</li></ol><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表</li></ul><div align="center"><img src="//enpong.github.io/2019/05/06/Redis数据结构及对象/1.png"></div><ul><li>查找时，从上层指针开始，找到对应的区间之后再到下一层去查找；</li></ul><div align="center"><img src="//enpong.github.io/2019/05/06/Redis数据结构及对象/2.png"></div><ul><li>与红黑树等平衡树相比，跳跃表具有以下优点：<ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作</li></ul></li></ul><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>Redis 并没有直接使用以上数据结构来实现键值对数据库，而是基于这些数据结构创建一个对象系统，这个系统包含字符串对象、哈希对象、列表对象、集合对象、有序集合对象这五种类型的对象。而每个对象都用到了至少一种以上的数据结构。</p></li><li><p>对象系统实现了基于引用计数技术的内存回收机制、对象共享机制（让多个数据库键共享同一个对象来节约内存）</p></li><li><p>Redis 中的每个对象都由一个redisObject 结构表示，该结构中有 type 、encoding、 ptr 三个属性；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型 (5种对象)</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>一部分对象的编码：</p><div align="center"><img src="//enpong.github.io/2019/05/06/Redis数据结构及对象/4.png"></div></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象（数据类型）&quot;&gt;&lt;a href=&quot;#对象（数据类型）&quot; class=&quot;headerlink&quot; title=&quot;对象（数据类型）&quot;&gt;&lt;/a&gt;对象（数据类型）&lt;/h1&gt;&lt;p&gt;redis数据库存储的是一个个键值对(key-value)，每个键值对都是由对象组成&lt;/p&gt;
      
    
    </summary>
    
      <category term="后端" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Redis" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"/>
    
    
      <category term="redis" scheme="https://enpong.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>荷兰国旗问题</title>
    <link href="https://enpong.github.io/2019/05/03/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/"/>
    <id>https://enpong.github.io/2019/05/03/荷兰国旗问题/</id>
    <published>2019-05-03T04:28:05.000Z</published>
    <updated>2019-11-05T07:45:11.273Z</updated>
    
    <content type="html"><![CDATA[<p>荷兰国旗包含三种颜色：红、白、蓝。</p><p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。</p><p>它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</p><h2 id="按颜色进行排序"><a href="#按颜色进行排序" class="headerlink" title="按颜色进行排序"></a>按颜色进行排序</h2><p><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener">75. Sort Colors (Medium)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>题目描述：只有 0/1/2 三种颜色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zero = -<span class="number">1</span>, one = <span class="number">0</span>, two = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (one &lt; two) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[one] == <span class="number">0</span>) &#123;</span><br><span class="line">            swap(nums, ++zero, one++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[one] == <span class="number">2</span>) &#123;</span><br><span class="line">            swap(nums, --two, one);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++one;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;荷兰国旗包含三种颜色：红、白、蓝。&lt;/p&gt;
&lt;p&gt;有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。&lt;/p&gt;
&lt;p&gt;它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分
      
    
    </summary>
    
      <category term="编程" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/leetcode/"/>
    
      <category term="算法" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/leetcode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://enpong.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kth Element &amp; TopK Element</title>
    <link href="https://enpong.github.io/2019/05/03/Kth-Element-TopK-Element/"/>
    <id>https://enpong.github.io/2019/05/03/Kth-Element-TopK-Element/</id>
    <published>2019-05-03T03:46:20.000Z</published>
    <updated>2019-11-05T07:45:28.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kth-Element"><a href="#Kth-Element" class="headerlink" title="Kth Element"></a>Kth Element</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>使用快排将数组排序，选取排好序的第 K 个元素，时间复杂度O(nlogn)，空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>维护大小为 K 的小顶堆，首先建立大小为K的小顶堆，第 K+1 元素加入堆时与堆顶元素比较大小，如果大于堆顶元素，则替代堆顶元素，重新调整堆成为小顶堆；直到遍历完剩下的元素；时间复杂度为O(nlogK)，空间复杂度O(K).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : nums)&#123;</span><br><span class="line">        heap.add(val);</span><br><span class="line">        <span class="keyword">if</span>(heap.size &gt; k)</span><br><span class="line">            heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><p>根据快速排序分区操作的特性：分区操作将小于基准值的元素分在基准左边，大于分在右边，并返回基准值下标；如果返回的基准值下标正好是 K ，则完成；平均时间复杂度O(n)，最坏时间复杂度O(n²)，空间复杂度O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= h)&#123;</span><br><span class="line">        <span class="keyword">int</span> partitionInd = partition(nums, l, h);</span><br><span class="line">        <span class="keyword">if</span>(partitionInd == k-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[partitionInd];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(partitionInd &lt; k-<span class="number">1</span>)</span><br><span class="line">            h = partitionInd-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = partitionInd+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==h)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[h]&gt;=pivot &amp;&amp; l&lt;h)</span><br><span class="line">            h--;</span><br><span class="line">        nums[l] = nums[h];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nums[l]&lt;=pivot &amp;&amp; l&lt;h)</span><br><span class="line">            l++;</span><br><span class="line">        nums[h] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TopK-Element"><a href="#TopK-Element" class="headerlink" title="TopK Element"></a>TopK Element</h1><p>用于求解 <strong>TopK Elements</strong> 问题，通过维护一个大小为 K 的堆，堆中的元素就是 TopK Elements。</p><p>堆排序也可以用于求解 Kth Element 问题，堆顶元素就是 Kth Element。</p><p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kth-Element&quot;&gt;&lt;a href=&quot;#Kth-Element&quot; class=&quot;headerlink&quot; title=&quot;Kth Element&quot;&gt;&lt;/a&gt;Kth Element&lt;/h1&gt;&lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;
      
    
    </summary>
    
      <category term="编程" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/leetcode/"/>
    
      <category term="算法" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/leetcode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="堆" scheme="https://enpong.github.io/tags/%E5%A0%86/"/>
    
      <category term="排序" scheme="https://enpong.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快排" scheme="https://enpong.github.io/tags/%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="https://enpong.github.io/2019/05/03/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://enpong.github.io/2019/05/03/滑动窗口的最大值/</id>
    <published>2019-05-03T03:10:52.000Z</published>
    <updated>2019-11-05T07:45:40.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h2><p>使用Java的优先队列（也就是堆），我们可以使用最大堆（<code>PriorityQueue</code>默认是最小堆，构建最大堆只需要在构建时传入一个 comparator 即可），在滑动窗口滑动时，将当前元素加入最大堆中，堆顶的元素即是最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span> || size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        heap.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ret.add(heap.peek());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=i+size; j&lt;nums.length; i++,j++)&#123;</span><br><span class="line">        heap.remove(nums[i]);</span><br><span class="line">        heap.add(nums[j]);</span><br><span class="line">        ret.add(heap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>可以使用双端队列，队列中之存放当前元素的下标，设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值），如果前面的元素比 k 大，判断是否还在窗口范围内，不在则移除。</p><ol><li>先判断当前队列是否为空，如果不空而且当前元素比队列中尾部的元素大，将队列元素的尾端弹出；</li><li>判断队列头元素（存的是下标）是否还在滑动窗口中，不在则把头元素移除。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span> || size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[i]&gt;=nums[queue.getLast()])</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.getFirst()&lt;i-(size-<span class="number">1</span>))</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        queue.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=size)&#123;</span><br><span class="line">            ret.add(nums[queue.getFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h1 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="编程" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="堆" scheme="https://enpong.github.io/tags/%E5%A0%86/"/>
    
      <category term="双端队列" scheme="https://enpong.github.io/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="最值" scheme="https://enpong.github.io/tags/%E6%9C%80%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>创建高性能的索引</title>
    <link href="https://enpong.github.io/2019/04/30/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>https://enpong.github.io/2019/04/30/创建高性能的索引/</id>
    <published>2019-04-30T02:48:14.000Z</published>
    <updated>2019-11-05T07:46:00.734Z</updated>
    
    <content type="html"><![CDATA[<p>索引由存储引擎层实现。</p><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><h3 id="查询类型"><a href="#查询类型" class="headerlink" title="查询类型"></a>查询类型</h3><ol><li><code>全值匹配</code>：索引中所有列进行匹配；</li><li><code>匹配最左前缀</code>：只是用索引的第一列；</li><li><code>匹配列前缀</code>：匹配索引第一列的值的开头部分；</li><li><code>匹配范围值</code>：索引第一列某个范围的所有；如果范围匹配的不是索引第一列，需要补全需要范围索引列的前面全部索引列</li></ol><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>限制与索引列的顺序息息相关</p><ol><li>如果不是从索引的最左列开始查找，则无法使用索引；</li><li>不能跳过跳过索引中的列；</li><li>如果查询中有某个列的范围查找，其右边所有列都无法使用索引优化查找。</li></ol><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3><ol><li>哈希索引只保存哈希值和行指针，不存储字段值；需要通过行指针获取行数据；</li><li>哈希索引不支持部分索引列匹配，因为哈希值是全部索引列的值哈希得到的；</li><li>哈希索引只支持等值查询；</li><li>哈希索引无法用于排序，因为数据不是按索引的值顺序存储的。</li></ol><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>当InnoDB注意到某些索引值被使用非常频繁时，会在B-Tree索引的基础上建立哈希索引，这样就有了哈希索引的一些特点，比如快速哈希查找；这是一个完全自动、内部的行为，无法人为配置控制，只能选择开启或关闭该功能。</p><h2 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h2><p>MyISAM表支持空间索引，可以用作地理数据存储；和B-Tree索引不同，它无需前缀索引，而是可以使用所有维度来索引数据，可以使用任意维度来组合查询。</p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>全文索引是一种特殊的索引类型，用于查找文本中的关键词，而不是索引的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;索引由存储引擎层实现。&lt;/p&gt;
&lt;h2 id=&quot;B-Tree索引&quot;&gt;&lt;a href=&quot;#B-Tree索引&quot; class=&quot;headerlink&quot; title=&quot;B-Tree索引&quot;&gt;&lt;/a&gt;B-Tree索引&lt;/h2&gt;&lt;h3 id=&quot;查询类型&quot;&gt;&lt;a href=&quot;#查询类型&quot; 
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="MySQL" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://enpong.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="https://enpong.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL架构</title>
    <link href="https://enpong.github.io/2019/04/29/MySQL%E6%9E%B6%E6%9E%84/"/>
    <id>https://enpong.github.io/2019/04/29/MySQL架构/</id>
    <published>2019-04-29T12:11:40.000Z</published>
    <updated>2019-11-05T07:46:15.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><div align="center"><img src="//enpong.github.io/2019/04/29/MySQL架构/1.png"></div><ul><li>第一层：连接/线程管理，授权认证、安全等；</li><li>第二层：核心服务功能，查询、优化、解析、缓存以及所有内置函数，存储过程、触发器、视图；</li><li>第三层：存储引擎，负责MySQL中数据的提取和存储；事务、行级锁在该层实现。</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读锁：共享锁，同一时刻多个客户可以同时读取同一资源互不干扰；</p><p>写锁：排他锁，一个写锁会阻塞其他写锁和读锁。</p><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p>锁定资源粒度越小，并发度越高，锁开销越大。</p><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>尽管存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种有效的表锁来实现不同的目的，比如，服务器会为 ALTER TABLE语句使用表锁而忽略存储引擎的锁机制。</p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>行级锁只在存储引擎层实现，而MySQL服务器层没有实现。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性：一个事务中的操作要么全部执行，要么全部失败回滚；</li><li>一致性：数据库总是从一个一致性状态到另一个一致性状态；</li><li>隔离性：一个事务的修改在提交前，对其他事务不可见；</li><li>持久性：事务一旦提交，所做的修改持久化到数据库。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>未提交读：事务中的修改，即使未提交，其他事务也是可见的；</li><li>提交读：一个事务从开始直到提交之前，所作的修改对其他事务不可见；</li><li>可重复读：保证同一事务多次读取同一记录结果一致；</li><li>串行化：强制事务串行执行；在读取的每一行数据都加锁，会导致大量的超时和锁争用问题。</li></ul><div align="center"><img src="//enpong.github.io/2019/04/29/MySQL架构/2.png"></div><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个或多个事务在同一资源上相互争用，并请求对方已经锁定的资源，从而导致的恶性循环现象。</p><p>解决姿势：</p><ol><li>查询时间到达锁等待设定的时间后，放弃锁请求；</li><li>InnoDB处理方式：将持有最少行级排他锁的事务回滚。</li></ol><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>预写式日志：修改数据时只需要修改内存拷贝中的数据，并且将修改行为追加记录到持久在硬盘的事务日志中；因此修改需要两次写磁盘，一次修改行为写入日志，一次是内存中被修改的数据慢慢刷回磁盘；如果数据的修改行为已经记录到日志中而数据本身还未写回磁盘，此时系统崩溃，数据的修改也不会丢失，存储引擎重启时执行事务日志即可恢复。</p><h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><p>事务型存储引擎，采用多版本并发控制减少加锁操作，降低锁开销。</p><h3 id="InnoDB多版本并发控制的简单实现"><a href="#InnoDB多版本并发控制的简单实现" class="headerlink" title="InnoDB多版本并发控制的简单实现"></a>InnoDB多版本并发控制的简单实现</h3><ul><li>SELECT：1.查找版本号小于或等于当前事务版本的数据行，这样可以确保读取的数据行要么是事务开始前已存在的或者当前事务插入的行； 2.删除标识版本号要么未定义，要么大于当前事务版本号；</li><li>INSERT：为插入的数据行保存当前系统版本号为行版本号；</li><li>DELETE：为删除的数据行保存当前系统版本号为删除标识；</li><li>UPDATE：先INSERT后DELETE。</li></ul><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>数据表的定义由服务器层实现；</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li>数据存储在表空间</li><li>MVCC支持高并发，默认隔离级别可重复读，并使用间隙锁解决幻读问题；</li><li>聚簇索引</li><li>优化：可预测性预读、自适应哈希索引、插入缓冲区</li><li>在线热备份</li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li>全文索引、压缩</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h2&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;//enpong.github
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="MySQL" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://enpong.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://enpong.github.io/tags/%E9%94%81/"/>
    
      <category term="事务" scheme="https://enpong.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="存储引擎" scheme="https://enpong.github.io/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://enpong.github.io/2019/04/24/Linux/"/>
    <id>https://enpong.github.io/2019/04/24/Linux/</id>
    <published>2019-04-23T17:12:39.000Z</published>
    <updated>2019-11-05T07:46:53.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用操作和命令"><a href="#常用操作和命令" class="headerlink" title="常用操作和命令"></a>常用操作和命令</h2><p>Tab：命令或文件名补全；</p><p>Ctrl+C：中断程序；</p><p>Ctrl+D：结束键盘输入；</p><p>ls：（-a全部文件）、（-d只列出目录）、（-l长数据串行输出）；</p><p>mkdir：（-p递归创建）、（-m配置权限）；</p><p>rmkdir：（-p递归删除）</p><p>touch：更新文件时间或者建立新文件；</p><p>–help：指令用法和选项介绍；</p><p>man：显示指令具体信息；</p><p>info：将文档分成一个个页面，每个页面可跳转；</p><p>doc：/usr/share/doc，存放软件一整套说明文件；</p><p>who：查看在线用户；</p><p>sync：将内存中的文件同步到磁盘，关机前使用；</p><p>shutdown：（-k警告信息不关机）、（-r关闭系统服务后重启）、（-h关闭系统服务后立即关机）、（-c取消shutdown命令）</p><p>PATH：环境变量，声明可执行文件的路径，多个用：分隔符；</p><p>sudo：一般用户使用root可执行的命令，只有再/etc/sudoers配置的用户才可用；</p><p>RPM：redhat package manager，软件包管理工具；</p><p>YUM：基于RPM，具有依赖管理和软件升级功能；</p><p>VIM：指令模式，编辑模式，指令列模式；</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘接口"><a href="#磁盘接口" class="headerlink" title="磁盘接口"></a>磁盘接口</h3><p>IDE：磁盘接口，并口线抗干扰性差，已逐渐被SATA取代；</p><p>SATA：串口ATA，支持热插拔；</p><p>SCSI：小型机系统接口；</p><p>SAS：采取序列式技术以获得更高传输速度；</p><h3 id="磁盘文件名"><a href="#磁盘文件名" class="headerlink" title="磁盘文件名"></a>磁盘文件名</h3><p>Linux每个硬件都被当成一个文件，包括磁盘</p><p>IDE磁盘：/dev/hd[a-d]</p><p>SATA/SCSI/SAS磁盘：/dev/sd[a-p]</p><p>后面的序号与系统检测到磁盘的顺序有关，有插入的插槽位置无关；</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>MBR：限制较多，第一个扇区最重要，里面有开机记录和分区表，开机记录446bytes，分区表64bytes；分区表最多能存4个分区，主分区和扩展分区，扩展分区只有一个，扩展区可分出更多分区（逻辑分区）；分区也是一个文件，命名方式：磁盘文件名+编号，/dev/sda1；逻辑分区从5开始。</p><p>GPT：</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="分区与文件系统"><a href="#分区与文件系统" class="headerlink" title="分区与文件系统"></a>分区与文件系统</h3><p>对分区进行格式化是为了再分区建立文件系统，一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>inode：一个文件一个，记录文件属性，同时记录文件内容所在的block编号；</p><p>block：记录文件的内容，文件太大的话，占用多个block；</p><p>superblock：记录文件系统的整体信息，包括inode和block总量、使用量、剩余量，以及文件系统的格式和相关信息等；</p><p>block bitmap：记录block是否被使用的位域；</p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>Ext2文件系统：当要读取一个文件内容时，先在inode中查找文件内容所在的所有block，然后把所有内容读出来；</p><p>FAT文件系统：没有inode，每个block中存着下一个block编号；</p><h3 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h3><p>文件内容所在block过于分散，导致磁盘头移动距离过大降低读写性能；</p><p>block：在Ext2文件系统，block大小1K，2K，4K三种，一个block只能被一个文件使用；</p><p>inode：权限，拥有者与群组，容量，建立修改时间，最近读取时间，文件特性旗标，文件真正内容指向；大小固定128bytes，每个文件仅占用1个；</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>一个目1个Inode，至少1个block，block记录目录下文件的inode和文件名；inode本身不记录文件名，文件名记录在目录，因此文件增删改操作与目录的w权限有关；</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>修复文件系统</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载利用目录作为文件系统进入点，即进入目录之后就可以读取文件系统的数据</p><h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3><p>/：根目录</p><p>/usr：系统默认软件都会安装到这个目录</p><p>/var：存放系统或程序运行过程中的数据文件</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>ls： <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code> </p><p>dr…x：文件类型（d目录、-文件、l链接文件）和权限，文件拥有者、群组、其他人；</p><p>3：链接数；</p><p>root：文件拥有者；</p><p>root：所属群组；</p><p>17：文件大小；</p><p>May..:14：最后修改时间；</p><p>config：文件名</p><h5 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h5><p>cat：取出文件内容</p><p>tac：cat的反向操作，从最后一行打印</p><p>more：可以一页一页查看文件内容，适合大文件查看；</p><p>less：和more类似，多了向前翻页功能</p><p>head：取得文件前几行；</p><p>tail：取得文件后几行</p><p>od：以字符或者十六进制显示二进制文件；</p><h5 id="指令与文件搜索"><a href="#指令与文件搜索" class="headerlink" title="指令与文件搜索"></a>指令与文件搜索</h5><p>witch：指令搜索</p><p>whereis：文件搜索，速度快，因为只搜索几个特定目录；</p><p>locate：文件搜索，可用关键字或正则搜索，使用/var/lib/mlocate/数据库进行搜索，存在内存中，每日一更；（-r正则表达式）</p><p>find：文件搜索，可以使用文件属性和权限搜索</p><h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用操作和命令&quot;&gt;&lt;a href=&quot;#常用操作和命令&quot; class=&quot;headerlink&quot; title=&quot;常用操作和命令&quot;&gt;&lt;/a&gt;常用操作和命令&lt;/h2&gt;&lt;p&gt;Tab：命令或文件名补全；&lt;/p&gt;
&lt;p&gt;Ctrl+C：中断程序；&lt;/p&gt;
&lt;p&gt;Ctrl+D：结束
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Linux" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/"/>
    
    
      <category term="Linux" scheme="https://enpong.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>开发工具类：CyclicBarrier</title>
    <link href="https://enpong.github.io/2019/04/22/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACyclicBarrier/"/>
    <id>https://enpong.github.io/2019/04/22/开发工具类：CyclicBarrier/</id>
    <published>2019-04-22T13:51:30.000Z</published>
    <updated>2019-11-05T07:47:38.837Z</updated>
    
    <content type="html"><![CDATA[<p>CyclicBarrier 是一个同步辅助类，允许一组<strong>线程互相等待</strong>，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为<strong>循环</strong>的 barrier。</p><p>　　注意比较<a href="http://www.cnblogs.com/skywang12345/p/3533887.html" target="_blank" rel="noopener">CountDownLatch</a> 和<a href="http://www.cnblogs.com/skywang12345/p/3533995.html" target="_blank" rel="noopener">CyclicBarrier</a>：<br>　　　　(01) CountDownLatch 的作用是允许1或N个线程等待其他线程完成执行；而 CyclicBarrier 则是允许N个线程相互等待。<br>　　　　(02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p> <div align="center"><img src="//enpong.github.io/2019/04/22/开发工具类：CyclicBarrier/2.png"></div><h2 id="CyclicBarrier函数列表"><a href="#CyclicBarrier函数列表" class="headerlink" title="CyclicBarrier函数列表"></a><strong>CyclicBarrier函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier(<span class="keyword">int</span> parties)</span><br><span class="line"><span class="comment">//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction)</span><br><span class="line"><span class="comment">//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回当前在屏障处等待的参与者数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回要求启动此 barrier 的参与者数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//查询此屏障是否处于损坏状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//将屏障重置为其初始状态。</span></span></span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier数据结构"><a href="#CyclicBarrier数据结构" class="headerlink" title="CyclicBarrier数据结构"></a><strong>CyclicBarrier数据结构</strong></h2><div align="center"><img src="//enpong.github.io/2019/04/22/开发工具类：CyclicBarrier/1.jpg"></div><p> CyclicBarrier 是包含了 “ ReentrantLock 对象 lock “和” Condition 对象 trip “，它是通过<strong>独占锁</strong>实现的。下面通过源码去分析到底是如何实现的。</p><p> <strong>1. 构造函数</strong></p><p> 　　CyclicBarrier 的构造函数共2个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable barrierAction)。第1个构造函数是调用第2个构造函数来实现的，下面第2个构造函数的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// parties表示“必须同时到达barrier的线程个数”。</span></span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="comment">// count表示“处在等待状态的线程个数”。</span></span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="comment">// barrierCommand表示“parties个线程到达barrier时，会执行的动作”。</span></span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>2. 等待函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取“独占锁(lock)”</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存“当前的generation”</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若“当前generation已损坏”，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将“count计数器”-1</span></span><br><span class="line">       <span class="keyword">int</span> index = --count;</span><br><span class="line">       <span class="comment">// 如果index=0，则意味着“有parties个线程到达barrier”。</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">           <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果barrierCommand不为null，则执行该动作。</span></span><br><span class="line">               <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">               <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">// 唤醒所有等待线程，并更新generation。</span></span><br><span class="line">               nextGeneration();</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，</span></span><br><span class="line">        <span class="comment">// 当前线程才继续执行。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果等待过程中，线程被中断，则执行下面的函数。</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果“当前generation已经损坏”，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果“generation已经换代”，则返回index。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“独占锁(lock)”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：dowait() 的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，当前线程才继续执行。</p><p>(01) generation 是 CyclicBarrier 的一个成员变量，在 CyclicBarrier 中，同一批的线程属于同一代，即同一个Generation；CyclicBarrier 中通过 generation 对象，记录属于哪一代。当有parties个线程到达 barrier，generation 就会被更新换代。</p><p>它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> (02) 如果当前线程被中断，即 Thread.interrupted() 为true；则通过 breakBarrier() 终止 CyclicBarrier。breakBarrier() 会设置当前中断标记 broken 为 true，意味着“将该 Generation 中断”；同时，设置 count=parties ，即重新初始化 count；最后，通过 signalAll() 唤醒 CyclicBarrier 上所有的等待线程。 breakBarrier() 的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> (03) 将“ count 计数器”-1，即 –count ；然后判断是不是“有 parties 个线程到达 barrier ”，即 index 是不是为0。首先，它会调用 signalAll() 唤醒 CyclicBarrier 上所有的等待线程；接着，重新初始化 count；最后，更新 generation 的值。<br>　　当 index =0时，如果 barrierCommand 不为null，则执行该 barrierCommand ， barrierCommand 就是我们创建 CyclicBarrier 时，传入的 Runnable 对象。然后，调用 nextGeneration() 进行换代工作， nextGeneration() 的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 04) 在 for(;;) 循环中。 timed 是用来表示当前是不是“超时等待”线程。如果不是，则通过 trip.await() 进行等待；否则，调用 awaitNanos() 进行超时等待。</p><h2 id="CyclicBarrier-的使用示例"><a href="#CyclicBarrier-的使用示例" class="headerlink" title="CyclicBarrier 的使用示例"></a>CyclicBarrier 的使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        cb = <span class="keyword">new</span> CyclicBarrier(SIZE);</span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> InnerThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait for CyclicBarrier."</span>);</span><br><span class="line">                <span class="comment">// 将cb的参与者数量加1</span></span><br><span class="line">                cb.await();</span><br><span class="line">                <span class="comment">// cb的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" continued."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">2</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">3</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">4</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">0</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">0</span> continued.</span><br><span class="line">Thread-<span class="number">4</span> continued.</span><br><span class="line">Thread-<span class="number">2</span> continued.</span><br><span class="line">Thread-<span class="number">3</span> continued.</span><br><span class="line">Thread-<span class="number">1</span> continued.</span><br></pre></td></tr></table></figure><p><strong>结果说明</strong>：主线程中新建了5个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrie r时，这些线程才继续运行！</p><p><strong>示例2</strong></p><p>新建5个线程，当这5个线程达到一定的条件时，执行某项任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        cb = <span class="keyword">new</span> CyclicBarrier(SIZE, <span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"CyclicBarrier's parties is: "</span>+ cb.getParties());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> InnerThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait for CyclicBarrier."</span>);</span><br><span class="line">                <span class="comment">// 将cb的参与者数量加1</span></span><br><span class="line">                cb.await();</span><br><span class="line">                <span class="comment">// cb的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" continued."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">2</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">3</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">4</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">0</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">CyclicBarrier<span class="string">'s parties is: 5</span></span><br><span class="line"><span class="string">Thread-0 continued.</span></span><br><span class="line"><span class="string">Thread-4 continued.</span></span><br><span class="line"><span class="string">Thread-2 continued.</span></span><br><span class="line"><span class="string">Thread-3 continued.</span></span><br><span class="line"><span class="string">Thread-1 continued.</span></span><br></pre></td></tr></table></figure><p><strong>结果说明</strong>：主线程中新建了5个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到cb中所有线程都达到barrier时，执行新建cb时注册的Runnable任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CyclicBarrier 是一个同步辅助类，允许一组&lt;strong&gt;线程互相等待&lt;/strong&gt;，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为&lt;strong&gt;循环&lt;/strong&gt;的 
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="JUC" scheme="https://enpong.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>开发工具类：CountDownLatch</title>
    <link href="https://enpong.github.io/2019/04/22/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACountDownLatch/"/>
    <id>https://enpong.github.io/2019/04/22/开发工具类：CountDownLatch/</id>
    <published>2019-04-22T12:56:17.000Z</published>
    <updated>2019-11-05T07:47:59.721Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch 所描述的是”在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待“：用给定的计数初始化 CountDownLatch 。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。CountDownLatch 的本质也是一个<font color="green">“共享锁”</font></p><div align="center"><img src="//enpong.github.io/2019/04/22/开发工具类：CountDownLatch/1.png"></div>\<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch(<span class="keyword">int</span> count)</span><br><span class="line">构造一个用给定计数初始化的 CountDownLatch。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前计数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回标识此锁存器及其状态的字符串。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><br><br>　　CountDownLatch 是通过一个计数器来实现的，当我们在 new  一个 CountDownLatch 对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。<br><br>　　虽然，CountDownlatch 与 CyclicBarrier（后续会接受。另外一并发工具类）区别：<br><br>1. CountDownLatch 的作用是允许1或N个线程等待其他线程完成执行；而 CyclicBarrier 则是允许N个线程<strong>相互等待</strong><br><br>1. CountDownLatch 的计数器<strong>无法被重置</strong>；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是<strong>循环</strong>的barrier<br><br>####<br><br>## 实现分析<br><br><div align="center"><img src="//enpong.github.io/2019/04/22/开发工具类：CountDownLatch/2.jpg"></div><p>　　通过上面的结构图我们可以看到，CountDownLatch 内部依赖Sync实现，而 Sync 继承 AQS。CountDownLatch 仅提供了一个构造方法：</p><p>　　CountDownLatch(int count) ： 构造一个用给定计数初始化的 CountDownLatch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">     <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>　　sync 为 CountDownLatch 的一个内部类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">       Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">           setState(count);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取同步状态</span></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getState();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取同步状态</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//释放同步状态</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> c = getState();</span><br><span class="line">               <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                   <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 　　通过这个内部类 Sync 我们可以清楚地看到 CountDownLatch 是采用共享锁来实现的。</p><p>　　CountDownLatch 提供 await() 方法来使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 　　await 其内部使用 AQS 的 acquireSharedInterruptibly(int arg)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　在内部类 Sync 中重写了 tryAcquireShared(int arg) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>　　getState() 获取同步状态，其值等于计数器的值，从这里我们可以看到如果计数器值不等于0，则会调用doAcquireSharedInterruptibly(int arg)，该方法为一个自旋方法会尝试一直去获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 对于CountDownLatch而言，如果计数器值不等于0，那么r 会一直小于0</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 　　CountDownLatch 提供 countDown() 方法递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　 内部调用 AQS 的 releaseShared(int arg) 方法来释放共享锁同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">           doReleaseShared();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 　　tryReleaseShared(int arg) 方法被 CountDownLatch 的内部类 Sync 重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取锁状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//c == 0 直接返回，释放锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//计算新“锁计数器”</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新锁状态（计数器）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　CountDownLatch 内部通过<strong>共享锁</strong>实现。在创建 CountDownLatch 实例时，需要传递一个 int 型的参数： count ，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。当某个线程调用 await() 方法，程序首先判断 count 的值是否为0，如果不会0的话则会一直等待直到为0为止。当其他线程调用 countDown() 方法时，则执行释放共享锁状态，使count值 - 1。当在创建 CountDownLatch 时初始化的 count 参数，必须要有count 线程调用 countDown 方法才会使计数器 count 等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch 不能回滚重置。</p><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>示例仍然使用开会案例。老板进入会议室等待5个人全部到达会议室才会开会。所以这里有两个线程老板等待开会线程、员工到达会议室：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Boss线程，等待员工到达开会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BossThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        BossThread(String name)&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":Boss在会议室等待，总共有"</span> + countDownLatch.getCount() + <span class="string">"个人开会..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Boss等待</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":所有人都已经到齐了，开会吧..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//员工到达会议室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpleoyeeThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"，到达会议室...."</span>);</span><br><span class="line">            <span class="comment">//员工到达会议室 count - 1</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//Boss线程启动</span></span><br><span class="line">        <span class="keyword">new</span> BossThread(<span class="string">"张总"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> BossThread(<span class="string">"李总"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> BossThread(<span class="string">"王总"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> EmpleoyeeThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">张总:Boss在会议室等待，总共有<span class="number">5</span>个人开会...</span><br><span class="line">李总:Boss在会议室等待，总共有<span class="number">5</span>个人开会...</span><br><span class="line">王总:Boss在会议室等待，总共有<span class="number">5</span>个人开会...</span><br><span class="line">Thread-<span class="number">0</span>，到达会议室....</span><br><span class="line">Thread-<span class="number">1</span>，到达会议室....</span><br><span class="line">Thread-<span class="number">2</span>，到达会议室....</span><br><span class="line">Thread-<span class="number">3</span>，到达会议室....</span><br><span class="line">Thread-<span class="number">4</span>，到达会议室....</span><br><span class="line">张总:所有人都已经到齐了，开会吧...</span><br><span class="line">王总:所有人都已经到齐了，开会吧...</span><br><span class="line">李总:所有人都已经到齐了，开会吧...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CountDownLatch 所描述的是”在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待“：用给定的计数初始化 CountDownLatch 。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="JUC" scheme="https://enpong.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>读写锁-ReentrantReadWriteLock</title>
    <link href="https://enpong.github.io/2019/04/20/%E8%AF%BB%E5%86%99%E9%94%81-ReentrantReadWriteLock/"/>
    <id>https://enpong.github.io/2019/04/20/读写锁-ReentrantReadWriteLock/</id>
    <published>2019-04-20T15:07:30.000Z</published>
    <updated>2019-11-05T07:48:42.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h1><p>ReentrantLock 排他锁，排他锁在同一时刻仅有一个线程可以进行访问，但是在大多数场景下，大部分时间都是提供读服务，而写服务占有的时间较少。然而读服务不存在数据竞争问题，如果一个线程在读时禁止其他线程读势必会导致性能降低。所以就提供了读写锁。</p><h1 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h1><p>　　读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：在同一时间可以允许多个读线程同时访问，但是在写线程访问时，所有读线程和写线程都会被阻塞。</p><p>读写锁的主要特性：</p><ol><li>公平性：支持公平性和非公平性。</li><li>重入性：支持重入。读写锁最多支持65535个递归写入锁和65535个递归读取锁。</li><li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁</li></ol><p>　　</p><p>　　读写锁 ReentrantReadWriteLock 实现接口 ReadWriteLock ，该接口维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　ReadWriteLock 定义了两个方法。readLock() 返回用于读操作的锁，writeLock() 返回用于写操作的锁。ReentrantReadWriteLock 定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 内部类  读锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">/** 内部类  写锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回用于写入操作的锁 */</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="comment">/** 返回用于读取操作的锁 */</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省略其余源代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省略其余源代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省略其余源代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　ReentrantReadWriteLock 与 ReentrantLock 一样，其锁主体依然是 Sync ，它的读锁、写锁都是依靠 Sync 来实现的。所以 ReentrantReadWriteLock 实际上只有一个锁，只是在获取读取锁和写入锁的方式上不一样而已，它的读写锁其实就是两个类：ReadLock、writeLock，这两个类都是 lock 实现。</p><p>　　在 ReentrantLock 中使用一个 int 类型的 state 来表示同步状态，该值表示锁被一个线程重复获取的次数。但是读写锁 ReentrantReadWriteLock 内部维护着两个一对锁，需要用一个变量维护多种状态。所以读写锁采用“<strong>按位切割使用</strong>”的方式来维护这个变量，将其切分为两部分，高16为表示读，低16为表示写。分割之后，读写锁是如何迅速确定读锁和写锁的状态呢？通过位运算。假如当前同步状态为 S ，那么写状态等于 S &amp; 0x0000FFFF（将高16位全部抹去），读状态等于S &gt;&gt;&gt; 16(无符号补0右移16位)。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><p>（写锁就是一个支持可重入的排他锁）</p><h3 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h3><p>（写锁的获取最终会调用 tryAcquire(int arg) ，该方法在内部类 Sync 中实现：）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">//当前锁个数</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//写锁</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//c != 0 &amp;&amp; w == 0 表示存在读锁</span></span><br><span class="line">            <span class="comment">//当前线程不是已经获取写锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//超出最大范围</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否需要阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//设置获取锁的线程为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　该方法和 ReentrantLock 的 tryAcquire(int arg) 大致一样，在判断重入时增加了一项条件：读锁是否存在。因为要确保写锁的操作对读锁是可见的，如果在存在读锁的情况下允许获取写锁，那么那些已经获取读锁的其他线程可能就无法感知当前写线程的操作。因此只有等读锁完全释放后，写锁才能够被当前线程所获取，一旦写锁获取了，所有其他读、写线程均会被阻塞。</p><h3 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h3><p>（获取了写锁用完了则需要释放，WriteLock提供了 unlock() 方法释放写锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写锁的释放最终还是会调用 AQS 的模板方法 release(int arg) 方法，该方法首先调用 tryRelease(int arg) 方法尝试释放锁，tryRelease(int arg) 方法为读写锁内部类 Sync 中定义了，如下：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放的线程不为锁的持有者</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">//若写锁的新线程数为0，则将锁的持有者设置为null</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写锁释放锁的整个过程和独占锁ReentrantLock相似，每次释放均是减少写状态，当写状态为0时表示 写锁已经完全释放了，从而等待的其他线程可以继续访问读写锁，获取同步状态，同时此次写线程的修改对后续的线程可见。</p><h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p> （读锁为一个可重入的共享锁，它能够被多个线程同时持有，在没有其他写线程访问时，读锁总是会获取成功）</p><h3 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h3><p>（读锁的获取可以通过ReadLock的lock()方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　Sync的acquireShared(int arg)定义在AQS中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　tryAcqurireShared(int arg)尝试获取读同步状态，该方法主要用于获取共享式同步状态，获取成功返回 &gt;= 0的返回结果，否则返回 &lt; 0 的返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//exclusiveCount(c)计算写锁</span></span><br><span class="line">    <span class="comment">//如果存在写锁，且锁的持有者不是当前线程，直接返回-1</span></span><br><span class="line">    <span class="comment">//存在锁降级问题，后续阐述</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//读锁</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * readerShouldBlock():读锁是否需要等待（公平锁原则）</span></span><br><span class="line"><span class="comment">     * r &lt; MAX_COUNT：持有线程小于最大数（65535）</span></span><br><span class="line"><span class="comment">     * compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * holdCount部分后面讲解</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　读锁获取的过程相对于独占锁而言会稍微复杂下，整个过程如下：</p><ol><li>因为存在锁降级情况，如果存在写锁且锁的持有者不是当前线程则直接返回失败，否则继续</li><li>依据公平性原则，判断读锁是否 塞，读锁持有线程数小于最大值（65535），且设置锁状态成功，执行以下代码（对于HoldCounter下面再阐述），并返回1。如果不满足改条件，执行fullTryAcquireShared()。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">      HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="comment">//锁降级</span></span><br><span class="line">          <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//读锁需要阻塞</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">              <span class="comment">//列头为当前线程</span></span><br><span class="line">              <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//HoldCounter后面讲解</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      rh = cachedHoldCounter;</span><br><span class="line">                      <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                          rh = readHolds.get();</span><br><span class="line">                          <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                              readHolds.remove();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//读锁超出最大范围</span></span><br><span class="line">          <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">          <span class="comment">//CAS设置读锁成功</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">              <span class="comment">//如果是第1次获取“读取锁”，则更新firstReader和firstReaderHoldCount</span></span><br><span class="line">              <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                  firstReader = current;</span><br><span class="line">                  firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程,则将firstReaderHoldCount+1</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                  firstReaderHoldCount++;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                      rh = cachedHoldCounter;</span><br><span class="line">                  <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                      rh = readHolds.get();</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                      readHolds.set(rh);</span><br><span class="line">                  <span class="comment">//更新线程的获取“读取锁”的共享计数</span></span><br><span class="line">                  rh.count++;</span><br><span class="line">                  cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>　　fullTryAcquireShared(Thread current)会根据“是否需要阻塞等待”，“读取锁的共享计数是否超过限制”等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过CAS尝试获取锁，并返回1</p><h3 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h3><p>（与写锁相同，读锁也提供了unlock()释放读锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　unlcok()方法内部使用Sync的releaseShared(int arg)方法，该方法定义在AQS中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　调用tryReleaseShared(int arg)尝试释放读锁，该方法定义在读写锁的Sync内部类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">     Thread current = Thread.currentThread();</span><br><span class="line">     <span class="comment">//如果想要释放锁的线程为第一个获取锁的线程</span></span><br><span class="line">     <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">         <span class="comment">//仅获取了一次，则需要将firstReader 设置null，否则 firstReaderHoldCount - 1</span></span><br><span class="line">         <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">             firstReader = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             firstReaderHoldCount--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获取rh对象，并更新“当前线程获取锁的信息”</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         HoldCounter rh = cachedHoldCounter;</span><br><span class="line">         <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">             rh = readHolds.get();</span><br><span class="line">         <span class="keyword">int</span> count = rh.count;</span><br><span class="line">         <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">             readHolds.remove();</span><br><span class="line">             <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">         &#125;</span><br><span class="line">         --rh.count;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CAS更新同步状态</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>　　锁降级：从写锁变成读锁；　</p><p>　　锁升级：从读锁变成写锁。　</p><p>　　读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。</p><p>　　如下代码会产生死锁，因为同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于<strong>锁升级，ReentrantReadWriteLock是不支持</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">rtLock.readLock().lock();</span><br><span class="line">System.out.println(<span class="string">"get readLock."</span>);</span><br><span class="line">rtLock.writeLock().lock();</span><br><span class="line">System.out.println(<span class="string">"blocking"</span>);</span><br></pre></td></tr></table></figure><p>　　<strong>ReentrantReadWriteLock支持锁降级，</strong>如下代码不会产生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">rtLock.writeLock().lock();</span><br><span class="line">System.out.println(<span class="string">"writeLock"</span>);</span><br><span class="line"></span><br><span class="line">rtLock.readLock().lock();</span><br><span class="line">System.out.println(<span class="string">"get read lock"</span>);</span><br></pre></td></tr></table></figure><p>　　以上这段代码虽然不会导致死锁，但没有正确的释放锁。从写锁降级成读锁，并不会自动释放当前线程获取的写锁，仍然需要显示的释放，否则别的线程永远也获取不到写锁。锁降级就意味着写锁是可以降级为读锁的，但是需要遵循先获取写锁、获取读锁在释放写锁的次序。注意如果当前线程先获取写锁，然后释放写锁，再获取读锁这个过程不能称之为锁降级，锁降级一定要遵循那个次序。</p><p>　　锁降级中读锁的获取释放为必要？肯定是必要的。试想，假如当前线程A不获取读锁而是直接释放了写锁，这个时候另外一个线程B获取了写锁，那么这个线程B对数据的修改是不会对当前线程A可见的。如果获取了读锁，则线程B在获取写锁过程中判断如果有读锁还没有释放则会被阻塞，只有当前线程A释放读锁后，线程B才会获取写锁成功。</p><h2 id="读写锁例子"><a href="#读写锁例子" class="headerlink" title="读写锁例子"></a>读写锁例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Queue3 q3 = <span class="keyword">new</span> Queue3();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        q3.get();                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        q3.put(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;            </span><br><span class="line">                </span><br><span class="line">            &#125;.start();    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data = <span class="keyword">null</span>;<span class="comment">//共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" be to read data!"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"have read data :"</span> + data);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        rwl.writeLock().lock();<span class="comment">//上写锁，不允许其他线程读也不允许写</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" be to write data!"</span>);                    </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.data = data;        </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" have write data: "</span> + data);                    </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.writeLock().unlock();<span class="comment">//释放写锁    </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> be ready to read data!</span><br><span class="line">Thread-<span class="number">1</span> be ready to read data!</span><br><span class="line">Thread-<span class="number">2</span> be ready to read data!</span><br><span class="line">Thread-<span class="number">0</span>have read data :<span class="keyword">null</span></span><br><span class="line">Thread-<span class="number">2</span>have read data :<span class="keyword">null</span></span><br><span class="line">Thread-<span class="number">1</span>have read data :<span class="keyword">null</span></span><br><span class="line">Thread-<span class="number">5</span> be ready to write data!</span><br><span class="line">Thread-<span class="number">5</span> have write data: <span class="number">6934</span></span><br><span class="line">Thread-<span class="number">5</span> be ready to write data!</span><br><span class="line">Thread-<span class="number">5</span> have write data: <span class="number">8987</span></span><br><span class="line">Thread-<span class="number">5</span> be ready to write data!</span><br><span class="line">Thread-<span class="number">5</span> have write data: <span class="number">8496</span></span><br></pre></td></tr></table></figure><p>使用读写锁模拟一个缓存器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存器,这里假设需要存储1000左右个缓存对象，按照默认的负载因子0.75，则容量=750，大概估计每一个节点链表长度为5个</span></span><br><span class="line"><span class="comment">     * 那么数组长度大概为：150,又有雨设置map大小一般为2的指数，则最近的数字为：128</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Object value = <span class="keyword">null</span>;</span><br><span class="line">        rwl.readLock().lock();<span class="comment">//首先开启读锁，从缓存中去取</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            value = map.get(id);</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;  <span class="comment">//如果缓存中没有释放读锁，上写锁</span></span><br><span class="line">                rwl.readLock().unlock();</span><br><span class="line">                rwl.writeLock().lock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123; <span class="comment">//防止多写线程重复查询赋值</span></span><br><span class="line">                        value = <span class="string">"redis-value"</span>;  <span class="comment">//此时可以去数据库中查找，这里简单的模拟一下</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    rwl.readLock().lock(); <span class="comment">//加读锁降级写锁,不明白的可以查看上面锁降级的原理与保持读取数据原子性的讲解</span></span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    rwl.writeLock().unlock(); <span class="comment">//释放写锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            rwl.readLock().unlock(); <span class="comment">//最后释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重入锁ReentrantLock&quot;&gt;&lt;a href=&quot;#重入锁ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;重入锁ReentrantLock&quot;&gt;&lt;/a&gt;重入锁ReentrantLock&lt;/h1&gt;&lt;p&gt;ReentrantLock 
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="锁" scheme="https://enpong.github.io/tags/%E9%94%81/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>锁条件Condition</title>
    <link href="https://enpong.github.io/2019/04/20/%E9%94%81%E6%9D%A1%E4%BB%B6Condition/"/>
    <id>https://enpong.github.io/2019/04/20/锁条件Condition/</id>
    <published>2019-04-20T13:13:45.000Z</published>
    <updated>2019-11-05T07:48:18.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h1><p>　　Condition 的作用是<strong>对锁进行更精确的控制</strong>。 Condition 中的 await() 方法相当于 Object 的 wait() 方法， Condition 中的 signal() 方法相当于 Object 的 notify() 方法， Condition 中的 signalAll() 相当于 Object 的 notifyAll() 方法。不同的是， Object 中的 wait() , notify() , notifyAll() 方法是和”同步锁” (synchronized 关键字) 捆绑使用的；而 Condition 是需要与”互斥锁”/“共享锁”捆绑使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 唤醒一个等待线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 唤醒所有等待线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="Condtion的实现"><a href="#Condtion的实现" class="headerlink" title="Condtion的实现"></a>Condtion的实现</h3><p>　　获取一个 Condition 必须要通过 Lock 的 newCondition() 方法。该方法定义在接口 Lock 下面，返回的结果是绑定到此 Lock 实例的新 Condition 实例。 Condition 为一个接口，其下仅有一个实现类 ConditionObject ，由于  Condition 的操作需要获取相关的锁，而 AQS 则是同步锁的实现基础，所以 ConditionObject 则定义为 AQS 的内部类。定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedLongSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>　　每个 Condition 对象都包含着一个 FIFO 队列，该队列是 Condition 对象通知/等待功能的关键。在队列中每一个节点都包含着一个线程引用，该线程就是在该 Condition 对象上等待的线程。我们看 Condition 的定义就明白了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 省略方法 **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上面代码可以看出 Condition 拥有首节点（firstWaiter），尾节点（lastWaiter）。当前线程调用 await() 方法，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾部。结构如下：</p><p> <img src="//enpong.github.io/2019/04/20/锁条件Condition/1.jpg"></p><p>　　Node 里面包含了当前线程的引用。 Node 定义与 AQS 的 CLH 同步队列的节点使用的都是同一个类（AbstractQueuedSynchronized.Node 静态内部类）。</p><p>　　Condition 的队列结构比 CLH 同步队列的结构简单些，新增过程较为简单只需要将原尾节点的 nextWaiter 指向新增节点，然后更新 lastWaiter 即可。</p><h3 id="等待（await）"><a href="#等待（await）" class="headerlink" title="等待（await）"></a>等待（await）</h3><p>　　调用 Condition 的 await() 方法会使当前线程进入等待状态，同时会加入到 Condition 等待队列同时释放锁。当从 await() 方法返回时，当前线程一定是获取了 Condition 相关连的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">long</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测此节点的线程是否在同步队上，如果不在，则说明该线程还不具备竞争锁的资格，则继续等待</span></span><br><span class="line"><span class="comment">     * 直到检测到此节点在同步队列上</span></span><br><span class="line"><span class="comment">     * 需要被唤醒才能从条件队列转移到CLF同步队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//线程挂起</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//如果已经中断了，则退出</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">//清理下条件队列中的不是在等待条件的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此段代码的逻辑是：首先将当前线程新建一个节点同时加入到条件队列中，然后释放当前线程持有的同步状态。然后则是不断检测该节点代表的线程释放出现在 CLH 同步队列中（收到 signal 信号之后就会在 AQS 队列中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p><p>　　加入条件队列（addConditionWaiter()）源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;    <span class="comment">//尾节点</span></span><br><span class="line">    <span class="comment">//Node的节点状态如果不为CONDITION，则表示该节点不处于等待状态，需要清除节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">//清除条件队列中所有状态不为Condition的节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前线程新建节点，状态CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该节点加入到条件队列中最后一个位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　该方法主要是将当前线程加入到 Condition 条件队列中。当然在加入到尾节点之前会清楚所有状态不为 Condition 的节点。</p><p>　　<code>fullyRelease(Node node)</code>，负责释放该线程持有的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//节点状态--其实就是持有锁的数量</span></span><br><span class="line">        <span class="keyword">long</span> savedState = getState();</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>isOnSyncQueue(Node node)</code>：如果一个节点刚开始在条件队列上，现在在同步队列上获取锁则返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//状态为Condition，获取前驱节点为null，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//后继节点不为null，肯定在CLH同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>unlinkCancelledWaiters()</code>：负责将条件队列中状态不为<code>Condition</code>的节点删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通知（signal）"><a href="#通知（signal）" class="headerlink" title="通知（signal）"></a>通知（signal）</h3><p>　　调用 Condition 的 signal() 方法，将会唤醒在条件等待队列中等待最长时间的节点（条件队列里的首节点），在唤醒节点前，会将节点移到 CLH 同步队列中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测当前线程是否为拥有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//头节点，唤醒条件队列中的第一个节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);    <span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　该方法首先会判断当前线程是否已经获得了锁，这是前置条件。然后唤醒条件队列中的头节点。</p><p>　　doSignal(Node first)：唤醒头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//修改头结点，完成旧头结点的移出工作</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">            (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　doSignal(Node first)主要是做两件事：1.修改头节点，2.调用 transferForSignal(Node first)  方法将节点移动到CLH同步队列中。transferForSignal(Node first)源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将该节点从状态CONDITION改变为初始状态0,</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将节点加入到syn队列中去，返回的是syn队列中node节点前面的一个节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断当前线程是否已经获取了锁，如果没有获取则直接抛出异常，因为获取锁为通知的前置条件。</li><li>如果线程已经获取了锁，则将唤醒条件队列的首节点</li><li>唤醒首节点是先将条件队列中的头节点移出，然后调用 AQS 的 enq(Node node) 方法将其安全地移到 CLH 同步队列中</li><li>最后判断如果该节点的同步状态是否为 Cancel ，或者修改状态为 Signal 失败时，则直接调用LockSupport唤醒该节点的线程。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　一个线程获取锁后，通过调用 Condition 的 await() 方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过 isOnSyncQueue(Node node) 方法不断自检看节点是否已经在 CLH 同步队列了，如果是则尝试获取锁，否则一直挂起。当线程调用 signal() 方法后，程序首先检查当前线程是否获取了锁，然后通过 doSignal(Node first) 方法唤醒 CLH 同步队列的首节点。被唤醒的线程，将从 await() 方法中的 while 循环中退出来，然后调用 acquireQueued() 方法竞争同步状态。</p><h1 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h1><p>　　synchronized 原理在 java 中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。<br>当我们调用某对象的 synchronized 方法时，就获取了该对象的同步锁。例如， synchronized(obj) 就获取了“obj这个对象”的同步锁。<br>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程 A 和线程 B ，它们都会访问“对象 obj 的同步锁”。假设，在某一时刻，线程 A 获取到“ obj 的同步锁”并在执行一些操作；而此时，线程 B 也企图获取“ obj 的同步锁” —— 线程 B 会获取失败，它必须等待，直到线程 A 释放了“该对象的同步锁”之后线程 B 才能获取到“ obj 的同步锁”从而才可以运行。</p><h1 id="synchronized基本规则"><a href="#synchronized基本规则" class="headerlink" title="synchronized基本规则"></a>synchronized基本规则</h1><p>　　synchronized 基本规则我们将 synchronized 的基本规则总结为下面3条，并通过实例对它们进行说明。<br>　　第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。<br>　　第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。<br>　　第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p><p> <strong>实例锁</strong> – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。<br>               实例锁对应的就是synchronized关键字。</p><p><strong>全局锁</strong> – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。<br>               全局锁对应的就是 static synchronized（或者是锁在该类的class或者classloader对象上）。</p><h2 id="Condtion的实现-1"><a href="#Condtion的实现-1" class="headerlink" title="Condtion的实现"></a>Condtion的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="comment">// 将x添加到缓冲中</span></span><br><span class="line">            items[putptr] = x; </span><br><span class="line">            <span class="comment">// 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。</span></span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将“缓冲”数量+1</span></span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">// 唤醒take线程，因为take线程通过notEmpty.await()等待</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印写入的数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" put  "</span>+ (Integer)x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) </span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="comment">// 将x从缓冲中取出</span></span><br><span class="line">            Object x = items[takeptr]; </span><br><span class="line">            <span class="comment">// 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将“缓冲”数量-1</span></span><br><span class="line">            --count;</span><br><span class="line">            <span class="comment">// 唤醒put线程，因为put线程通过notFull.await()等待</span></span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印取出的数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" take "</span>+ (Integer)x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BoundedBuffer bb = <span class="keyword">new</span> BoundedBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)；</span></span><br><span class="line">        <span class="comment">// 启动10个“读线程”，从BoundedBuffer中不断的读数据。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> PutThread(<span class="string">"p"</span>+i, i).start();</span><br><span class="line">            <span class="keyword">new</span> TakeThread(<span class="string">"t"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(String name, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);    <span class="comment">// 线程休眠1ms</span></span><br><span class="line">                bb.put(num);        <span class="comment">// 向BoundedBuffer中写入数据</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TakeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TakeThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);                    <span class="comment">// 线程休眠1ms</span></span><br><span class="line">                Integer num = (Integer)bb.take();    <span class="comment">// 从BoundedBuffer中取出数据</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p1 put  <span class="number">1</span></span><br><span class="line">p4 put  <span class="number">4</span></span><br><span class="line">p5 put  <span class="number">5</span></span><br><span class="line">p0 put  <span class="number">0</span></span><br><span class="line">p2 put  <span class="number">2</span></span><br><span class="line">t0 take <span class="number">1</span></span><br><span class="line">p3 put  <span class="number">3</span></span><br><span class="line">t1 take <span class="number">4</span></span><br><span class="line">p6 put  <span class="number">6</span></span><br><span class="line">t2 take <span class="number">5</span></span><br><span class="line">p7 put  <span class="number">7</span></span><br><span class="line">t3 take <span class="number">0</span></span><br><span class="line">p8 put  <span class="number">8</span></span><br><span class="line">t4 take <span class="number">2</span></span><br><span class="line">p9 put  <span class="number">9</span></span><br><span class="line">t5 take <span class="number">3</span></span><br><span class="line">t6 take <span class="number">6</span></span><br><span class="line">t7 take <span class="number">7</span></span><br><span class="line">t8 take <span class="number">8</span></span><br><span class="line">t9 take <span class="number">9</span></span><br></pre></td></tr></table></figure><p>(01)  BoundedBuffer  是容量为5的缓冲，缓冲中存储的是 Object 对象，支持多线程的读/写缓冲。多个线程操作“一个 BoundedBuffer 对象”时，它们通过互斥锁 lock 对缓冲区 items 进行互斥访问；而且同一个 BoundedBuffer 对象下的全部线程共用 “notFull” 和 “notEmpty” 这两个 Condition 。<br>       notFull 用于控制写缓冲， notEmpty 用于控制读缓冲。当缓冲已满的时候，调用 put 的线程会执行notFull.await()进行等待；当缓冲区不是满的状态时，就将对象添加到缓冲区并将缓冲区的容量count+1，最后，调用notEmpty.signal()缓冲notEmpty上的等待线程(调用notEmpty.await的线程)。 简言之，notFull控制“缓冲区的写入”，当往缓冲区写入数据之后会唤醒notEmpty上的等待线程。<br>       同理，notEmpty控制“缓冲区的读取”，当读取了缓冲区数据之后会唤醒notFull上的等待线程。<br>(02) 在ConditionTest2的main函数中，启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)；同时，也启动10个“读线程”，从BoundedBuffer中不断的读数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Condition简介&quot;&gt;&lt;a href=&quot;#Condition简介&quot; class=&quot;headerlink&quot; title=&quot;Condition简介&quot;&gt;&lt;/a&gt;Condition简介&lt;/h1&gt;&lt;p&gt;　　Condition 的作用是&lt;strong&gt;对锁进行更精确的控制
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="JUC" scheme="https://enpong.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步状态的获取和释放</title>
    <link href="https://enpong.github.io/2019/04/20/AQS%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE/"/>
    <id>https://enpong.github.io/2019/04/20/AQS同步状态的获取和释放/</id>
    <published>2019-04-20T12:13:12.000Z</published>
    <updated>2019-11-05T07:49:07.049Z</updated>
    
    <content type="html"><![CDATA[<p>AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：<font color="blue">独占式获取和释放同步状态</font>、<font color="pink">共享式获取和释放同步状态</font>、<font color="brown">查询同步队列中的等待线程情况</font>。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。</p><h5 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h5><p>　　独占式，同一时刻仅有一个线程持有同步状态。</p><h6 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="　　独占式同步状态获取"></a>　　独占式同步状态获取</h6><hr><p> 　　<code>acquire(int arg)</code>方法为 AQS 提供的模板方法，该方法为独占式获取同步状态，但是该方法<strong>对中断不敏感</strong>，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个方法定义如下：</p><ol><li><code>tryAcquire</code>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</li><li><code>addWaiter</code>：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><code>acquireQueued</code>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt</code>：产生一个中断。</li></ol><p>acquireQueued 方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//中断标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 自旋过程，其实就是一个死循环而已</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//当前线程的前驱节点是头结点，且同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取失败，线程等待--具体后面介绍</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p><ol><li>保持FIFO同步队列原则。</li><li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li></ol><p>acquire(int arg) 方法流程图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS同步状态的获取和释放/1.png"></p><h6 id="独占式获取响应中断"><a href="#独占式获取响应中断" class="headerlink" title="　　独占式获取响应中断"></a>　　独占式获取响应中断</h6><hr><p>　　AQS 提供了 acquire(int arg) 方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS 提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常 nterruptedException 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　首先校验该线程是否已经中断了，如果是则抛出 InterruptedException ，否则执行 tryAcquire(int arg) 方法获取同步状态，如果获取成功，则直接返回，否则执行<code>doAcquireInterruptibly(int arg)</code>。doAcquireInterruptibly(int arg) 定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　doAcquireInterruptibly(int arg) 方法与 acquire(int arg) 方法仅有两个差别。1.方法声明抛出 InterruptedException 异常；2.在中断方法处不再是使用 interrupted 标志，而是直接抛出 InterruptedException 异常。</p><h6 id="独占式超时获取"><a href="#独占式超时获取" class="headerlink" title="　　独占式超时获取"></a>　　独占式超时获取</h6><hr><p>　　AQS 除了提供上面两个方法外，还提供了一个增强版的方法：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为 acquireInterruptibly 方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回 false ，否则返回 true 。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　tryAcquireNanos(int arg, long nanosTimeout) 方法超时获取最终是在 doAcquireNanos(int arg, long nanosTimeout) 中实现的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//nanosTimeout &lt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">//新增Node节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//获取同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 获取失败，做超时、中断判断</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//重新计算需要休眠的时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//已经超时，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//如果没有超时，则等待nanosTimeout纳秒</span></span><br><span class="line">            <span class="comment">//注：该线程会直接从LockSupport.parkNanos中返回，</span></span><br><span class="line">            <span class="comment">//LockSupport为JUC提供的一个阻塞和唤醒的工具类，后面做详细介绍</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">//线程是否已经中断了</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　针对超时控制，程序首先记录唤醒时间 deadline  ，deadline = System.nanoTime() + nanosTimeout（时间间隔）。如果获取同步状态失败，则需要计算出需要休眠的时间间隔nanosTimeout（= deadline - System.nanoTime()），如果 nanosTimeout &lt;= 0 表示已经超时了，返回false，如果大于 spinForTimeoutThreshold（1000L） 则需要休眠 nanosTimeout  ，如果nanosTimeout &lt;= spinForTimeoutThreshold ，就不需要休眠了，直接进入快速自旋的过程。原因在于 spinForTimeoutThreshold 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让nanosTimeout 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。</p><p>　　整个流程如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS同步状态的获取和释放/2.png"></p><h6 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="　　独占式同步状态释放"></a>　　独占式同步状态释放</h6><hr><p>　　 当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS 提供了 release(int arg) 方法释放同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法同样是先调用自定义同步器自定义的 tryRelease(int arg) 方法来释放同步状态，释放成功后，会调用 unparkSuccessor(Node node) 方法唤醒后继节点。</p><p><strong>总结一下</strong>：</p><p>　　在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的队尾并一直保持着自旋。在 CLH 同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH 同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p><h5 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h5><p>　　共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><h6 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="　共享式同步状态获取"></a>　共享式同步状态获取</h6><hr><p>　　AQS 提供 <code>acquireShared(int arg)</code>方法共享式获取同步状态：　　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//获取失败，自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上面程序可以看出，方法首先是调用 tryAcquireShared(int arg) 方法尝试获取同步状态，如果获取失败则调用<code>doAcquireShared(int arg)</code>自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。自选式获取同步状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享式节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果其前驱节点，获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//尝试获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，返回值为 int ，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。</p><p>　　acquireShared(int arg) 方法不响应中断，与独占式相似，AQS 也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，这里就不做解释了。</p><h6 id="共享式同步状态释放"><a href="#共享式同步状态释放" class="headerlink" title="　　共享式同步状态释放"></a>　　共享式同步状态释放</h6><hr><p>　　获取同步状态后，需要调用<code>release(int arg)</code>方法释放同步状态，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：&lt;font color=&quot;blue&quot;&gt;独占式获取和释放同步状态&lt;/font&gt;、&lt;font colo
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="JUC" scheme="https://enpong.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>AQS简介</title>
    <link href="https://enpong.github.io/2019/04/20/AQS%E7%AE%80%E4%BB%8B/"/>
    <id>https://enpong.github.io/2019/04/20/AQS简介/</id>
    <published>2019-04-20T11:35:17.000Z</published>
    <updated>2019-11-05T07:50:07.458Z</updated>
    
    <content type="html"><![CDATA[<h5 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h5><p>　　AQS，<code>AbstractQueuedSynchronizer</code>，即<strong>队列同步器</strong>。它是构建锁或者其他同步组件的基础框架（如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code>等），JUC 并发包的作者（ Doug Lea ）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。</p><p>　　AQS 解决了在实现同步器时涉及到的大量细节问题，例如<font color="green">获取同步状态、 FIFO 同步队列</font>。基于 AQS 来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>　　在基于 AQS 构建的同步器中，<font color="brown">只能在一个时刻发生阻塞</font>，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中所有基于 AQS 构建的同步器均可以获得这个优势。</p><p>　　AQS 的主要使用方式是<strong>继承</strong>，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>　　AQS 使用一个 int 类型的成员变量 state 来表示同步状态，当 state &gt; 0 时表示已经获取了锁，当 state = 0 时表示释放了锁。它提供了三个方法（ getState() 、setState(int newState) 、compareAndSetState(int expect,int update)）来对同步状态 state 进行操作，当然 AQS 可以确保对 state 的操作是安全的。</p><p>　　AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态（锁）失败时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><h5 id="AQS方法"><a href="#AQS方法" class="headerlink" title="AQS方法"></a>AQS方法</h5><ul><li><code>getState()</code>：返回同步状态的当前值；</li><li><code>setState(int newState)</code>：设置当前同步状态；</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li><li><code>tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li><li><code>tryRelease(int arg)</code>：独占式释放同步状态；</li><li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li><li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态；</li><li><code>isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li><li><code>acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li><li><code>acquireInterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li><li><code>tryAcquireNanos(int arg,long nanos)</code>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li><li><code>acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li><li><code>acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断；</li><li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制；</li><li><code>release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li><li><code>releaseShared(int arg)</code>：共享式释放同步状态；</li></ul><h5 id="CLH同步队列"><a href="#CLH同步队列" class="headerlink" title="CLH同步队列"></a>CLH同步队列</h5><p>　　CLH 同步队列是一个 FIFO 双向队列，AQS 依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS 则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到 CLH 同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>　　在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 共享 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** 独占 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示下一次共享式同步状态获取将会无条件地传播下去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">/** 等待状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">/** 前驱节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">/** 后继节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">/** 获取同步状态的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLH同步队列结构图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS简介/1.png"></p><h6 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h6><p>　　学了数据结构的我们，CLH 队列入列是再简单不过了，无非就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。代码我们可以看看addWaiter(Node node)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多次尝试</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　addWaiter(Node node) 先通过快速尝试设置尾节点，如果失败，则调用 enq(Node node) 方法设置尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//多次尝试，直到成功为止</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node t = tail;</span><br><span class="line">          <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">          <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                  tail = head;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//设置为尾节点</span></span><br><span class="line">              node.prev = t;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                  t.next = node;</span><br><span class="line">                  <span class="keyword">return</span> t;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>　　在上面代码中，两个方法都是通过一个 CAS 方法 <code>compareAndSetTail(Node expect, Node update)</code>来设置尾节点，该方法可以确保节点是线程安全添加的。在 <code>enq(Node node)</code> 方法中，AQS 通过“死循环”的方式来保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去。</p><p>过程图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS简介/2.png"></p><h6 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h6><p>　　CLH 同步队列遵循 FIFO ，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head 执行该节点并断开原首节点的 next 和当前节点的 prev 即可，注意在这个过程是不需要使用 CAS 来保证的，因为只有一个线程能够成功获取到同步状态。过程图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS简介/3.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;AQS简介&quot;&gt;&lt;a href=&quot;#AQS简介&quot; class=&quot;headerlink&quot; title=&quot;AQS简介&quot;&gt;&lt;/a&gt;AQS简介&lt;/h5&gt;&lt;p&gt;　　AQS，&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;，即&lt;strong&gt;队列同
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="JUC" scheme="https://enpong.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>线程池-tomcat</title>
    <link href="https://enpong.github.io/2019/04/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0-tomcat/"/>
    <id>https://enpong.github.io/2019/04/20/线程池-tomcat/</id>
    <published>2019-04-20T09:26:44.000Z</published>
    <updated>2019-11-05T07:50:40.230Z</updated>
    
    <content type="html"><![CDATA[<p>线程池在tomcat中的创建实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">        TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">"-exec-"</span>, daemon, getThreadPriority());</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">        taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时（重点）： <strong>tomcat 的线程池扩展了 jdk 的 executor ，而且队列用的是自己的 task queue ，因此其策略与 jdk 的有所不同，需要注意一下。</strong></p><h5 id="tomcat线程池策略"><a href="#tomcat线程池策略" class="headerlink" title="tomcat线程池策略"></a>tomcat线程池策略</h5><p>　　场景1：接受一个请求，此时 tomcat 启动的线程数还没有达到 corePoolSize ( tomcat 里头叫 minSpareThreads )， tomcat 会启动一个线程来处理该请求；</p><p>　　场景2：接受一个请求，此时 tomcat 启动的线程数已经达到了 corePoolSize ， tomcat 把该请求放入队列 (<code>offer</code>) ，如果放入队列成功，则返回，放入队列不成功，则尝试增加工作线程，在当前线程个数 &lt; maxThreads 的时候，可以继续增加线程来处理，超过 maxThreads 的时候，则继续往等待队列里头放，等待队列放不进去，则抛出 RejectedExecutionException ；</p><p>　　值得注意的是，使用 LinkedBlockingQueue 的话，默认是使用 Integer.MAX_VALUE ，即无界队列(这种情况下如果没有配置队列的 capacity 的话，队列始终不会满，那么始终无法进入开启新线程到达 maxThreads 个数的地步，则此时配置 maxThreads 其实是没有意义的)。</p><h6 id="tomcat等待队列"><a href="#tomcat等待队列" class="headerlink" title="tomcat等待队列"></a>tomcat等待队列</h6><p>　　而 TaskQueue 的队列 capacity 为 maxQueueSize ，默认也是 Integer.MAX_VALUE 。但是，<strong>其重写 offer 方法，当其线程池大小 &lt; maximumPoolSize 的时候，返回false，即在一定程度改写了队列满的逻辑</strong>，修复了使用LinkedBlockingQueue默认的 capacity为 Integer.MAX_VALUE 的时候， maxThreads 失效的 “bug” 。从而可以继续增长线程到 maxThreads ，超过之后，继续放入队列。</p><p>　　<strong>tomcat 的线程池使用了自己扩展的 taskQueue ，而不是 Executors 工厂方法里头用的 LinkedBlockingQueue 。(主要是修改了 offer 的逻辑)</strong> TaskQueue 实现的offer操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.tomcat.util.threads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">　　 <span class="keyword">private</span> ThreadPoolExecutor parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//we can't do any checks</span></span><br><span class="line">        <span class="keyword">if</span> (parent==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//we are maxed out on threads, simply queue the object</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//we have idle threads, just add it to the queue</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getSubmittedCount()&lt;(parent.getPoolSize())) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//当其线程池大小小于maximumPoolSize的时候，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//if we reached here, we need to add it to the queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="tomcat拒绝任务"><a href="#tomcat拒绝任务" class="headerlink" title="tomcat拒绝任务"></a>tomcat拒绝任务</h6><p>　　<strong>这里改写了 jdk 线程池默认的 Rejected 规则，即 catch 住了 RejectedExecutionException 。正常 jdk 的规则是 core 线程数＋临时线程数 &gt; maxSize 的时候，就抛出 RejectedExecutionException 。这里 catch 住的话，继续往 taskQueue 里头放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.tomcat.util.threads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.res.StringManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        execute(command,<span class="number">0</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        submittedCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.execute(command);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">                <span class="keyword">final</span> TaskQueue queue = (TaskQueue)<span class="keyword">super</span>.getQueue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                        submittedCount.decrementAndGet();</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity is full."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    Thread.interrupted();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> rx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下 queue.force 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">force</span><span class="params">(Runnable o, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( parent.isShutdown() ) <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Executor not running, can't force a command into the queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task is rejected</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　注意的是这里调用的 super.offer(o,timeout,unit) ，即 LinkedBlockingQueue ，只有当队列满的时候，返回 false ，才会抛出重新抛出 RejectedExecutionException 。</p><p>　　<strong>这里改变了 jdk 的 ThreadPoolExecutor 的 RejectedExecutionException 抛出的逻辑，也就是超出了 maxThreads 不会抛出 RejectedExecutionException ，而是继续往队列丢任务，而 taskQueue 本身是无界的，因此可以默认几乎不会抛出 RejectedExecutionException </strong></p><h5 id="回顾-JDK-线程池策略"><a href="#回顾-JDK-线程池策略" class="headerlink" title="回顾 JDK 线程池策略　"></a>回顾 JDK 线程池策略　</h5><ul><li>每次提交任务时，如果线程数还没达到 coreSize 就创建新线程并绑定该任务。所以第 coreSize 次提交任务后线程总数必达到 coreSize ，不会重用之前的空闲线程。</li><li>线程数达到 coreSize 后，新增的任务就放到工作队列里，而线程池里的线程则努力的使用 take() 从工作队列里拉活来干。</li><li>如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。</li><li>临时线程使用 poll(keepAliveTime，timeUnit) 来从工作队列拉活，如果时候到了仍然两手空空没拉到活，表明它太闲了，就会被解雇掉。</li><li>如果 core 线程数＋临时线程数  &gt; maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder 。默认的 AbortPolicy 抛 RejectedExecutionException 异常，其他选择包括静默放弃当前任务(Discard)，放弃工作队列里最老的任务(DisacardOldest)，或由主线程来直接执行(CallerRuns).</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>tomcat 的线程池与 jdk 的使用无界 LinkedBlockingQueue 主要有如下两点区别：</p><p>举个例子：假设队列大小为 10，corePoolSize 为 3，maximumPoolSize 为 6，那么当加入 20 个任务时</p><table><thead><tr><th>jdk有界执行任务过程</th><th></th></tr></thead><tbody><tr><td>核心线程(3)</td><td>1、2、3</td></tr><tr><td>等待队列(10)</td><td>4、5、6、… 12、13</td></tr><tr><td>非核心线程(3)</td><td>14、15、16</td></tr><tr><td>拒绝任务</td><td>17、18、19、20</td></tr><tr><td>任务执行顺序</td><td>1、2、3、14、15、16、4、5、6、… 12、13</td></tr></tbody></table><table><thead><tr><th>tomcat执行任务过程</th><th></th></tr></thead><tbody><tr><td>核心线程</td><td>1、2、3</td></tr><tr><td>等待队列（无界)</td><td>7、8、9、… 19、20</td></tr><tr><td>非核心线程</td><td>4、5、6</td></tr><tr><td>拒绝任务</td><td></td></tr><tr><td>任务执行顺序</td><td>1、2、3、4、5、6、… 19、20</td></tr></tbody></table><ul><li>ThreadPoolExecutor 的线程池增长策略是：<ul><li>如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。</li><li>而 tomcat 的 ThreadPoolExecutor 使用的 taskQueue ，是无界的 LinkedBlockingQueue ，但是通过 taskQueue 的 offer 方法覆盖了 LinkedBlockingQueue 的 offer 方法，改写了规则，使得它也走 jdk 的 ThreadPoolExecutor 的有界队列的线程增长策略。</li></ul></li><li>ThreadPoolExecutor 拒绝任务策略：<ul><li>jdk ，当 core线程数＋临时线程数 &gt; maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder 。</li><li>而 tomcat 的ThreadPoolExecutor 则改写了这个规则，即 catch 住了 RejectExecutionHanlder ，继续往队列里头放，直到队列满了才抛出 RejectExecutionHanlder 。而默认 taskQueue 是无界的。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程池在tomcat中的创建实现为：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="tomcat" scheme="https://enpong.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://enpong.github.io/2019/04/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://enpong.github.io/2019/04/20/线程池/</id>
    <published>2019-04-20T08:44:09.000Z</published>
    <updated>2019-11-05T07:50:28.501Z</updated>
    
    <content type="html"><![CDATA[<p>　　JAVA语言为我们提供了两种基础线程池的选择：<code>ScheduledThreadPoolExecutor</code>和<code>ThreadPoolExecutor</code>。它们都实现了<code>ExecutorService</code>接口<font color="green">（注意，ExecutorService接口本身和“线程池”并没有直接关系，它的定义更接近“执行器”，而“使用线程管理的方式进行实现”只是其中的一种实现方式）</font>。这篇文章中，我们主要围绕 ThreadPoolExecutor 类进行讲解。</p><h5 id="ThreadPoolExecutor的构造方法"><a href="#ThreadPoolExecutor的构造方法" class="headerlink" title="ThreadPoolExecutor的构造方法"></a>ThreadPoolExecutor的构造方法</h5><h6 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||  maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　构造函数中需要传入的参数包括<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>keepAliveTime</code>、<code>timeUnit</code>和<code>workQueue</code>。要明确理解这些参数（和后续将要介绍的参数）的含义，就首先要搞清楚 ThreadPoolExecutor 线程池的逻辑结构。</p><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/1.jpg"></div><p>　　一定要注意一个概念，即<font color="pink">存在于线程池中容器的一定是 Thread 对象，而不是您要求运行的任务</font>（所以叫线程池而不叫任务池也不叫对象池，更不叫游泳池）；您要求运行的任务将被线程池分配给某一个空闲的 Thread 运行。从上图中，我们可以看到构成线程池的几个重要元素：</p><ul><li><strong>等待队列</strong>：顾名思义，就是您调用线程池对象的 submit() 方法或者 execute() 方法，要求线程池运行的任务（这些任务必须实现 Runnable 接口或者 Callable 接口）。但是出于某些原因线程池并没有马上运行这些任务，而是送入一个队列等待执行。</li><li><strong>核心线程</strong>：线程池主要用于执行任务的是“核心线程”，“核心线程”的数量是您创建线程时所设置的 corePoolSize 参数决定的。如果不进行特别的设定，线程池中始终会保持 corePoolSize 数量的线程数（不包括创建阶段）。</li><li><strong>非核心线程</strong>：一旦任务数量过多（由等待队列的特性决定），线程池将创建“非核心线程”临时帮助运行任务。您设置的大于 corePoolSize 参数小于 maximumPoolSize 参数的部分，就是线程池可以临时创建的“非核心线程”的最大数量。<font color="pink">这种情况下如果某个线程没有运行任何任务，在等待 keepAliveTime 时间后，这个线程将会被销毁，直到线程池的线程数量重新达到corePoolSize</font>。<font color="blue">也就是说，并不是所谓的“非核心线程”才会被回收；而是谁的空闲时间达到 keepAliveTime 这个阀值，就会被回收。直到线程池中线程数量等于 corePoolSize 为止</font>。</li><li>maximumPoolSize 参数也是当前线程池允许创建的最大线程数量。那么如果您设置的 corePoolSize 参数和您设置的 maximumPoolSize 参数一致时，线程池在任何情况下都不会回收空闲线程。 keepAliveTime 和 timeUnit 也就失去了意义。</li><li>keepAliveTime 参数和 timeUnit 参数也是配合使用的。 keepAliveTime 参数指明等待时间的量化值， timeUnit 指明量化值单位。例如 keepAliveTime=1，timeUnit 为 TimeUnit.MINUTES ，代表空闲线程的回收阀值为1分钟。</li></ul><h6 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h6><ul><li><p>CachedThreadPool：一个任务创建一个线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>FixedThreadPool：所有任务只能使用固定大小的线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="完整的任务处理过程"><a href="#完整的任务处理过程" class="headerlink" title="完整的任务处理过程"></a>完整的任务处理过程</h6><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/2.jpg"></div><p>　　1、首先您可以通过线程池提供的 submit() 方法或者 execute() 方法，要求线程池执行某个任务。线程池收到这个要求执行的任务后，会有几种处理情况：</p><p>　　　　1.1、如果当前线程池中运行的线程数量还没有达到 corePoolSize 大小时，线程池会创建一个新的线程运行您的任务，<font color="red">无论之前已经创建的线程是否处于空闲状态</font>。</p><p>　　　　1.2、如果当前线程池中运行的线程数量已经达到设置的 corePoolSize 大小，线程池会把您的这个任务加入到等待队列中。直到某一个的线程空闲了，线程池会根据您设置的等待队列规则，从队列中取出一个新的任务执行。</p><p>　　　　1.3、<font color="red">如果根据队列规则，这个任务无法加入等待队列。这时线程池就会创建一个“非核心线程”直接运行这个任务</font>。注意，如果这种情况下任务执行成功，那么当前线程池中的线程数量一定大于 corePoolSize 。</p><p>　　　　1.4、如果这个任务，无法被“核心线程”直接执行，又无法加入等待队列，又无法创建“非核心线程”直接执行，且您没有为线程池设置<code>RejectedExecutionHandler</code>。这时线程池会抛出 RejectedExecutionException 异常，即线程池拒绝接受这个任务。（<font color="red">实际上抛出 RejectedExecutionException 异常的操作，是 ThreadPoolExecutor 线程池中一个默认的 RejectedExecutionHandler 实现：<code>AbortPolicy</code></font>）</p><p>　　2、一旦线程池中某个线程完成了任务的执行，它就会试图到任务等待队列中拿去下一个等待任务（所有的等待任务都实现了<code>BlockingQueue</code>接口，按照接口字面上的理解，这是一个可阻塞的队列接口），它会调用等待队列的 poll() 方法，并停留在哪里。</p><p>　　3、当线程池中的线程超过您设置的 corePoolSize 参数，说明当前线程池中有所谓的“非核心线程”。那么当某个线程处理完任务后，如果等待 keepAliveTime 时间后仍然没有新的任务分配给它，那么这个线程将会被回收。线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于您设置的 corePoolSize 参数时，回收过程才会停止，还有回收的前提条件是线程数大于 corePoolSize。</p><h5 id="allowCoreThreadTimeOut"><a href="#allowCoreThreadTimeOut" class="headerlink" title="allowCoreThreadTimeOut"></a>allowCoreThreadTimeOut</h5><p>　　前文我们讨论到，线程池回收线程只会发生在当前线程池中线程数量大于 corePoolSize 参数的时候；当线程池中线程数量小于等于 corePoolSize 参数的时候，回收过程就会停止。 allowCoreThreadTimeOut 设置项可以要求线程池：将包括“核心线程”在内的，没有任务分配的任何线程，在等待 keepAliveTime 时间后全部进行回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>));</span><br><span class="line">poolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h5 id="prestartAllCoreThreads"><a href="#prestartAllCoreThreads" class="headerlink" title="prestartAllCoreThreads"></a>prestartAllCoreThreads</h5><p>　　前文我们还讨论到，当线程池中的线程还没有达到您设置的 corePoolSize 参数值的时候，如果有新的任务到来，线程池将创建新的线程运行这个任务，无论之前已经创建的线程是否处于空闲状态。这个描述可以用下面的示意图表示出来：</p><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/3.jpg"></div><p>　　<code>prestartAllCoreThreads</code>设置项，可以在线程池创建，但还没有接收到任何任务的情况下，先行创建符合 corePoolSize 参数值的线程数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>));</span><br><span class="line">poolExecutor.prestartAllCoreThreads();</span><br></pre></td></tr></table></figure><h5 id="使用ThreadFactory"><a href="#使用ThreadFactory" class="headerlink" title="使用ThreadFactory"></a>使用ThreadFactory</h5><p> 　　线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在 ThreadPoolExecutor 线程池中，创建线程的工作交给<code>ThreadFactory</code>来完成。<font color="sandybrown">要使用线程池，就必须要指定ThreadFactory</font>。</p><p>　　 如果我们使用的构造函数时并没有指定使用的 ThreadFactory ，这个时候 ThreadPoolExecutor 会使用一个默认的 ThreadFactory：<code>DefaultThreadFactory</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.thread.pool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试自定义的一个线程工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something before new thread created;</span></span><br><span class="line">        <span class="comment">// create new thread ， and return</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程池的等待队列"><a href="#线程池的等待队列" class="headerlink" title="线程池的等待队列"></a>线程池的等待队列</h5><p>　　在使用 ThreadPoolExecutor 线程池的时候，需要指定一个实现了 BlockingQueue接口的任务等待队列。在 ThreadPoolExecutor 线程池的 API 文档中，一共推荐了三种等待队列，它们是：<code>SynchronousQueue</code>、<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>；但通过观察 BlockingQueue 接口的实现情况，您可以发现，能够直接使用的等待队列还有：<code>PriorityBlockingQueue</code>、<code>LinkedBlockingDeque</code>和<code>LinkedTransferQueue</code>。</p><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/4.jpg"></div><h6 id="有限队列"><a href="#有限队列" class="headerlink" title="有限队列"></a>有限队列</h6><ul><li><p><code>SynchronousQueue</code>： 一种阻塞队列，其中每个 put 必须等待一个 take，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。即这是<font color="palegoldenrod">一个内部没有任何容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行插入操作的线程就要一直等待，反之亦然</font>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;Object&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;Object&gt;();</span><br><span class="line"><span class="comment">// 不要使用add，因为这个队列内部没有任何容量，所以会抛出异常“IllegalStateException”</span></span><br><span class="line"><span class="comment">// queue.add(new Object());</span></span><br><span class="line"><span class="comment">// 操作线程会在这里被阻塞，直到有其他操作线程取走这个对象</span></span><br><span class="line">queue.put(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>ArrayBlockingQueue</code>：一个由数组支持的有界阻塞队列。此队列按  FIFO （先进先出）原则对元素进行排序。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。<font color="red">一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞</font>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们创建了一个ArrayBlockingQueue，并且设置队列空间为2</span></span><br><span class="line">ArrayBlockingQueue&lt;Object&gt; arrayQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Object&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 插入第一个对象</span></span><br><span class="line">arrayQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第二个对象</span></span><br><span class="line">arrayQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第三个对象时，这个操作线程就会被阻塞。</span></span><br><span class="line">arrayQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 请不要使用add操作，和SynchronousQueue的add操作一样，它们都使用了AbstractQueue中的add实现</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="无限队列"><a href="#无限队列" class="headerlink" title="无限队列"></a>无限队列</h6><ul><li><p><code>LinkedBlockingQueue</code>： 在 ThreadPoolExecutor 线程池中常应用的等待队列。它可以指定容量也可以不指定容量。由于它具有“无限容量”的特性，所以我还是将它归入了无限队列的范畴（实际上任何无限容量的队列/栈都是有容量的，这个容量就是 Integer.MAX_VALUE ）。 LinkedBlockingQueue 的实现是基于链表结构，而不是类似 ArrayBlockingQueue 那样的数组。但实际使用过程中，您不需要关心它的内部实现，如果您指定了 LinkedBlockingQueue 的容量大小，那么它反映出来的使用特性就和 ArrayBlockingQueue 类似了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue&lt;Object&gt; linkedQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;(<span class="number">2</span>);</span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第二个对象</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第三个对象时，这个操作线程就会被阻塞。</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">=======================================</span><br><span class="line"><span class="comment">// 或者如下使用：</span></span><br><span class="line">LinkedBlockingQueue&lt;Object&gt; linkedQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第二个对象</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第N个对象时，都不会阻塞</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure></li><li><p><code>LinkedBlockingDeque</code>：一个基于链表的双端队列。 LinkedBlockingQueue 的内部结构决定了它只能从队列尾部插入，从队列头部取出元素；但是 LinkedBlockingDeque 既可以从尾部插入/取出元素，还可以从头部插入元素/取出元素。</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingDeque&lt;TempObject&gt; linkedDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;TempObject&gt;();</span><br><span class="line"><span class="comment">// push ，可以从队列的头部插入元素</span></span><br><span class="line">linkedDeque.push(<span class="keyword">new</span> TempObject(<span class="number">1</span>));</span><br><span class="line">linkedDeque.push(<span class="keyword">new</span> TempObject(<span class="number">2</span>));</span><br><span class="line">linkedDeque.push(<span class="keyword">new</span> TempObject(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// poll ， 可以从队列的头部取出元素</span></span><br><span class="line">TempObject tempObject = linkedDeque.poll();</span><br><span class="line"><span class="comment">// 这里会打印 tempObject.index = 3</span></span><br><span class="line">System.out.println(<span class="string">"tempObject.index = "</span> + tempObject.getIndex());</span><br><span class="line"></span><br><span class="line"><span class="comment">// put ， 可以从队列的尾部插入元素</span></span><br><span class="line">linkedDeque.put(<span class="keyword">new</span> TempObject(<span class="number">4</span>));</span><br><span class="line">linkedDeque.put(<span class="keyword">new</span> TempObject(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// pollLast , 可以从队列尾部取出元素</span></span><br><span class="line">tempObject = linkedDeque.pollLast();</span><br><span class="line"><span class="comment">// 这里会打印 tempObject.index = 5</span></span><br><span class="line">System.out.println(<span class="string">"tempObject.index = "</span> + tempObject.getIndex());</span><br></pre></td></tr></table></figure><ul><li><p><code>PriorityBlockingQueue</code>： 一个按照优先级进行内部元素排序的无限队列。存放在 PriorityBlockingQueue 中的元素必须实现 Comparable 接口，这样才能通过实现 compareTo() 方法进行排序。优先级最高的元素将始终排在队列的头部；<font color="red"> PriorityBlockingQueue 不会保证优先级一样的元素的排序，也不保证当前队列中除了优先级最高的元素以外的元素，随时处于正确排序的位置</font>。</p></li><li><p><code>LinkedTransferQueue</code>：一个无限队列，它除了具有一般队列的操作特性外（先进先出），还具有一个<strong>阻塞特性</strong>： LinkedTransferQueue 可以由一对生产者/消费者线程进行操作，当消费者将一个新的元素插入队列后，消费者线程将会一直等待，直到某一个消费者线程将这个元素取走，反之亦然。</p></li></ul><h5 id="拒绝任务"><a href="#拒绝任务" class="headerlink" title="　　拒绝任务"></a>　　拒绝任务</h5><p>　　在 ThreadPoolExecutor 线程池中还有一个重要的接口：<code>RejectedExecutionHandler</code>。<strong>当提交给线程池的某一个新任务无法直接被线程池中“核心线程”直接处理，又无法加入等待队列，也无法创建新的线程执行；又或者线程池已经调用 shutdown() 方法停止了工作；又或者线程池不是处于正常的工作状态；这时候 ThreadPoolExecutor 线程池会拒绝处理这个任务，触发您创建 ThreadPoolExecutor 线程池时定义的 RejectedExecutionHandler 接口的实现。</strong></p><p>　　ThreadPoolExecutor线程池在创建时，会使用一个默认的 RejectedExecutionHandler 接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default rejected execution handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">        <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看到，ThreadPoolExecutor中的两个没有指定RejectedExecutionHandler</span></span><br><span class="line">    <span class="comment">// 接口的构造函数，都是使用了一个RejectedExecutionHandler接口的默认实现：AbortPolicy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　实际上，在 ThreadPoolExecutor 中已经提供了四种可以直接使用的 RejectedExecutionHandler 接口的实现：</p><ul><li><code>CallerRunsPolicy</code>：这个拒绝处理器，将直接运行这个任务的 run 方法。但是，请注意并不是在 ThreadPoolExecutor 线程池中的线程中运行，而是直接调用这个任务实现的 run 方法。</li><li><code>AbortPolicy</code>：这个处理器，在任务被拒绝后会创建一个 RejectedExecutionException 异常并抛出。这个处理过程也是 ThreadPoolExecutor 线程池默认的 RejectedExecutionHandler 实现。</li><li><code>DiscardPolicy</code> ： DiscardPolicy处理器，将会<strong>默默丢弃</strong>这个被拒绝的任务，不会抛出异常，也不会通过其他方式执行这个任务的任何一个方法，更不会出现任何的日志提示。</li><li><code>DiscardOldestPolicy</code>：这个处理器很有意思。它会检查当前ThreadPoolExecutor线程池的等待队列。并调用队列的 poll() 方法，将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。</li></ul><blockquote><p>　    CallerRunsPolicy 在非线程池以外直接调用任务的 run 方法，可能会造成线程安全上的问题；</p><p>​    DiscardPolicy 默默的忽略掉被拒绝任务，也没有输出日志或者提示，开发人员不会知道线程池的处理过程出现了错误；</p><p>​    DiscardOldestPolicy 中 e.getQueue().poll() 的方式好像是科学的，但是如果等待队列出现了容量问题，大多数情况下就是这个线程池的代码出现了 BUG 。</p><p>​    <strong>最科学的的还是 AbortPolicy 提供的处理方式：抛出异常，由开发人员进行处理</strong>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　JAVA语言为我们提供了两种基础线程池的选择：&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;和&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。它们都实现了&lt;code&gt;ExecutorService&lt;/code&gt;接口&lt;fo
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/java/JUC/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>spring AOP</title>
    <link href="https://enpong.github.io/2019/04/20/spring-AOP/"/>
    <id>https://enpong.github.io/2019/04/20/spring-AOP/</id>
    <published>2019-04-20T07:13:02.000Z</published>
    <updated>2019-11-05T07:51:00.020Z</updated>
    
    <content type="html"><![CDATA[<h5 id="存在的意义"><a href="#存在的意义" class="headerlink" title="存在的意义"></a>存在的意义</h5><blockquote><p>面向对象编程（ OOP ）有一些弊端，当需要为多个不具有继承关系的对象引人同一个公共行为时，例如日志、安全检测等，我们只有在每个对象里引用公共行为，这样程序中就产生了大量的重复代码，程序就不便于维护了，所以就有了一个对面向对象编程的补充，即面向方面编程（ AOP ), AOP 所关注的方向是横向的，不同于OOP 的纵向。</p></blockquote><h5 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h5><ol><li>通知<code>Advice</code>：你想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下 ；</li><li>连接点<code>JoinPoint</code>：spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的钱、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点 ；</li><li>切入点<code>PoinCut</code>：你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法 ；</li><li>切面<code>Aspect</code>：通知和切入点的结合 ，通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义 ；</li><li>织入<code>Weaving</code>：切面应用到目标对象来创建新的代理对象的过程 。</li></ol><h5 id="常用的AOP"><a href="#常用的AOP" class="headerlink" title="常用的AOP"></a>常用的AOP</h5><p><code>AspectJ</code>、<code>JBossAOP</code>、<code>SpringAOP</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;存在的意义&quot;&gt;&lt;a href=&quot;#存在的意义&quot; class=&quot;headerlink&quot; title=&quot;存在的意义&quot;&gt;&lt;/a&gt;存在的意义&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;面向对象编程（ OOP ）有一些弊端，当需要为多个不具有继承关系的对象引人同一个公共行为时
      
    
    </summary>
    
      <category term="后端" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="spring" scheme="https://enpong.github.io/tags/spring/"/>
    
      <category term="AOP" scheme="https://enpong.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>spring IOC</title>
    <link href="https://enpong.github.io/2019/04/20/spring-IOC/"/>
    <id>https://enpong.github.io/2019/04/20/spring-IOC/</id>
    <published>2019-04-20T06:45:13.000Z</published>
    <updated>2019-11-05T07:51:14.909Z</updated>
    
    <content type="html"><![CDATA[<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>spring ioc是spring的特性，称为控制反转。将对象的创建、初始化和销毁交由容器管理。实现方式有依赖查找和依赖注入。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在spring容器启动的时候，通过反射的方式，主动加载（或延迟加载）我们主动配置的bean以及该bean的依赖对象。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>在不同的业务之间的相互调用，我们无需去关注业务对象的产生。而更注重业务之间的逻辑，这在复杂工程中显得尤为重要。 </p><h5 id="spring构造对象的三种方法"><a href="#spring构造对象的三种方法" class="headerlink" title="spring构造对象的三种方法"></a>spring构造对象的三种方法</h5><ol><li><p>采用默认的构造函数创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mc.base.learn.spring.bean.Person"</span> <span class="attr">id</span>=<span class="string">"person"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>静态工厂创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"com.mc.base.learn.spring.factory.PersonStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createPerson"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>实例化工厂</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   　　<span class="comment">&lt;!-- 实例工程方法需要先创建工厂实例，然后在创建所需对象的时候，将其赋值为factory-bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personFactory"</span> <span class="attr">class</span>=<span class="string">"com.mc.base.learn.spring.factory.PersonFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">factory-bean</span>=<span class="string">"personFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="spring初始化的三种方式"><a href="#spring初始化的三种方式" class="headerlink" title="spring初始化的三种方式"></a>spring初始化的三种方式</h5><ol><li>通过实现 <code>InitializingBean/DisposableBean</code> 接口来定制初始化之后/销毁之前的操作方法； </li><li>通过<code>&lt;bean&gt;</code>元素的<code>init-method/destroy-method</code>属性指定初始化之后 /销毁之前调用的操作方法； </li><li>在指定方法上加上@PostConstruct 或@PreDestroy注解来制定该方法是在初始化之后还是销毁之前调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h5&gt;&lt;p&gt;spring ioc是spring的特性，称为控制反转。将对象的创建、初始化和销毁交由容器管理。实现方式有依赖查找和依赖注入。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="后端" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://enpong.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="spring" scheme="https://enpong.github.io/tags/spring/"/>
    
      <category term="IOC" scheme="https://enpong.github.io/tags/IOC/"/>
    
  </entry>
  
</feed>
