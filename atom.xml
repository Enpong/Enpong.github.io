<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enpong</title>
  
  <subtitle>成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://enpong.github.io/"/>
  <updated>2019-04-17T16:51:30.699Z</updated>
  <id>https://enpong.github.io/</id>
  
  <author>
    <name>Enpong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://enpong.github.io/2019/04/18/二维数组中的查找/</id>
    <published>2019-04-17T16:36:41.000Z</published>
    <updated>2019-04-17T16:51:30.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。</p><p>该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><div align="center"> <img src="//enpong.github.io/2019/04/18/二维数组中的查找/4.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = col-<span class="number">1</span>;<span class="comment">//从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span>(r&lt;=row-<span class="number">1</span> &amp;&amp; c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == matrix[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://enpong.github.io/2019/04/18/数组中重复的数字/</id>
    <published>2019-04-17T16:10:37.000Z</published>
    <updated>2019-04-17T16:30:22.058Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 </p><blockquote><p>Input:{2, 3, 1, 0, 2, 5}</p><p>Output:2</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。</p><p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><div align="center"> <img src="//enpong.github.io/2019/04/18/数组中重复的数字/3.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplicatin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[j] = nums[i];</span><br><span class="line">    nums[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="重复" scheme="https://enpong.github.io/tags/%E9%87%8D%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>leetcode---241. 为运算表达式设计优先级</title>
    <link href="https://enpong.github.io/2019/03/22/leetcode---241.%20%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://enpong.github.io/2019/03/22/leetcode---241. 为运算表达式设计优先级/</id>
    <published>2019-03-22T07:39:51.000Z</published>
    <updated>2019-04-09T07:59:26.071Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88742790" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88742790</a></p><p>回溯搜索。该问题牵涉到括号的组合问题，一般使用递归+回溯的思想。主要想法：</p><ul><li>递归回溯。可以产生所有的组合方式。 </li><li>每个小组合方式相当于一个子集，不断的将计算结果返回给上一层。 </li></ul><p>举例：a + (b - (c <em> d))会不断的变成a + (b - (res1 </em> res2))-&gt; a + (res1 - res2) -&gt; res1</p><ul><li>res2</li></ul><p>计算结果需要for循环！！！其实有这种情况，a + (b - (c <em> d))和a + (b - c) </em> d))，这里 a +<br>res2，res2就可能有多种情况。</p><pre><code>class Solution {    public List&lt;Integer&gt; diffWaysToCompute(String input) {        List&lt;Integer&gt; ways = new ArrayList&lt;&gt;();        for(int i=0; i&lt;input.length(); i++){            char c = input.charAt(i);            if(c==&apos;+&apos; || c==&apos;-&apos; || c==&apos;*&apos;){                List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0, i));                List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+1));                for(Integer l : left){                    for(Integer r : right){                        switch(c){                            case &apos;+&apos;:                                ways.add(l+r);                                break;                            case &apos;-&apos;:                                ways.add(l-r);                                break;                            case &apos;*&apos;:                                ways.add(l*r);                                break;                        }                    }                }            }        }        if(ways.size()==0)            ways.add(Integer.valueOf(input));        return ways;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88742790&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
    
      <category term="undefined" scheme="https://enpong.github.io/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>leetcode---二分查找</title>
    <link href="https://enpong.github.io/2019/03/22/leetcode---%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://enpong.github.io/2019/03/22/leetcode---二分查找/</id>
    <published>2019-03-22T07:10:34.000Z</published>
    <updated>2019-04-09T07:59:25.746Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88741847" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88741847</a></p><pre><code>//二分查找基本实现public int binarySearch(int[] nums, int key){    int l = 0, h = nums.length-1;    while(l&lt;=h){        int mid = l+(h-l)/2;  //防止(h+l)/2加法溢出        if(nums[mid]==key)            return mid;        else if(nums[mid]&gt;key)            h = mid-1;        else            l = mid+1;    }    return -1;}/** * 变种二分查找，找出数组中key重复元素最左位置(注意边界) */public int binarySearch(int[] nums, int key){    int l=0, h=nums.length-1;    while(l&lt;h){        int mid = l+(h-l)/2;        if(nums[mid]&gt;=key)            h = mid;        else            l = mid+1;    }    if(nums[l]==key)        return l;    else         return -1;}//求开方   69. Sqrt(x) (Easy)public int mySqrt(int x){    if(x&lt;=1)        return x;    int l=1,h=x;    while(l&lt;=h){        int mid = l+(h-l)/2;        int sqrt = x/mid;        if(sqrt==mid)            return mid;        else if(mid&gt;sqrt)            h = mid-1;        else            l = mid+1;    }    return h;}//给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符//744. Find Smallest Letter Greater Than Target (Easy)public char nextGreatestLetter(char[] letters, char target){    int l=0, h=letters.length-1;    while(l&lt;=h){        int mid = l+(h-l)/2;        if(letters[mid]&lt;=target)            l = mid+1;        else            h = mid-1;    }    return l&lt;letters.length ? letters[l] : letters[0];}//以O(logN)时间复杂度找出有序数组中唯一不出现2次的元素//540. Single Element in a Sorted Array (Medium)//假设index是该元素所在位置，mid是偶数，则当(mid+1&lt;index)时，nums[m]==nums[m+1];//当(mid+1&gt;=index),nums[m]!=nums[m+1]//因此，m为偶数的情况下，当nums[m]==nums[m+1],index所在区间应该为[m+2,h];否则，index在[l,m];public int singleNonDuplicate(int[] nums){    int l=0, h=nums.length-1;    while(l&lt;h){        int mid = l+(h-l)/2;        if(mid%2==1)            mid--; //保证mid是偶数        if(nums[mid]==nums[mid+1)            l = m+2;        else            h = m;    }    return h;}//旋转数组中的最小数字 153. Find Minimum in Rotated Sorted Array (Medium)public int findMin(int[] nums){    int l=0, h=nums.length-1;    while(l&lt;h){        int mid = l+(h-l)/2;        if(nums[mid]&lt;=nums[h])            h = mid;        else            l = mid+1;    }    return nums[l];}//查找区间，找到最左位置，找到最右位置//34. Search for a Range (Medium)public int findRange(int[] nums, int target){    int first=0, last=0;    int l=0, h=nums.length-1;    //找最左位置    while(l&lt;h){        int mid = l+(h-l)/2;        if(nums[mid]&gt;=target)            h = mid;        else            l = mid+1;    }    if(nums[l]!=target)        return new int{-1,-1};    else{        first = l;        //找最右位置        l=0, h=nums.length-1;        while(l&lt;h){            int mid = l+(h-l+1)/2;//这里mid选择向上取整，否则会死循环            if(nums[mid]&lt;=target)                l = mid;            else                h = mid-1;        }        last = h;        return new int{first, last};    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88741847&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
    
      <category term="二分查找" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---线程同步</title>
    <link href="https://enpong.github.io/2019/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://enpong.github.io/2019/03/21/操作系统---线程同步/</id>
    <published>2019-03-21T08:22:46.000Z</published>
    <updated>2019-04-09T07:59:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88718474" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88718474</a></p><h4 id="进程中线程同步的四种常用方式："><a href="#进程中线程同步的四种常用方式：" class="headerlink" title="进程中线程同步的四种常用方式："></a>进程中线程同步的四种常用方式：</h4><h6 id="临界区（CCriticalSection"><a href="#临界区（CCriticalSection" class="headerlink" title="临界区（CCriticalSection)"></a>临界区（CCriticalSection)</h6><p>当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区对象的线程可以访问被保护的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程释<br>放临界区为止。</p><ol><li>定义临界区对象CCriticalSection g_CriticalSection； </li><li>在访问共享资源之前，先获取临界区对象，g_CriticalSection； </li><li>访问资源结束后，释放临界区对象，g_CriticalSection.unLock(); </li></ol><h6 id="事件（CEvent）"><a href="#事件（CEvent）" class="headerlink" title="事件（CEvent）"></a>事件（CEvent）</h6><p>事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程A负责侦听通信端口，另外一个线程B负责更新用户数<br>据，利用事件机制，则线程A可以通知线程B何时更新用户数据。<br>每个Cevent对象可以有两种状态：<br>有信号状态和无信号状态。<br>Cevent类对象有两种类型：人工事件和自动事件。<br>自动事件对象，在被至少一个线程释放后自动返回到无信号状态；<br>人工事件对象，获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。在创建Cevent对象时，默认创建的是自动事件。</p><h6 id="互斥量（CMutex）"><a href="#互斥量（CMutex）" class="headerlink" title="互斥量（CMutex）"></a>互斥量（CMutex）</h6><p>互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。<br>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带<br>来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</p><h6 id="信号量（CSemphore）"><a href="#信号量（CSemphore）" class="headerlink" title="信号量（CSemphore）"></a>信号量（CSemphore）</h6><p>当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数<br>值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计<br>数值不为零为止。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88718474&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="线程同步" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java实现LRU策略缓冲</title>
    <link href="https://enpong.github.io/2019/03/08/Java%E5%AE%9E%E7%8E%B0LRU%E7%AD%96%E7%95%A5%E7%BC%93%E5%86%B2/"/>
    <id>https://enpong.github.io/2019/03/08/Java实现LRU策略缓冲/</id>
    <published>2019-03-08T13:05:21.000Z</published>
    <updated>2019-04-09T07:59:25.172Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88358466" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88358466</a></p><p>1.基于”双向链表+HashMap“实现：</p><ul><li><p>访问某个节点时，将该节点从双向链表中原位置删除，并重新插入链表头。这样可以保证链表尾部节点就是最近最久未被使用的，当节点数量大于缓存空间就淘汰链表尾部节点； </p></li><li><p>为了能在O(1)时间内从链表删除某个节点，不能通过遍历链表查找该节点。需要借助HashMap存储key与节点的映射，通过key在O(1)时间内找到节点，并在O(1)时间内删除该节点。 </p><pre><code>public class LRU&lt;K, V&gt; implements Iterable&lt;K&gt; {private Node head;private Node tail;private HashMap&lt;K, Node&gt; map;private int maxSize;private class Node {    Node pre;    Node next;    K k;    V v;    public Node(K k, V v) {        this.k = k;        this.v = v;    }}</code></pre></li></ul><pre><code>    public LRU(int maxSize) {        this.maxSize = maxSize;        this.map = new HashMap&lt;&gt;(maxSize * 4 / 3);        head = new Node(null, null);        tail = new Node(null, null);        head.next = tail;        tail.pre = head;    }    public V get(K key) {        if (!map.containsKey(key)) {            return null;        }        Node node = map.get(key);        unlink(node);        appendHead(node);        return node.v;    }    public void put(K key, V value) {        if (map.containsKey(key)) {            Node node = map.get(key);            unlink(node);        }        Node node = new Node(key, value);        map.put(key, node);        appendHead(node);        if (map.size() &gt; maxSize) {            Node toRemove = removeTail();            map.remove(toRemove.k);        }    }    private void unlink(Node node) {        Node pre = node.pre;        Node next = node.next;        pre.next = next;        next.pre = pre;        node.pre = null;        node.next = null;    }    private void appendHead(Node node) {        Node next = head.next;        node.next = next;        next.pre = node;        node.pre = head;        head.next = node;    }    private Node removeTail() {        Node node = tail.pre;        Node pre = node.pre;        tail.pre = pre;        pre.next = tail;        node.pre = null;        node.next = null;        return node;    }    @Override    public Iterator&lt;K&gt; iterator() {        return new Iterator&lt;K&gt;() {            private Node cur = head.next;            @Override            public boolean hasNext() {                return cur != tail;            }            @Override            public K next() {                Node node = cur;                cur = cur.next;                return node.k;            }        };    }}</code></pre><p>2.使用Java容器中的LinkedHashMap</p><ul><li>LinkedHashMap继承自HashMap，因此具有和HashMap一样的快速查找特性； </li><li>内部维护了一个双向链表，用来维护插入顺序或者LRU顺序；accessOrder字段决定了顺序，默认为false（插入顺序）； </li><li>因此，LinkedHashMap = ”双向链表”+HashMap. </li><li>但是LinkedHashMap实现的LRU缓存与第1个实现方式有一点  区别，即LinkedHashMap的链表首部才是最近最久未使用节点  ；当然，这个区别对于双向链表来说不是事儿，只是寓意上的区别而已（在我看来）。 </li></ul><blockquote><p>访问一个节点时，调用get()方法，get()中有一个函数afterNodeAccess()；该方法用于将该节点移到链表尾部（最近访问节点）</p></blockquote><pre><code>void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last    LinkedHashMap.Entry&lt;K,V&gt; last;    if (accessOrder &amp;&amp; (last = tail) != e) {        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = null;        if (b == null)            head = a;        else            b.after = a;        if (a != null)            a.before = b;        else            last = b;        if (last == null)            head = p;        else {            p.before = last;            last.after = p;        }        tail = p;        ++modCount;    }}</code></pre><blockquote><p>在put等操作之后执行afterNodeInsertion()，当removeEldestEntry()方法返回true时会移除最晚的节点，也就是链表首<br>部节点；evict只有在构建Map时才为false，在这里为true.</p></blockquote><pre><code>void afterNodeInsertion(boolean evict) { // possibly remove eldest    LinkedHashMap.Entry&lt;K,V&gt; first;    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {        K key = first.key;        removeNode(hash(key), key, null, false, true);    }}</code></pre><blockquote><p>removeEldestEntry()默认为false，也就是说put操作后执行的afterNodeInsertion()并没有移除首部节点，也就没有L<br>RU缓存淘汰的说法了；如果需要让它为true，需要继承LinkedHashMap并且覆盖该方法；</p></blockquote><pre><code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {    return false;}</code></pre><ul><li>因此，要用LinkedHashMap来实现一个LRU缓存，需要：<br>1.设定最大缓存空间MAX_ENTRIES<br>2.使用LinkedHashMap的构造方法将accessOrder设置为true，开启LRU顺序；<br>3.覆盖removeEldestEntry（）方法实现，在节点多于MAX_ENTRIES就会将最近最久未使用的节点删除。</li></ul><pre><code>class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {    private static final int MAX_ENTRIES = 3;    protected boolean removeEldestEntry(Map.Entry eldest) {        return size() &gt; MAX_ENTRIES;    }    LRUCache() {        super(MAX_ENTRIES, 0.75f, true);    }}public class LRUTest{    public static void main(String[] args) {        LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();        cache.put(1, &quot;a&quot;);        cache.put(2, &quot;b&quot;);        cache.put(3, &quot;c&quot;);        cache.get(1);        cache.put(4, &quot;d&quot;);        System.out.println(cache.keySet());    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88358466&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
    
      <category term="LRU" scheme="https://enpong.github.io/tags/LRU/"/>
    
      <category term="缓存" scheme="https://enpong.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程的中断操作</title>
    <link href="https://enpong.github.io/2019/03/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C/"/>
    <id>https://enpong.github.io/2019/03/06/Java多线程的中断操作/</id>
    <published>2019-03-06T07:33:09.000Z</published>
    <updated>2019-04-09T07:59:24.724Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88238190" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88238190</a></p><h5 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h5><p>如果一个线程处于阻塞、限期等待或无限期等待状态时，调用该线程的interrupt()方法中断线程，就会抛出InterruptedException，从而提前<br>结束该线程；（注意：不能中断IO阻塞和Synchronized锁阻塞）</p><h5 id="Interupted"><a href="#Interupted" class="headerlink" title="Interupted"></a>Interupted</h5><ul><li>如果一个线程的run()方法执行一个循环体，并且循环体中没有会抛出InterruptedException的操作（如sleep())，那么该线程调用interrupted()就无法中断线程； </li><li>由于一个线程调用interrupt()会设置线程中断标志，该标志可以通过interrupted()来获取；因此可以在run()方法的循环体中以该标志来判断线程是否处于中断状态，以结束线程。 </li></ul><h5 id="Executor中断操作"><a href="#Executor中断操作" class="headerlink" title="Executor中断操作"></a>Executor中断操作</h5><ol><li>Executor的shutDown()会等待所有线程执行完毕之后再关闭；而调用shutDownNow()，相当于调用每个线程的interrupt()方法，中断所有线程； </li><li>如果只想中断Executor中的一个线程，可以使用submit()提交一个线程，该方法返回一个Future&lt;?&gt;对象，通过调用该对象的cancel(true)方法中断线程。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88238190&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
    
      <category term="多线程" scheme="https://enpong.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="中断" scheme="https://enpong.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Web页面请求过程</title>
    <link href="https://enpong.github.io/2019/03/06/Web%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://enpong.github.io/2019/03/06/Web页面请求过程/</id>
    <published>2019-03-06T06:23:37.000Z</published>
    <updated>2019-04-09T07:59:24.218Z</updated>
    
    <content type="html"><![CDATA[<p>转自： <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener"> https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/计算机网络.md#web-<br>页面请求过程 </a></p><h5 id="DHCP配置主机信息"><a href="#DHCP配置主机信息" class="headerlink" title="DHCP配置主机信息"></a>DHCP配置主机信息</h5><ul><li>假设主机最开始没有IP地址以及其他信息，那么就需要先使用DHCP来获取； </li><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中； </li><li>该报文段则被放入在一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中； </li><li>该数据报则被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备； </li><li>连接在交换机的DHCP服务器收到广播帧之后，不断向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中； </li><li>该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧； </li><li>主机收到该帧后，不断向上分解得到DHCP报文。之后就配置它的IP地址，子网掩码和DNS服务器IP地址，并在其IP转发表中安装默认网关． </li></ul><h5 id="ARP解析MAC地址"><a href="#ARP解析MAC地址" class="headerlink" title="ARP解析MAC地址"></a>ARP解析MAC地址</h5><ul><li>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成该套接字，主机需要知道网站的域名对应的IP地址。 </li><li>主机生成一个DNS查询报文，该报文具有53端口，因为DNS服务器的端口号时53； </li><li>该DNS查询报文被放入目的地址为DNS服务器的IP数据报中； </li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器； </li><li>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议； </li><li>主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将该ARP查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器； </li><li>网关路由器接收到该帧后，不断向上分解得到ARP报文，发现其中的IP地址与其接口的IP地址匹配，因此就发送ARP回答报文，包含了它的MAC地址，发回给主机。 </li></ul><h5 id="DNS解析域名"><a href="#DNS解析域名" class="headerlink" title="DNS解析域名"></a>DNS解析域名</h5><ul><li>知道了网关路由器的MAC地址之后，就可以继续DNS的解析过程了； </li><li>网关路由器接收到包含DNS查询报文的以太网帧后，抽取出IP数据报，并根据转发表决定该IP数据报应该转发的路由器； </li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达DNS服务器的路由表项； </li><li>到达DNS服务器后，DNS服务器抽取出DNS查询报文，并在DNS数据库中查找待解析的域名； </li><li>找到DNS记录之后，发送DNS回答报文，将该回答报文放入UDP报文段中，然后放入IP数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 </li></ul><h5 id="HTTP请求页面"><a href="#HTTP请求页面" class="headerlink" title="HTTP请求页面"></a>HTTP请求页面</h5><ul><li>有了HTTP服务器的IP地址，主机就能够生成TCP套接字，该套接字将用于向Web服务器发送HTTP GET报文； </li><li>在生成TCP套接字之前，必须先与HTTP服务器进行三次握手来建立连接。生成一个具有目的端口80的TCP SYN报文段，并向HTTP服务器发送该报文段； </li><li>HTTP服务器接到该报文段之后，生成TCP SYN ACK报文段，发回给主机； </li><li>连接建立之后，浏览器生成HTTP GET报文，并交付给HTTP服务器； </li><li>HTTP服务器从TCP套接字中读取HTTP GET报文，生成一个HTTP响应报文，将Web页面内容放入报文体中，发回给主机； </li><li>浏览器收到HTTP响应报文后，抽取出Web页面内容，之后进行渲染，显示Web页面。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自： &lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%
E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#web-%E9%A1%B5%E
      
    
    </summary>
    
      <category term="网络" scheme="https://enpong.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="undefined" scheme="https://enpong.github.io/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="https://enpong.github.io/2019/03/05/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://enpong.github.io/2019/03/05/五种IO模型/</id>
    <published>2019-03-05T04:55:40.000Z</published>
    <updated>2019-04-09T07:59:23.537Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88177447" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88177447</a></p><p>一个输入操作通常有两个阶段：</p><ul><li>等待数据准备，即从存储介质（磁盘，网络等）拷贝到内核； </li><li>从内核向进程复制数据 </li></ul><h5 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124039713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回 </li></ul><h5 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124240779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。 </li></ul><h5 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h5><p><img src="https://img-blog.csdnimg.cn/20190305124437547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中； </li><li>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。 </li></ul><h5 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124709590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的； </li><li>当数据报准备好被读时，就为该进程生成一个SIGIO信号； </li><li>应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。 </li></ul><h5 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305125019326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号； </li><li>调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。 </li></ul><h5 id="对比五种I-O模型"><a href="#对比五种I-O模型" class="headerlink" title="对比五种I/O模型"></a>对比五种I/O模型</h5><p><img src="https://img-blog.csdnimg.cn/20190305125145450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞； </li><li>异步I/O：在I/O操作未完成前，请求进程未被阻塞。 </li><li>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88177447&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I" scheme="https://enpong.github.io/tags/I/"/>
    
      <category term="O" scheme="https://enpong.github.io/tags/O/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中BitSet</title>
    <link href="https://enpong.github.io/2019/03/02/JAVA%E4%B8%ADBitSet/"/>
    <id>https://enpong.github.io/2019/03/02/JAVA中BitSet/</id>
    <published>2019-03-02T11:10:27.000Z</published>
    <updated>2019-04-09T07:59:22.639Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA中BitSet就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示<br>false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个数据结构KEY和Value的保存需要消耗较多的<br>内存，不适合保存较多的数据，即大数据场景；比如在有10亿条URL中判定一个（ <a href="http://www.baidu.com" target="_blank" rel="noopener"> www.baidu.com </a><br>）是否存在，如果我们使用常规的hashmap来保存将是不现实的，因为URL本身需要占据较多的内存而无法直接操作。如果我们使用bitset来保存，那么可以对一<br>条URL求hashcode，并将数字映射在bitset上，那么事实上它只需要bitset上的一个bit位即可，即我们1位空间即可表达一个URL字符串的存在性<br>。</p><blockquote><p>所谓“存在性”，就是通过BitSet来检测一个数字是否存在。</p></blockquote><h4 id="BitSet原理"><a href="#BitSet原理" class="headerlink" title="BitSet原理"></a>BitSet原理</h4><p>JAVA中，一个long型数字占用64位空间，根据上述“位图”的概念，那么一个long型数字（4个字节）就可以保存64个数字的“存在性”状态(无碰撞冲突时，<br>即true、false状态)。比如50个数字{0,1,10,…63}，判定“15”是否存在，那么我们通常会首先将这些数字使用数组或者hashmap保存，然后<br>再去判定，那么保存这些这些数据需要占用64 * 64位；如果使用位图，那么一个long型数字即可。（如果换成50个字符串，那么其节约的空间可能更大）。</p><ol><li>BitSet只面向数字比较，比如set(int a,boolean value)方法，将数字a在bitSet中设定为true或者false；此后可以通过get(int a)方法检测结果。对于string类型的数据，如果像使用BitSet，那么可以将其hashcode值映射在bitset中。 </li><li>首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 </li></ol><p>数字范围  [0,63]  [64,127]  [128,191]  …</p><p>long数组索引</p><p>0</p><p>1</p><p>2</p><p>…</p><ol start="3"><li><p>bitSet内部的long[]数组是基于向量的，即随着set的最大数字而动态扩展。数组的最大长度计算： </p><p>   (maxValue - 1) &gt;&gt; 6  + 1  </p></li></ol><ol start="4"><li><p>BitSet中set方法伪代码： </p><p>   public void set(int number) {<br>   int index = number &gt;&gt; 6;//找到number需要映射的数组的index。<br>   if(index + 1 &gt; length) {  </p><pre><code>ensureCapacity(index + 1);//重新扩展long[]数组  </code></pre><p>   }<br>   long[index] |= (1L &lt;&lt; number);//冲突解决<br>}  </p></li></ol><h4 id="使用BitSet"><a href="#使用BitSet" class="headerlink" title="使用BitSet"></a>使用BitSet</h4><p>本例中使用bitSet做String字符串的存在性校验。</p><pre><code>BitSet bitSet = new BitSet(Integer.MAX_VALUE);//hashcode的值域  //0x7FFFFFFF  String url = &quot;http://baidu.com/a&quot;;  int hashcode = url.hashCode() &amp; 0x7FFFFFFF;  bitSet.set(hashcode);  System.out.println(bitSet.cardinality());//着色位的个数  System.out.println(bitSet.get(hashcode));//检测存在性  bitSet.clear(hashcode);//清除位数据  </code></pre><h4 id="BitSet与Hashcode冲突"><a href="#BitSet与Hashcode冲突" class="headerlink" title="BitSet与Hashcode冲突"></a>BitSet与Hashcode冲突</h4><p>因为BitSet API只能接收int型的数字，即只能判定int数字是否在bitSet中存在。所以，对于String类型，我们通常使用它的hashcode，<br>但这有一种隐患，java中hashcode存在冲突问题，即不同的String可能得到的hashcode是一样的（即使不重写hashcode方法），如果我们不<br>能很好的解决这个问题，那么就会出现“数据抖动”—不同的hashcode算法、运行环境、bitSet容量，会导致判断的结果有所不同。比如A、B连个字符串，它们<br>的hashcode一样，如果A在BitSet中“着色”(值为true)，那么检测B是否在BitSet存在时，也会得到true。</p><p>这个问题该如何解决或者缓解呢？</p><ol><li><p>调整hashcode生成算法：我们可以对一个String使用多个hashcode算法，生成多个hashcode，然后在同一个BitSet进行多次“着色”，在判断存在性时，只有所有的着色位为true时，才判定成功 </p><p>   String url = “<a href="http://baidu.com/a&quot;" target="_blank" rel="noopener">http://baidu.com/a&quot;</a>;<br>int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF;<br>bitSet.set(hashcode1);  </p><p>int hashcode2 = (url + “-seed-“).hashCode() &amp; 0x7FFFFFFF;<br>bitSet.set(hashcode2);<br>System.out.println(bitSet.get(hashcode1) &amp;&amp; bitSet.get(hashcode2));<br>//也可以在两个不同的bitSet上进行2次“着色”，这样冲突性更小。但会消耗双倍的内存  </p></li></ol><p>其实我们能够看出，这种方式降低了误判的概率。但是如果BitSet中存储了较多的数字，那么互相覆盖着色，最终数据冲突的可能性会逐渐增加，最终仍然有一定概率的判<br>断失误。所以在hashcode算法的个数与实际String的个数之间有一个权衡，我们建议: “hashcode算法个数 <em> String字符串的个数” &lt;<br>Integer.MAX_VALUE </em> 0.8</p><ol start="2"><li>多个BitSet并行保存：<br>改良1)中的实现方式，我们仍然使用多个hashcode生成算法，但是每个算法生成的值在不同的BitSet中着色，这样可以保持每个BitSet的稀疏度(降低冲<br>突的几率)。在实际结果上，比1)的误判率更低，但是它需要额外的占用更多的内存，毕竟每个BitSet都需要占用内存。这种方式，通常是缩小hashcode的值域<br>，避免内存过度消耗。</li></ol><pre><code>    BitSet bitSet1 = new BitSet(Integer.MAX_VALUE);//127M  BitSet bitSet2 = new BitSet(Integer.MAX_VALUE);  String url = &quot;http://baidu.com/a&quot;;  int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF;  bitSet1.set(hashcode1);  int hashcode2 = (url + &quot;-seed-&quot;).hashCode() &amp; 0x7FFFFFFF;  bitSet2.set(hashcode2);  System.out.println(bitSet1.get(hashcode1) &amp;&amp; bitSet2.get(hashcode2));  </code></pre><ol start="3"><li>是否有必要完全避免误判？<br>如果做到100%的正确判断率，在原理上说BitSet是无法做的，BitSet能够保证“如果判定结果为false，那么数据一定是不存在；但是如果结果为true<br>，可能数据存在，也可能不存在(冲突覆盖)”,即“false == YES，true ==<br>Maybe”。有人提出将冲突的数据保存在类似于BTree的额外数据结构中，事实上这种方式增加了设计的复杂度，而且最终仍然没有良好的解决内存占用较大的问题。</li></ol><h4 id="BloomFilter-布隆姆过滤器"><a href="#BloomFilter-布隆姆过滤器" class="headerlink" title="BloomFilter(布隆姆过滤器)"></a>BloomFilter(布隆姆过滤器)</h4><p>BloomFilter 的设计思想和BitSet有较大的相似性，目的也一致，它的核心思想也是使用多个Hash算法在一个“位图”结构上着色，最终提高“存在性”<br>判断的效率。请参见Guava BloomFilter。如下为代码样例：</p><pre><code>Charset charset = Charset.forName(&quot;utf-8&quot;);  BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(charset),2&lt;&lt;21);//指定bloomFilter的容量  String url = &quot;www.baidu.com/a&quot;;  bloomFilter.put(url);  System.out.println(bloomFilter.mightContain(url));  </code></pre><h4 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h4><p>据上所述，BitSet可以有效的降低内存的使用量，但是它的内存使用量是有内部long数组的大小决定，所以在创建BitSet时指定的值域非常重要，过大的值域将<br>会导致OOM（比如指定Long.MAX_VALUE）,在一个BitMap上存储Integer.MAX_VALUE个“着色”（注意，BitSet只能对正数操作<br>），大概消耗128M内存。</p><hr><p>转自： <a href="https://shift-alt-ctrl.iteye.com/blog/2194519" target="_blank" rel="noopener"> https://shift-alt-ctrl.iteye.com/blog/2194519 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JAVA中BitSet就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示&lt;br&gt;false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="大数据量" scheme="https://enpong.github.io/categories/java/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/"/>
    
    
      <category term="BitSet" scheme="https://enpong.github.io/tags/BitSet/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode---208.实现Trie前缀树</title>
    <link href="https://enpong.github.io/2019/03/02/Leetcode---208.%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <id>https://enpong.github.io/2019/03/02/Leetcode---208.实现Trie前缀树/</id>
    <published>2019-03-02T09:59:11.000Z</published>
    <updated>2019-04-09T07:59:21.416Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88079131" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88079131</a></p><p>Java非递归版</p><pre><code>class Trie {    private class Node{        boolean isTrie;        Map&lt;Character, Node&gt; children = new HashMap&lt;&gt;();    }    private Node root = new Node();    /** Initialize your data structure here. */    public Trie() {    }    /** Inserts a word into the trie. */    public void insert(String word) {        Node node = root;        for(int i=0; i&lt;word.length(); i++){            char c = word.charAt(i);            if(!node.children.containsKey(c)){                node.children.put(c, new Node());            }            node = node.children.get(c);        }        node.isTrie = true;        return;    }    /** Returns if the word is in the trie. */    public boolean search(String word) {        Node node = root;        for(int i=0; i&lt;word.length(); i++){            char c = word.charAt(i);            Node temp = node.children.get(c);            if(temp == null)                return false;            node  = temp;        }        return node.isTrie;    }    /** Returns if there is any word in the trie that starts with the given prefix. */    public boolean startsWith(String prefix) {        Node node = root;        for(int i=0; i&lt;prefix.length(); i++){            char c = prefix.charAt(i);            Node temp = node.children.get(c);            if(temp == null)                return false;            node  = temp;        }        return node!=null;    }}</code></pre><h3 id="关于Trie"><a href="#关于Trie" class="headerlink" title="关于Trie"></a>关于Trie</h3><ul><li><p>核心思想：空间换取时间 </p></li><li><p>Trie 树又叫又叫字典树、前缀树、单词查找树，它是一颗多叉查找树。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。 </p></li><li><p>如果  海量数据  是字符串数据，那么就可以用很小的空间开销构建一颗 Trie 树，空间开销和树高有关。 </p></li></ul><p>{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”}<br><img src="https://img-blog.csdnimg.cn/20190302174704179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>基本性质： </p><ul><li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 </li><li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 </li><li>每个节点的所有子节点包含的字符互不相同。 </li></ul></li><li><p>优点 </p><ul><li>插入和查询效率很高，都是O(m)，m是待插入/查询字符串长度；（关于查询，会有人认为hash表时间复杂度O(1)不是更快？确实，但是哈希搜索的效率通常取决于hash函数的好坏，因为这决定着冲突的概率）。 </li><li>Trie树中不同关键字不会冲突； </li><li>可以对关键字按字典排序。 </li></ul></li><li><p>缺点 </p><ul><li>当hash函数很好时，Trie树的查找效率会低于哈希查找； </li><li>空间消耗比较大。 </li></ul></li><li>主要应用：字符串检索、词频统计、字符串排序、前缀匹配等 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88079131&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="undefined" scheme="https://enpong.github.io/categories/undefined/"/>
    
    
      <category term="undefined" scheme="https://enpong.github.io/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer---删除链表中重复的结点</title>
    <link href="https://enpong.github.io/2019/03/02/%E5%89%91%E6%8C%87offer---%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>https://enpong.github.io/2019/03/02/剑指offer---删除链表中重复的结点/</id>
    <published>2019-03-02T06:10:38.000Z</published>
    <updated>2019-04-09T07:59:20.247Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88075375" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88075375</a></p><h4 id="😊题目描述"><a href="#😊题目描述" class="headerlink" title="😊题目描述"></a>😊题目描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为<br>1-&gt;2-&gt;5</p><h4 id="解题思路（递归）"><a href="#解题思路（递归）" class="headerlink" title="解题思路（递归）"></a>解题思路（递归）</h4><p><img src="https://img-blog.csdnimg.cn/20190302140638410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>//这里不对节点删除是因为Java有回收机制，当然手动删除也可以啦public class Solution {    public ListNode deleteDuplication(ListNode pHead)    {        if(pHead==null || pHead.next==null)            return pHead;        ListNode node = pHead.next;        if(pHead.val == node.val){            while(node!=null &amp;&amp; pHead.val==node.val)                node = node.next;            return deleteDuplication(node);        }else{            pHead.next = deleteDuplication(pHead.next);//当前节点的后继指针指向后继链表的去重链表            return pHead;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88075375&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://enpong.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode869---重新排序得到2的幂</title>
    <link href="https://enpong.github.io/2019/03/02/LeetCode869---%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"/>
    <id>https://enpong.github.io/2019/03/02/LeetCode869---重新排序得到2的幂/</id>
    <published>2019-03-02T04:54:18.000Z</published>
    <updated>2019-04-09T07:59:19.615Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88074612" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88074612</a></p><h4 id="😍题目描述"><a href="#😍题目描述" class="headerlink" title="😍题目描述"></a>😍题目描述</h4><p>从正整数 N 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回<br>false。</p><h4 id="😘解题思路"><a href="#😘解题思路" class="headerlink" title="😘解题思路"></a>😘解题思路</h4><ul><li>先将数值N中的每个数字独立存储并排序为list，长度记作n；在2的幂中找出长度为n的所有数值，并同样对每个数字存储排序,得到list2，判断list与list2是否逐位相等 </li><li>对于2的幂的正整数，有个规律：位数每隔3都有对应的整数个数4、3、3， </li></ul><p>位数  个数  整数  幂指数</p><p>1</p><p>4</p><p>1，2，4，8</p><p>0，1，2，3</p><p>2</p><p>3</p><p>16，32，64</p><p>4，5，6</p><p>3</p><p>3</p><p>128，256，512</p><p>7，8，9</p><p>4</p><p>4</p><p>1024，2048，4096，8192</p><p>10，11，12，13</p><p>5</p><p>3</p><p>16384，32768，65536</p><p>14，15，16</p><p>6</p><p>3</p><p>…</p><p>17，18，19</p><p>7</p><p>4</p><p>…</p><p>20，21，22，23</p><p>8</p><p>3</p><p>…</p><p>24，25，26</p><p>9</p><p>3</p><p>…</p><p>27，28，29</p><p>…</p><p>…</p><p>…</p><p>…</p><h4 id="😱示例代码"><a href="#😱示例代码" class="headerlink" title="😱示例代码"></a>😱示例代码</h4><pre><code>class Solution {    public boolean reorderedPowerOf2(int N) {        String num = N+&quot;&quot;;        int len = num.length();        int n;//位数为len的整数（2的幂)的个数        int m;//位数为len的整数的幂指数        if(len%3 == 0){            m = (len/3)*10-3;            n = 3;        }else if(len%3 == 1){            m = (len/3)*10;            n = 4;        }else{            m = (len/3)*10+4;            n = 3;        }        String[] pows = new String[n];        for(int i=0; i&lt;n; i++){            pows[i] = (int)Math.pow(2, m+i) + &quot;&quot;;            char[] powlist = pows[i].toCharArray();            Arrays.sort(powlist);            char[] numlist = num.toCharArray();            Arrays.sort(numlist);            if(Arrays.equals(powlist, numlist))                return true;        }        return false;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88074612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="undefined" scheme="https://enpong.github.io/categories/undefined/"/>
    
    
      <category term="undefined" scheme="https://enpong.github.io/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---进程通信</title>
    <link href="https://enpong.github.io/2019/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://enpong.github.io/2019/03/01/操作系统---进程通信/</id>
    <published>2019-03-01T15:54:07.000Z</published>
    <updated>2019-04-09T07:59:18.751Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88071041" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88071041</a></p><h3 id="对进程通信的理解"><a href="#对进程通信的理解" class="headerlink" title="对进程通信的理解"></a>对进程通信的理解</h3><p>进程是资源分配的基本单位，所以说某块资源分配给一个进程后，该资源只能是该进程独占，所以进程之间的通信就会比较麻烦，因为需要让不同的进程间能够看到一份公共的资<br>源。所以交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信<br>。</p><h3 id="实现进程通信的方式"><a href="#实现进程通信的方式" class="headerlink" title="实现进程通信的方式"></a>实现进程通信的方式</h3><h5 id="匿名管道（pipe）"><a href="#匿名管道（pipe）" class="headerlink" title="匿名管道（pipe）"></a>匿名管道（pipe）</h5><ul><li>管道是通过调用 pipe 函数创建的，是在内核中开辟出的一块缓冲区，fd[0] 用于读，fd[1] 用于写。 </li><li>只支持半双工通信（单向交替传输）； </li><li>只能在父子进程中使用。 </li><li>父进程关闭读端（fd[0]）,子进程关闭写端(fd[1])，则此时父进程可以往管道中进行写操作，子进程可以从管道中读，从而实现了通过管道的进程间通信<br><img src="https://img-blog.csdnimg.cn/20190301210844562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code>#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;int main(){    int fd[2];    int ret = pipe(fd);        //开启匿名管道    if(ret&lt;0)         perror(&quot;pipe\n&quot;);    //开启失败    pid_t id = fork();        //创建子进程    if(id&lt;0)         perror(&quot;fork\n&quot;);    //创建失败    else if(id==0){        //子进程        close(fd[0]);        //子进程关闭读端        int i=0;        char *mesg = NULL;        while(i&lt;100){            mesg = &quot;child&quot;;            write(fd[1], mesg, strlen(mesg)+1);        //向管道另一端写数据            sleep(1);            i++;        }    }    else{        //父进程        close(fd[1]);        //父进程关闭写端        int i=0;        char mesg[100];        while(i&lt;100){            memset(mesg, &apos;\0&apos;, sizeof(mesg));            read(fd[0], mesg, sizeof(mesg));        //从管道另一端读数据            printf(&quot;%s\n&quot;, mesg);            j++;        }    }    return 0;}</code></pre><h5 id="命名管道（FIFO）"><a href="#命名管道（FIFO）" class="headerlink" title="命名管道（FIFO）"></a>命名管道（FIFO）</h5><ul><li>命名管道，去除了管道只能在父子进程中使用的限制。 </li><li>命名管道创建后就可以使用了，使用方法和匿名管道基本相同。只是使用命名管道时，必须先调用open()将其打开，因为命名管道是一个存在于硬盘的文件，而匿名管道是存在于内存中的特殊文件 </li><li>调用open()打开命名管道的进程可能会被阻塞。但如果同时用读写方式（ O_RDWR）打开，则一定不会导致阻塞；如果以只读方式（ O_RDONLY）打开，则调用open()函数的进程将会被阻塞直到有写方打开管道；同样以写方式（ O_WRONLY）打开也会阻塞直到有读方式打开管道。<br><img src="https://img-blog.csdnimg.cn/2019030121392516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code>     😜Client.c文件，向管道写数据#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#define _PATH_NAME_ &quot;/tmp/file.tmp&quot;#define _SIZE_ 100int main(){    int ret=mkfifo(_PATH_NAME_,S_IFIFO|0666);        //第一个参数是命名管道存储路径，第二个是命名管道的存取权限    if(ret==-1){        printf(&quot;make fifo error\n&quot;);        return 1;    }    char buf[_SIZE_];    memset(buf,&apos;\0&apos;,sizeof(buf));    int fd=open(_PATH_NAME_,O_WRONLY);        //打开命名管道，因为其是硬盘上的文件    while(1)    {        //scanf(&quot;%s&quot;,buf);        fgets(buf,sizeof(buf)-1,stdin);        int ret=write(fd,buf,strlen(buf)+1);        if(ret&lt;0){            printf(&quot;write error&quot;);            break;        }    }    close(fd);    return 0;}      😜Server.c文件，从管道读数据并输出 #include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#define _PATH_NAME &quot;/tmp/file.tmp&quot;#define _SIZE_ 100int main(){    int fd=open(_PATH_NAME,O_RDONLY);    if(fd&lt;0){        printf(&quot;open file error&quot;);        return 1;    }    char buf[_SIZE_];    memset(buf,&apos;\0&apos;,sizeof(buf));    while(1){        int ret=read(fd,buf,sizeof(buf));        if(ret&lt;0){            printf(&quot;read end or error\n&quot;);            break;        }        printf(&quot;%s&quot;,buf);    }    close(fd);    return 0;}</code></pre><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><ul><li><p>消息队列可以独立于读写进程存在，从而避免了FIFO中为了同步管道的打开和关闭可能产生的困难； </p></li><li><p>避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法； </p></li><li><p>读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收. </p><pre><code>int msgget(key_t key, int msgflg);</code></pre><p>ssize_t msgrcv(int msqid, void <em>msgp, size_t msgsz, long msgtyp, int msgflg);<br>int msgsnd(int msqid, const void </em>msgp, size_t msgsz, int msgflg);<br>int msgctl ( int msgqid, int cmd, struct msqid_ds *buf );</p></li></ul><ul><li><p>创建消息队列用系统调用msgget()来实现，这一步工作也被称为消息队列的初始化。 </p></li><li><p>在进行通信时，消息队列的发送和接收分别用系统调用msgsnd()和msgrcv()来实现.。 </p></li><li><p>在需要改变队列的使用权限及其它一些特性时，用msgclt()来实现。 </p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10287879）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10287879）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10287879）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10287879）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10287879）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89</a>)</p><pre><code>     😘msgreceive.c#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msg_st{    long int msg_type;    char text[BUFSIZ];};int main(){    int running = 1;    int msgid = -1;    struct msg_st data;    long int msgtype = 0; //注意1    //建立消息队列    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);    if(msgid == -1)    {        fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno);        exit(EXIT_FAILURE);    }    //从队列中获取消息，直到遇到end消息为止    while(running)    {        if(msgrcv(msgid, (void*)&amp;data, BUFSIZ, msgtype, 0) == -1)        {            fprintf(stderr, &quot;msgrcv failed with errno: %d\n&quot;, errno);            exit(EXIT_FAILURE);        }        printf(&quot;You wrote: %s\n&quot;,data.text);        //遇到end结束        if(strncmp(data.text, &quot;end&quot;, 3) == 0)            running = 0;    }    //删除消息队列    if(msgctl(msgid, IPC_RMID, 0) == -1)    {        fprintf(stderr, &quot;msgctl(IPC_RMID) failed\n&quot;);        exit(EXIT_FAILURE);    }    exit(EXIT_SUCCESS);}    😘msgsend.c文件#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/msg.h&gt;#include &lt;errno.h&gt;#define MAX_TEXT 512struct msg_st{    long int msg_type;    char text[MAX_TEXT];};int main(){    int running = 1;    struct msg_st data;    char buffer[BUFSIZ];    int msgid = -1;    //建立消息队列    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);    if(msgid == -1)    {        fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno);        exit(EXIT_FAILURE);    }    //向消息队列中写消息，直到写入end    while(running)    {        //输入数据        printf(&quot;Enter some text: &quot;);        fgets(buffer, BUFSIZ, stdin);        data.msg_type = 1;    //注意2        strcpy(data.text, buffer);        //向队列发送数据        if(msgsnd(msgid, (void*)&amp;data, MAX_TEXT, 0) == -1)        {            fprintf(stderr, &quot;msgsnd failed\n&quot;);            exit(EXIT_FAILURE);        }        //输入end结束输入        if(strncmp(buffer, &quot;end&quot;, 3) == 0)            running = 0;        sleep(1);    }    exit(EXIT_SUCCESS);}</code></pre><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><ul><li>它是一个计数器，用于为多个进程提供对共享数据对象的访问 </li><li>semget()用于创建一个新信号量或返回一个已有信号量（根据IPCkey） </li><li>semop()用于改变信号量的值，用于对信号量增减操作，即PV操作 </li><li><p>semclt()用于直接控制信号量的值，用于对信号量初始化操作 </p><pre><code>int semget(key_t key, int num_sems, int sem_flags);</code></pre><p>int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);<br>int semctl(int sem_id, int sem_num, int command, …);</p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10243617）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10243617）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10243617）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10243617）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10243617）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10243617%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10243617%EF%BC%89</a>)</p><pre><code>#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/sem.h&gt;union semun{    int val;    struct semid_ds *buf;    unsigned short *arry;};static int sem_id = 0;static int set_semvalue();static void del_semvalue();static int semaphore_p();static int semaphore_v();int main(int argc, char *argv[]){    char message = &apos;X&apos;;    int i = 0;    //创建信号量    sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);    if(argc &gt; 1)    {        //程序第一次被调用，初始化信号量        if(!set_semvalue())        {            fprintf(stderr, &quot;Failed to initialize semaphore\n&quot;);            exit(EXIT_FAILURE);        }        //设置要输出到屏幕中的信息，即其参数的第一个字符        message = argv[1][0];        sleep(2);    }    for(i = 0; i &lt; 10; ++i)    {        //进入临界区        if(!semaphore_p())            exit(EXIT_FAILURE);        //向屏幕中输出数据        printf(&quot;%c&quot;, message);        //清理缓冲区，然后休眠随机时间        fflush(stdout);        sleep(rand() % 3);        //离开临界区前再一次向屏幕输出数据        printf(&quot;%c&quot;, message);        fflush(stdout);        //离开临界区，休眠随机时间后继续循环        if(!semaphore_v())            exit(EXIT_FAILURE);        sleep(rand() % 2);    }    sleep(10);    printf(&quot;\n%d - finished\n&quot;, getpid());    if(argc &gt; 1)    {        //如果程序是第一次被调用，则在退出前删除信号量        sleep(3);        del_semvalue();    }    exit(EXIT_SUCCESS);}static int set_semvalue(){    //用于初始化信号量，在使用信号量前必须这样做    union semun sem_union;    sem_union.val = 1;    if(semctl(sem_id, 0, SETVAL, sem_union) == -1)        return 0;    return 1;}static void del_semvalue(){    //删除信号量    union semun sem_union;    if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)        fprintf(stderr, &quot;Failed to delete semaphore\n&quot;);}static int semaphore_p(){    //对信号量做减1操作，即等待P（sv）    struct sembuf sem_b;    sem_b.sem_num = 0;    sem_b.sem_op = -1;//P()    sem_b.sem_flg = SEM_UNDO;    if(semop(sem_id, &amp;sem_b, 1) == -1)    {        fprintf(stderr, &quot;semaphore_p failed\n&quot;);        return 0;    }    return 1;}static int semaphore_v(){    //这是一个释放操作，它使信号量变为可用，即发送信号V（sv）    struct sembuf sem_b;    sem_b.sem_num = 0;    sem_b.sem_op = 1;//V()    sem_b.sem_flg = SEM_UNDO;    if(semop(sem_id, &amp;sem_b, 1) == -1)    {        fprintf(stderr, &quot;semaphore_v failed\n&quot;);        return 0;    }    return 1;}</code></pre><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><ul><li><p>允许多个进程共享一个给定的存储区 </p></li><li><p>因为数据不需要进程之间的复制，而是直接访问内存，所以这是最快的一种IPC。 </p></li><li><p>由于共享内存并不提供同步操作，所以在使用共享内存这种通信方式时，需要借助其他手段进行进程间的同步工作，可以使用信号量等 </p></li><li><p>shmget()用来创建共享内存，返回一个与key相关的共享内存标识符 </p></li><li><p>shmat()用来启动对共享内存的访问，并把共享内存连接到当前进程的地址空间（第一次创建完共享内存时，还不能被任何进程访问），返回指向共享内存的指针 </p></li><li><p>shmclt()用来控制共享内存，与信号量的semclt()函数一样 </p></li><li><p>shmdt()用于将共享内存从当前进程中分离，注意分离不等于删除共享内存 </p><pre><code>int shmget(key_t key, size_t size, int shmflg);</code></pre><p>void <em>shmat(int shm_id, const void </em>shm_addr, int shmflg);<br>int shmctl(int shm_id, int command, struct shmid_ds <em>buf);<br>int shmdt(const void </em>shmaddr);</p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10253345）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10253345）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10253345）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10253345）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10253345）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10253345%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10253345%EF%BC%89</a>)</p><pre><code>      😀shmdata.h文件，定义共享内存结构//shmdata.h文件，定义共享内存结构#ifndef _SHMDATA_H_HEADER#define _SHMDATA_H_HEADER #define TEXT_SZ 2048struct shared_use_st{    int written;//作为一个标志，非0：表示可读，0表示可写    char text[TEXT_SZ];//记录写入和读取的文本};#endif    😀shmread.c文件，创建共享内存，并读取其中信息#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include &quot;shmdata.h&quot;int main(){    int running = 1;//程序是否继续运行的标志    void *shm = NULL;//分配的共享内存的原始首地址    struct shared_use_st *shared;//指向shm    int shmid;//共享内存标识符    //创建共享内存    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);    if(shmid == -1)    {        fprintf(stderr, &quot;shmget failed\n&quot;);        exit(EXIT_FAILURE);    }    //将共享内存连接到当前进程的地址空间    shm = shmat(shmid, 0, 0);    if(shm == (void*)-1)    {        fprintf(stderr, &quot;shmat failed\n&quot;);        exit(EXIT_FAILURE);    }    printf(&quot;\nMemory attached at %X\n&quot;, (int)shm);    //设置共享内存    shared = (struct shared_use_st*)shm;    shared-&gt;written = 0;    while(running)//读取共享内存中的数据    {        //没有进程向共享内存定数据有数据可读取        if(shared-&gt;written != 0)        {            printf(&quot;You wrote: %s&quot;, shared-&gt;text);            sleep(rand() % 3);            //读取完数据，设置written使共享内存段可写            shared-&gt;written = 0;            //输入了end，退出循环（程序）            if(strncmp(shared-&gt;text, &quot;end&quot;, 3) == 0)                running = 0;        }        else//有其他进程在写数据，不能读取数据            sleep(1);    }    //把共享内存从当前进程中分离    if(shmdt(shm) == -1)    {        fprintf(stderr, &quot;shmdt failed\n&quot;);        exit(EXIT_FAILURE);    }    //删除共享内存    if(shmctl(shmid, IPC_RMID, 0) == -1)    {        fprintf(stderr, &quot;shmctl(IPC_RMID) failed\n&quot;);        exit(EXIT_FAILURE);    }    exit(EXIT_SUCCESS);}    😀shmwrite.c文件，向共享内存写入数据#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &quot;shmdata.h&quot;int main(){    int running = 1;    void *shm = NULL;    struct shared_use_st *shared = NULL;    char buffer[BUFSIZ + 1];//用于保存输入的文本    int shmid;    //创建共享内存    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);    if(shmid == -1)    {        fprintf(stderr, &quot;shmget failed\n&quot;);        exit(EXIT_FAILURE);    }    //将共享内存连接到当前进程的地址空间    shm = shmat(shmid, (void*)0, 0);    if(shm == (void*)-1)    {        fprintf(stderr, &quot;shmat failed\n&quot;);        exit(EXIT_FAILURE);    }    printf(&quot;Memory attached at %X\n&quot;, (int)shm);    //设置共享内存    shared = (struct shared_use_st*)shm;    while(running)//向共享内存中写数据    {        //数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本        while(shared-&gt;written == 1)        {            sleep(1);            printf(&quot;Waiting...\n&quot;);        }        //向共享内存中写入数据        printf(&quot;Enter some text: &quot;);        fgets(buffer, BUFSIZ, stdin);        strncpy(shared-&gt;text, buffer, TEXT_SZ);        //写完数据，设置written使共享内存段可读        shared-&gt;written = 1;        //输入了end，退出循环（程序）        if(strncmp(buffer, &quot;end&quot;, 3) == 0)            running = 0;    }    //把共享内存从当前进程中分离    if(shmdt(shm) == -1)    {        fprintf(stderr, &quot;shmdt failed\n&quot;);        exit(EXIT_FAILURE);    }    sleep(2);    exit(EXIT_SUCCESS);}</code></pre><h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><ul><li><p>与其它通信机制不同的是，它可用于不同机器间的进程通信 </p></li><li><p>因特网提供了两种通信机制：流（stream）和数据报（datagram），因而套接字的类型也就分为流套接字和数据报套接字。 </p></li><li><p>一种套接字域是AF_INET，它指的是Internet网络，结构中有IP地址和端口 </p></li><li><p>另一种域AF_UNIX，表示UNIX文件系统，它就是文件输入/输出，结构中有文件路径名 </p></li><li><p>socket()用于创建一个套接字，三个参数分别为套接字域、通信机制、协议类型 </p></li><li><p>bind()函数把通过socket调用创建的套接字命名，从而让它可以被其他进程使用。对于AF_UNIX，调用该函数后套接字就会关联到一个文件系统路径名，对于AF_INET，则会关联到一个IP端口号 </p></li><li><p>listen()用来创建一个队列来保存未处理的请求 </p></li><li><p>accept()用来等待客户建立对该套接字的连接，阻塞直到有客户建立连接 </p></li><li><p>connect()用来让客户程序通过在一个未命名套接字和服务器监听套接字之间建立连接的方法来连接到服务器 </p></li><li><p>close()用来终止服务器和客户上的套接字连接，我们应该总是在连接的两端（服务器和客户）关闭套接字 </p><pre><code>int socket(int domain, int type, int protocol);</code></pre><p>int bind( int socket, const struct sockaddr <em>address, size_t address_len);<br>int listen(int socket, int backlog);<br>int accept(int socket, struct sockaddr </em>address, size_t <em>address_len);<br>int connect(int socket, const struct sockaddr </em>address, size_t address_len);</p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10477427）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10477427）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10477427）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10477427）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10477427）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10477427%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10477427%EF%BC%89</a>)</p><pre><code>     😡sockserver.c文件，服务器端#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int server_sockfd = -1;    int client_sockfd = -1;    int client_len = 0;    struct sockaddr_in server_addr;    struct sockaddr_in client_addr;    //创建流套接字    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);    //设置服务器接收的连接地址和监听的端口    server_addr.sin_family = AF_INET;//指定网络套接字    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//接受所有IP地址的连接    server_addr.sin_port = htons(9736);//绑定到9736端口    //绑定（命名）套接字    bind(server_sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));    //创建套接字队列，监听套接字    listen(server_sockfd, 5);    //忽略子进程停止或退出信号    signal(SIGCHLD, SIG_IGN);    while(1)    {        char ch = &apos;\0&apos;;        client_len = sizeof(client_addr);        printf(&quot;Server waiting\n&quot;);        //接受连接，创建新的套接字        client_sockfd = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len);        if(fork() == 0)        {            //子进程中，读取客户端发过来的信息，处理信息，再发送给客户端            read(client_sockfd, &amp;ch, 1);            sleep(5);            ch++;            write(client_sockfd, &amp;ch, 1);            close(client_sockfd);            exit(0);        }        else        {            //父进程中，关闭套接字            close(client_sockfd);        }    }}    😡sockclient.c文件，客户端#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int sockfd = -1;    int len = 0;    struct sockaddr_in address;    int result;    char ch = &apos;A&apos;;    //创建流套接字    sockfd = socket(AF_INET, SOCK_STREAM, 0);    //设置要连接的服务器的信息    address.sin_family = AF_INET;//使用网络套接字    address.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//服务器地址    address.sin_port = htons(9736);//服务器所监听的端口    len = sizeof(address);    //连接到服务器    result = connect(sockfd, (struct sockaddr*)&amp;address, len);    if(result == -1)    {        perror(&quot;ops:client\n&quot;);        exit(1);    }    //发送请求给服务器    write(sockfd, &amp;ch, 1);    //从服务器获取数据    read(sockfd, &amp;ch, 1);    printf(&quot;char form server = %c\n&quot;, ch);    close(sockfd);    exit(0);}</code></pre><h5 id="关于System-V-IPC"><a href="#关于System-V-IPC" class="headerlink" title="关于System V IPC"></a>关于System V IPC</h5><p>System V IPC指的是AT&amp;T在System V.2发行版中引入的三种进程间通信工具：</p><ol><li>信号量，用来管理对共享资源的访问 </li><li>共享内存，用来高效地实现进程间的数据共享 共享内存，用来高效地实现进程间的数据共享 </li><li>消息队列，用来实现进程间数据的传递。 </li></ol><p>我们把这三种工具统称为System V<br>IPC的对象，每个对象都具有一个唯一的IPC标识符(identifier)。要保证不同的进程能够获取同一个IPC对象，必须提供一个IPC关键字(IPC<br>key)，内核负责把IPC关键字转换成IPC标识符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88071041&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程通信" scheme="https://enpong.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---进程同步经典问题</title>
    <link href="https://enpong.github.io/2019/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://enpong.github.io/2019/03/01/操作系统---进程同步经典问题/</id>
    <published>2019-03-01T12:43:04.000Z</published>
    <updated>2019-04-09T07:59:17.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full<br>记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full<br>信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行<br>down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty =<br>0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为<br>0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><pre><code>#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer(){    while(TRUE){        int item = produce_item();        down(&amp;empty);        down(&amp;mutex);        insert_item(item);        up(&amp;mutex);        up(&amp;full);    }}void consumer(){    while(TRUE){        down(&amp;full);        down(&amp;mutex);        int item = remove_item();        consume_item(item);        up(&amp;mutex);        up(&amp;empty);    }}</code></pre><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex<br>用于对读写的数据加锁。</p><ul><li>读者优先策略：当读者进行读取时，如果后面一直有读者进入，那么写者就会阻塞，直到所有读者完成之后，写者才可以进入。 </li></ul><pre><code>typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void writer(){    while(TRUE){        down(&amp;data_mutex);        write();        up(&amp;data_mutex);    }}void reader(){    while(TRUE){        down(&amp;count_mutex);        if(count==0)            down(&amp;data_mutex);//如果是第一个读者，阻塞写者        count++;        up(&amp;count_mutex);        read();        down(&amp;count_mutex);        count--;        if(count==0)            up(&amp;data_mutex);//最后一个读者出来，释放写者        up(&amp;count_mutex);    }}</code></pre><ul><li>写者优先：置一个WriterMutex信号量来实现优先读。我们可以看到，当有写者进入时，通过P(WriterMutex)阻塞了读者 </li></ul><pre><code>typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;semaphore write_mutex = 1;//实现写者优先int count = 0;void writer(){    while(TRUE){        down(&amp;write_mutex);        down(&amp;data_mutex);        write();        up(&amp;data_mutex);        up(&amp;write_mutex);    }}void reader(){    while(TRUE){        down(&amp;write_mutex);//无写者进入时        down(&amp;count_mutex);        if(count==0)            down(&amp;data_mutex);//如果是第一个读者，阻塞写者        count++;        up(&amp;write_mutex);//恢复对共享资源的访问        up(&amp;count_mutex);        read();        down(&amp;count_mutex);        count--;        if(count==0)            up(&amp;data_mutex);//最后一个读者出来，释放写者        up(&amp;count_mutex);    }}</code></pre><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>五个哲学家（A~E）围着一张圆桌就餐，他们每个人面前都有一盘通心粉。由于通心粉很滑，所以需要两只筷子才能夹住，但每两个盘子之间只放着一只筷子，如下图。<br>哲学家只有两个动作：要么就餐，要么思考。而且他们之间从不交谈。<br>当一个哲学家饿了的时候，就拿起盘子左右两边的筷子开始就餐（不能同时拿起两只筷子）。就餐完以后，就把筷子放回盘子左右，继续思考。<br>由于他们之间互不交谈，所以很容易出现“死锁”：假如每个人都拿着左边的筷子，则所有人都在等右边的筷子，谁都吃不了。<br><img src="https://img-blog.csdnimg.cn/20190301203327590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了防止死锁的发生，可以设置两个条件：</p><p>必须同时拿起左右两根筷子；<br>只有在两个邻居都没有进餐的情况下才允许进餐。</p><pre><code>#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N    // 右邻居#define THINKING 0#define HUNGRY   1#define EATING   2typedef int semaphore;int state[N];                // 跟踪每个哲学家的状态semaphore mutex = 1;         // 临界区的互斥semaphore s[N];              // 每个哲学家一个信号量void philosopher(int i) {    while(TRUE) {        think();        take_two(i);        eat();        put_two(i);    }}void take_two(int i) {    down(&amp;mutex);    state[i] = HUNGRY;    test(i);    up(&amp;mutex);    down(&amp;s[i]);}void put_two(i) {    down(&amp;mutex);    state[i] = THINKING;    test(LEFT);    test(RIGHT);    up(&amp;mutex);}void test(i) {         // 尝试拿起两把筷子    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) {        state[i] = EATING;        up(&amp;s[i]);    }}</code></pre><ul><li>其他解决方案（ <a href="https://blog.csdn.net/Sunflowerfiona/article/details/52756819%EF%BC%89" target="_blank" rel="noopener"> https://blog.csdn.net/Sunflowerfiona/article/details/52756819） </a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生产者-消费者问题&quot;&gt;&lt;a href=&quot;#生产者-消费者问题&quot; class=&quot;headerlink&quot; title=&quot;生产者-消费者问题&quot;&gt;&lt;/a&gt;生产者-消费者问题&lt;/h3&gt;&lt;p&gt;问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程同步" scheme="https://enpong.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>SSM---对Spring的理解</title>
    <link href="https://enpong.github.io/2019/03/01/SSM---%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://enpong.github.io/2019/03/01/SSM---对Spring的理解/</id>
    <published>2019-03-01T06:24:16.000Z</published>
    <updated>2019-04-09T07:59:16.987Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88057759" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88057759</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Spring是一个开源框架，为简化企业级应用开发而生。Spring可以是使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和<br>AOP容器框架。</p><h3 id="主要核心"><a href="#主要核心" class="headerlink" title="主要核心"></a>主要核心</h3><ul><li>控制反转（IOC），传统的Java开发模式中，当需要一个对象时，我们会自己使用new或者getInstance等直接或者间接调用构造方法创建一个对象，而在Spring开发模式中，spring容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring提供的对象就可以了，这是控制反转的思想。控制反转主要的实现方式有两种：依赖查找、依赖注入。 </li><li>依赖注入（DI），spring使用JavaBean对象的set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。 </li><li>面向切面编程（AOP），在面向对象编程(oop)思想中，我们将事物纵向抽成一个个对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事务管理、记录日志等公用操作处理的过程就是面向切面编程的思想。AOP底层是动态代理，如果是接口采用JDK动态代理，如果是类采用CGLIB方式实现动态代理。 </li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://img-blog.csdnimg.cn/20190301134638454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>spring由20多个模块组成，可以分为数据访问/集成、Web、面向切面编程、应用服务器设备管理、消息发送、核心容器和测试</p><ol><li>Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换和常用的工具类； </li><li>Beans模块：提供框架的基础部分，包括控制反转和依赖注入。其中BeanFactory是容器核心。 </li><li>Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化等；核心接口是ApplicationContext。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88057759&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="ssm" scheme="https://enpong.github.io/categories/ssm/"/>
    
    
      <category term="spring" scheme="https://enpong.github.io/tags/spring/"/>
    
      <category term="IOC" scheme="https://enpong.github.io/tags/IOC/"/>
    
      <category term="AOP" scheme="https://enpong.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---概述</title>
    <link href="https://enpong.github.io/2019/02/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%A6%82%E8%BF%B0/"/>
    <id>https://enpong.github.io/2019/02/28/操作系统---概述/</id>
    <published>2019-02-28T12:00:54.000Z</published>
    <updated>2019-04-09T07:59:16.473Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88043694" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88043694</a></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li><p>并发<br>一段时间内运行多个程序为并发；<br>同一时刻运行多条指令为并行；<br>并行需要硬件支持，比如多核处理器、分布式系统<br>操作系统引入进程和线程，使得程序能够并发运行</p></li><li><p>共享<br>指系统资源可以被多个并发进程使用<br>两种共享方式：互斥共享、同时共享</p></li><li><p>虚拟<br>两种虚拟技术：<br>时分复用技术，多个进程在同一个处理器上并发执行<br>空分复用技术，虚拟内存</p></li><li><p>异步<br>指一个进程不是一次执行完毕，而是走走停停</p></li></ul><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li><p>进程管理<br>进程控制、进程同步、进程调度、死锁处理、处理机调度等</p></li><li><p>内存管理<br>内存分配、地址映射、内存保护与共享、虚拟内存等</p></li><li><p>文件管理<br>文件存储空间管理、目录管理、文件读写管理与保护等</p></li><li><p>设备管理<br>帮助用户完成IO请求，包括缓冲管理、设备分配、设备处理、虚拟设备等</p></li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>如果一个进程在用户态需要使用内核态的功能，需要通过系统调用陷入内核态，有操作系统代为完成。<br><img src="https://img-blog.csdnimg.cn/20190228195735602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ol><li>外中断，如IO完成请求、时钟中断、控制台中断等 </li><li>异常，由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等 </li><li>陷入，进程使用系统调用由用户态陷入内核态 </li></ol><p>参考： <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E4%B8%80%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener"> https://github.com/CyC2018/CS-<br>Notes/blob/master/docs/notes/计算机操作系统.md#一概述 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88043694&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="概念" scheme="https://enpong.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO---字符操作</title>
    <link href="https://enpong.github.io/2019/02/28/JavaIO---%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C/"/>
    <id>https://enpong.github.io/2019/02/28/JavaIO---字符操作/</id>
    <published>2019-02-28T10:59:12.000Z</published>
    <updated>2019-04-09T07:59:15.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； </li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； </li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 </li></ul><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p><p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be<br>进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p><h4 id="String-的编码方式"><a href="#String-的编码方式" class="headerlink" title="String 的编码方式"></a>String 的编码方式</h4><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p><pre><code>String str1 = &quot;中文&quot;;byte[] bytes = str1.getBytes(&quot;UTF-8&quot;);String str2 = new String(bytes, &quot;UTF-8&quot;);System.out.println(str2);</code></pre><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将<br>String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为<br>UTF-8。</p><h3 id="Reader-与-Writer"><a href="#Reader-与-Writer" class="headerlink" title="Reader 与 Writer"></a>Reader 与 Writer</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p><p>InputStreamReader 实现从字节流解码成字符流；<br>OutputStreamWriter 实现字符流编码成为字节流。</p><p>实现逐行输出文本文件的内容</p><pre><code>public static void readFileContent(String filePath) throws IOException {    FileReader fileReader = new FileReader(filePath);    BufferedReader bufferedReader = new BufferedReader(fileReader);    String line;    while ((line = bufferedReader.readLine()) != null) {        System.out.println(line);    }    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法    // 因此只要一个 close() 调用即可    bufferedReader.close();}</code></pre><p>参考： <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md" target="_blank" rel="noopener"> https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java IO.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编码与解码&quot;&gt;&lt;a href=&quot;#编码与解码&quot; class=&quot;headerlink&quot; title=&quot;编码与解码&quot;&gt;&lt;/a&gt;编码与解码&lt;/h3&gt;&lt;p&gt;编码就是把字符转换为字节，而解码是把字节重新组合成字符。&lt;/p&gt;
&lt;p&gt;如果编码和解码过程使用不同的编码方式那么就出
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
    
      <category term="IO" scheme="https://enpong.github.io/tags/IO/"/>
    
      <category term="字符" scheme="https://enpong.github.io/tags/%E5%AD%97%E7%AC%A6/"/>
    
      <category term="编码" scheme="https://enpong.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="https://enpong.github.io/2019/02/28/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://enpong.github.io/2019/02/28/装饰者模式/</id>
    <published>2019-02-28T10:47:23.000Z</published>
    <updated>2019-04-09T07:59:14.704Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88040936" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88040936</a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p><img src="https://img-blog.csdnimg.cn/20190228180200747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><p>抽象构件(Component)<br>它是具体构件和抽象装饰类的共同祖先，声明了具体构件需要实现的业务方法</p></li><li><p>具体构件(ConcreteComponent)<br>它是抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的业务方法</p></li><li><p>抽象装饰类(Decorator)<br>它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通<br>过其子类扩展该方法，以达到装饰的目的。</p></li><li><p>具体装饰类(ConcreteDecorator)<br>它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>假设有两个程序员他们原来只会各自的技能，现在需要让Android程序猿具备设计模式技能，那就给他装饰一下。说明一下：</p><ul><li>抽象构件：掌握技能的程序员 </li><li>具体构件：一个掌握写Android代码技能的程序员，一个掌握写php代码技能的程序员 </li><li>抽象装饰类： </li><li>具体装饰类： 在业务方法中添加设计模式的技能 </li></ul><pre><code>//Component（抽象构件）interface ProgramMonkey {    void skills();}//ConcreteComponent（具体构件）class AndroidProgramMonkey implements ProgramMonkey {    @Override    public void skills() {        System.out.println(&quot;会写Android代码！&quot;);    }}//ConcreteComponent（具体构件）class PHPProgramMonkey implements ProgramMonkey {    @Override    public void skills() {        System.out.println(&quot;会写PHP代码！&quot;);    }}//Decorator（抽象装饰类）class ProgramMonkeyDecorator implements ProgramMonkey {    protected ProgramMonkey mProgramMonkey;    public ProgramMonkeyDecorator(ProgramMonkey mProgramMonkey) {        this.mProgramMonkey = mProgramMonkey;    }    public void skills() {        mProgramMonkey.skills();    }}//ConcreteDecorator（具体装饰类）class PatternDecorator extends ProgramMonkeyDecorator {    public PatternDecorator(ProgramMonkey mProgramMonkey) {        super(mProgramMonkey);    }    @Override    public void skills() {        super.skills();        System.out.println(&quot;会设计模式！&quot;);    }}public class Main {    public static void main(String[] args) {        //有一个Android程序猿只会写Android代码        ProgramMonkey programMonkey = new AndroidProgramMonkey();        programMonkey.skills();        //装饰一下他，装逼的技能，他竟然除了写Android还懂设计模式        programMonkey = new PatternDecorator(programMonkey);        programMonkey.skills();        programMonkey = new PHPProgramMonkey();        programMonkey.skills();    }}</code></pre><h3 id="Java-I-O中的装饰模式"><a href="#Java-I-O中的装饰模式" class="headerlink" title="Java I/O中的装饰模式"></a>Java I/O中的装饰模式</h3><p><img src="https://img-blog.csdnimg.cn/20190228184318894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>InputStream是抽象构件 </li><li>FileInputStream是InputStream的子类，属于其中一个具体构件，提供字节流输入的操作；PipedInputStream、ByteArrayInputStream也是具体构件 </li><li>FilterInputStream是InputStream的子类，属于抽象装饰类，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 </li><li>DataInputStream、BufferedInputStream、PushBackInputStream都是具体装饰者 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88040936&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="设计模式" scheme="https://enpong.github.io/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaIO" scheme="https://enpong.github.io/tags/JavaIO/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="https://enpong.github.io/2019/02/28/java%E5%9F%BA%E7%A1%80/"/>
    <id>https://enpong.github.io/2019/02/28/java基础/</id>
    <published>2019-02-28T09:18:03.000Z</published>
    <updated>2019-04-09T07:59:14.149Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88036891" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88036891</a></p><ul><li>基本数据类型，byte/8、short/16、char/16、int/32、float/32、long/62、double/16、boolean（只有两个值，可以用1bit来表示，但是具体大小没有明确规定，JVM在编译时期将boolean类型的数据转成int类型） </li><li>包装数据类型，基本数据类型都有对应的包装数据类型，两者之间的转换过程为装箱拆箱，装箱：基本数据类型–&gt;包装数据类型； </li><li><p>缓存池：new Integer(123)每次都会新建一个对象，而使用Integer.valueOf(123)创建实例时，会先判断该值是否在缓存池中，如果在直接返回缓存池中的内容，因此多次调用会取得同一个对象的引用；在自动装箱过程中，编译器会自动调用valueOf()，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象；每个基本数据类型都有对应的缓存池，使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象，但是有大小限制；<br><img src="https://img-blog.csdnimg.cn/20190228162602511.png" alt="在这里插入图片描述"></p></li><li><p>String Pool(字符串常量池)：在String Pool中添加字符串有两种方法，一种是字符串字面量”abc”在编译时期就确定，另一种是通过调用intern()在程序运行时将字符串对象添加到String Pool并返回该字符串的引用。在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误 </p></li><li>switch：从Java7开始，可以在switch条件判断语句中使用String对象；switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适 </li><li>抽象类与接口：抽象类可以有构造方法而接口不行；接口的成员（字段和方法）默认都是public而抽象类可以是任意访问权限；接口的字段默认都是static和final修饰的而抽象类可以有普通成员变量 </li><li>重写的两个限制：子类方法访问权限必须大于等于父类的；子类方法返回值类型必须是父类的返回值类型或子类型 </li><li>重载：返回值类型、方法名相同；参数类型、个数、顺序不同 </li><li>equal(Object o)的实现：1.判断是否为同一对象的引用，如果是直接返回true；2.判断是否为同一类型（getClass())，如果不是直接返回false；3.将参数Object对象进行转型；4.判断每个关键域是否相等。 </li><li>hashCode()：hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等； </li><li>clone()：1.Object的一个protected方法，如果一个类不显式重写该方法，那该类就不能调用clone()方法；而且该类要实现Cloneable()标记接口，要不然调用时会抛出CloneNotSupportedException。2.使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 </li><li>深拷贝与浅拷贝：区别在于浅拷贝拷贝时碰到对象只是复制了对象的引用。 </li><li>异常： <img src="https://img-blog.csdnimg.cn/20190228171321744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Java与C++： <img src="https://img-blog.csdnimg.cn/20190228171618152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>参考： <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md" target="_blank" rel="noopener"> CS-Note/Java基础 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88036891&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
    
      <category term="基础" scheme="https://enpong.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
