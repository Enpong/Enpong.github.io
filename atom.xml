<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enpong</title>
  
  <subtitle>成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://enpong.github.io/"/>
  <updated>2019-04-20T13:11:08.224Z</updated>
  <id>https://enpong.github.io/</id>
  
  <author>
    <name>Enpong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS同步状态的获取和释放</title>
    <link href="https://enpong.github.io/2019/04/20/AQS%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE/"/>
    <id>https://enpong.github.io/2019/04/20/AQS同步状态的获取和释放/</id>
    <published>2019-04-20T12:13:12.000Z</published>
    <updated>2019-04-20T13:11:08.224Z</updated>
    
    <content type="html"><![CDATA[<p>AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：<font color="blue">独占式获取和释放同步状态</font>、<font color="pink">共享式获取和释放同步状态</font>、<font color="brown">查询同步队列中的等待线程情况</font>。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。</p><h5 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h5><p>　　独占式，同一时刻仅有一个线程持有同步状态。</p><h6 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="　　独占式同步状态获取"></a>　　独占式同步状态获取</h6><hr><p> 　　<code>acquire(int arg)</code>方法为 AQS 提供的模板方法，该方法为独占式获取同步状态，但是该方法<strong>对中断不敏感</strong>，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个方法定义如下：</p><ol><li><code>tryAcquire</code>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</li><li><code>addWaiter</code>：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><code>acquireQueued</code>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt</code>：产生一个中断。</li></ol><p>acquireQueued 方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//中断标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 自旋过程，其实就是一个死循环而已</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//当前线程的前驱节点是头结点，且同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取失败，线程等待--具体后面介绍</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p><ol><li>保持FIFO同步队列原则。</li><li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li></ol><p>acquire(int arg) 方法流程图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS同步状态的获取和释放/1.png"></p><h6 id="独占式获取响应中断"><a href="#独占式获取响应中断" class="headerlink" title="　　独占式获取响应中断"></a>　　独占式获取响应中断</h6><hr><p>　　AQS 提供了 acquire(int arg) 方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS 提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常 nterruptedException 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　首先校验该线程是否已经中断了，如果是则抛出 InterruptedException ，否则执行 tryAcquire(int arg) 方法获取同步状态，如果获取成功，则直接返回，否则执行<code>doAcquireInterruptibly(int arg)</code>。doAcquireInterruptibly(int arg) 定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　doAcquireInterruptibly(int arg) 方法与 acquire(int arg) 方法仅有两个差别。1.方法声明抛出 InterruptedException 异常；2.在中断方法处不再是使用 interrupted 标志，而是直接抛出 InterruptedException 异常。</p><h6 id="独占式超时获取"><a href="#独占式超时获取" class="headerlink" title="　　独占式超时获取"></a>　　独占式超时获取</h6><hr><p>　　AQS 除了提供上面两个方法外，还提供了一个增强版的方法：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为 acquireInterruptibly 方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回 false ，否则返回 true 。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　tryAcquireNanos(int arg, long nanosTimeout) 方法超时获取最终是在 doAcquireNanos(int arg, long nanosTimeout) 中实现的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//nanosTimeout &lt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">//新增Node节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//获取同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 获取失败，做超时、中断判断</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//重新计算需要休眠的时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//已经超时，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//如果没有超时，则等待nanosTimeout纳秒</span></span><br><span class="line">            <span class="comment">//注：该线程会直接从LockSupport.parkNanos中返回，</span></span><br><span class="line">            <span class="comment">//LockSupport为JUC提供的一个阻塞和唤醒的工具类，后面做详细介绍</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">//线程是否已经中断了</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　针对超时控制，程序首先记录唤醒时间 deadline  ，deadline = System.nanoTime() + nanosTimeout（时间间隔）。如果获取同步状态失败，则需要计算出需要休眠的时间间隔nanosTimeout（= deadline - System.nanoTime()），如果 nanosTimeout &lt;= 0 表示已经超时了，返回false，如果大于 spinForTimeoutThreshold（1000L） 则需要休眠 nanosTimeout  ，如果nanosTimeout &lt;= spinForTimeoutThreshold ，就不需要休眠了，直接进入快速自旋的过程。原因在于 spinForTimeoutThreshold 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让nanosTimeout 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。</p><p>　　整个流程如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS同步状态的获取和释放/2.png"></p><h6 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="　　独占式同步状态释放"></a>　　独占式同步状态释放</h6><hr><p>　　 当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS 提供了 release(int arg) 方法释放同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法同样是先调用自定义同步器自定义的 tryRelease(int arg) 方法来释放同步状态，释放成功后，会调用 unparkSuccessor(Node node) 方法唤醒后继节点。</p><p><strong>总结一下</strong>：</p><p>　　在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的队尾并一直保持着自旋。在 CLH 同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH 同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p><h5 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h5><p>　　共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><h6 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="　共享式同步状态获取"></a>　共享式同步状态获取</h6><hr><p>　　AQS 提供 <code>acquireShared(int arg)</code>方法共享式获取同步状态：　　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//获取失败，自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上面程序可以看出，方法首先是调用 tryAcquireShared(int arg) 方法尝试获取同步状态，如果获取失败则调用<code>doAcquireShared(int arg)</code>自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。自选式获取同步状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享式节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果其前驱节点，获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//尝试获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，返回值为 int ，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。</p><p>　　acquireShared(int arg) 方法不响应中断，与独占式相似，AQS 也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，这里就不做解释了。</p><h6 id="共享式同步状态释放"><a href="#共享式同步状态释放" class="headerlink" title="　　共享式同步状态释放"></a>　　共享式同步状态释放</h6><hr><p>　　获取同步状态后，需要调用<code>release(int arg)</code>方法释放同步状态，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：&lt;font color=&quot;blue&quot;&gt;独占式获取和释放同步状态&lt;/font&gt;、&lt;font colo
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/java/JUC/"/>
    
      <category term="AQS" scheme="https://enpong.github.io/categories/java/JUC/AQS/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="同步" scheme="https://enpong.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="队列" scheme="https://enpong.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="AQS" scheme="https://enpong.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS简介</title>
    <link href="https://enpong.github.io/2019/04/20/AQS%E7%AE%80%E4%BB%8B/"/>
    <id>https://enpong.github.io/2019/04/20/AQS简介/</id>
    <published>2019-04-20T11:35:17.000Z</published>
    <updated>2019-04-20T12:12:26.746Z</updated>
    
    <content type="html"><![CDATA[<h5 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h5><p>　　AQS，<code>AbstractQueuedSynchronizer</code>，即<strong>队列同步器</strong>。它是构建锁或者其他同步组件的基础框架（如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code>等），JUC 并发包的作者（ Doug Lea ）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。</p><p>　　AQS 解决了在实现同步器时涉及到的大量细节问题，例如<font color="green">获取同步状态、 FIFO 同步队列</font>。基于 AQS 来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>　　在基于 AQS 构建的同步器中，<font color="brown">只能在一个时刻发生阻塞</font>，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中所有基于 AQS 构建的同步器均可以获得这个优势。</p><p>　　AQS 的主要使用方式是<strong>继承</strong>，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>　　AQS 使用一个 int 类型的成员变量 state 来表示同步状态，当 state &gt; 0 时表示已经获取了锁，当 state = 0 时表示释放了锁。它提供了三个方法（ getState() 、setState(int newState) 、compareAndSetState(int expect,int update)）来对同步状态 state 进行操作，当然 AQS 可以确保对 state 的操作是安全的。</p><p>　　AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态（锁）失败时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><h5 id="AQS方法"><a href="#AQS方法" class="headerlink" title="AQS方法"></a>AQS方法</h5><ul><li><code>getState()</code>：返回同步状态的当前值；</li><li><code>setState(int newState)</code>：设置当前同步状态；</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li><li><code>tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li><li><code>tryRelease(int arg)</code>：独占式释放同步状态；</li><li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li><li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态；</li><li><code>isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li><li><code>acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li><li><code>acquireInterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li><li><code>tryAcquireNanos(int arg,long nanos)</code>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li><li><code>acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li><li><code>acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断；</li><li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制；</li><li><code>release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li><li><code>releaseShared(int arg)</code>：共享式释放同步状态；</li></ul><h5 id="CLH同步队列"><a href="#CLH同步队列" class="headerlink" title="CLH同步队列"></a>CLH同步队列</h5><p>　　CLH 同步队列是一个 FIFO 双向队列，AQS 依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS 则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到 CLH 同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>　　在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 共享 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** 独占 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示下一次共享式同步状态获取将会无条件地传播下去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">/** 等待状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">/** 前驱节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">/** 后继节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">/** 获取同步状态的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLH同步队列结构图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS简介/1.png"></p><h6 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h6><p>　　学了数据结构的我们，CLH 队列入列是再简单不过了，无非就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。代码我们可以看看addWaiter(Node node)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多次尝试</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　addWaiter(Node node) 先通过快速尝试设置尾节点，如果失败，则调用 enq(Node node) 方法设置尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//多次尝试，直到成功为止</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node t = tail;</span><br><span class="line">          <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">          <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                  tail = head;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//设置为尾节点</span></span><br><span class="line">              node.prev = t;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                  t.next = node;</span><br><span class="line">                  <span class="keyword">return</span> t;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>　　在上面代码中，两个方法都是通过一个 CAS 方法 <code>compareAndSetTail(Node expect, Node update)</code>来设置尾节点，该方法可以确保节点是线程安全添加的。在 <code>enq(Node node)</code> 方法中，AQS 通过“死循环”的方式来保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去。</p><p>过程图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS简介/2.png"></p><h6 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h6><p>　　CLH 同步队列遵循 FIFO ，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head 执行该节点并断开原首节点的 next 和当前节点的 prev 即可，注意在这个过程是不需要使用 CAS 来保证的，因为只有一个线程能够成功获取到同步状态。过程图如下：</p><p><img src="//enpong.github.io/2019/04/20/AQS简介/3.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;AQS简介&quot;&gt;&lt;a href=&quot;#AQS简介&quot; class=&quot;headerlink&quot; title=&quot;AQS简介&quot;&gt;&lt;/a&gt;AQS简介&lt;/h5&gt;&lt;p&gt;　　AQS，&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;，即&lt;strong&gt;队列同
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/java/JUC/"/>
    
      <category term="AQS" scheme="https://enpong.github.io/categories/java/JUC/AQS/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="同步" scheme="https://enpong.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="队列" scheme="https://enpong.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="AQS" scheme="https://enpong.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>线程池-tomcat</title>
    <link href="https://enpong.github.io/2019/04/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0-tomcat/"/>
    <id>https://enpong.github.io/2019/04/20/线程池-tomcat/</id>
    <published>2019-04-20T09:26:44.000Z</published>
    <updated>2019-04-20T11:19:03.612Z</updated>
    
    <content type="html"><![CDATA[<p>线程池在tomcat中的创建实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">        TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">"-exec-"</span>, daemon, getThreadPriority());</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">        taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时（重点）： <strong>tomcat 的线程池扩展了 jdk 的 executor ，而且队列用的是自己的 task queue ，因此其策略与 jdk 的有所不同，需要注意一下。</strong></p><h5 id="tomcat线程池策略"><a href="#tomcat线程池策略" class="headerlink" title="tomcat线程池策略"></a>tomcat线程池策略</h5><p>　　场景1：接受一个请求，此时 tomcat 启动的线程数还没有达到 corePoolSize ( tomcat 里头叫 minSpareThreads )， tomcat 会启动一个线程来处理该请求；</p><p>　　场景2：接受一个请求，此时 tomcat 启动的线程数已经达到了 corePoolSize ， tomcat 把该请求放入队列 (<code>offer</code>) ，如果放入队列成功，则返回，放入队列不成功，则尝试增加工作线程，在当前线程个数 &lt; maxThreads 的时候，可以继续增加线程来处理，超过 maxThreads 的时候，则继续往等待队列里头放，等待队列放不进去，则抛出 RejectedExecutionException ；</p><p>　　值得注意的是，使用 LinkedBlockingQueue 的话，默认是使用 Integer.MAX_VALUE ，即无界队列(这种情况下如果没有配置队列的 capacity 的话，队列始终不会满，那么始终无法进入开启新线程到达 maxThreads 个数的地步，则此时配置 maxThreads 其实是没有意义的)。</p><h6 id="tomcat等待队列"><a href="#tomcat等待队列" class="headerlink" title="tomcat等待队列"></a>tomcat等待队列</h6><p>　　而 TaskQueue 的队列 capacity 为 maxQueueSize ，默认也是 Integer.MAX_VALUE 。但是，<strong>其重写 offer 方法，当其线程池大小 &lt; maximumPoolSize 的时候，返回false，即在一定程度改写了队列满的逻辑</strong>，修复了使用LinkedBlockingQueue默认的 capacity为 Integer.MAX_VALUE 的时候， maxThreads 失效的 “bug” 。从而可以继续增长线程到 maxThreads ，超过之后，继续放入队列。</p><p>　　<strong>tomcat 的线程池使用了自己扩展的 taskQueue ，而不是 Executors 工厂方法里头用的 LinkedBlockingQueue 。(主要是修改了 offer 的逻辑)</strong> TaskQueue 实现的offer操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.tomcat.util.threads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">　　 <span class="keyword">private</span> ThreadPoolExecutor parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//we can't do any checks</span></span><br><span class="line">        <span class="keyword">if</span> (parent==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//we are maxed out on threads, simply queue the object</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//we have idle threads, just add it to the queue</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getSubmittedCount()&lt;(parent.getPoolSize())) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//当其线程池大小小于maximumPoolSize的时候，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//if we reached here, we need to add it to the queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="tomcat拒绝任务"><a href="#tomcat拒绝任务" class="headerlink" title="tomcat拒绝任务"></a>tomcat拒绝任务</h6><p>　　<strong>这里改写了 jdk 线程池默认的 Rejected 规则，即 catch 住了 RejectedExecutionException 。正常 jdk 的规则是 core 线程数＋临时线程数 &gt; maxSize 的时候，就抛出 RejectedExecutionException 。这里 catch 住的话，继续往 taskQueue 里头放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.tomcat.util.threads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.res.StringManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        execute(command,<span class="number">0</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        submittedCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.execute(command);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">                <span class="keyword">final</span> TaskQueue queue = (TaskQueue)<span class="keyword">super</span>.getQueue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                        submittedCount.decrementAndGet();</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity is full."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    Thread.interrupted();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> rx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下 queue.force 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">force</span><span class="params">(Runnable o, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( parent.isShutdown() ) <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Executor not running, can't force a command into the queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task is rejected</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　注意的是这里调用的 super.offer(o,timeout,unit) ，即 LinkedBlockingQueue ，只有当队列满的时候，返回 false ，才会抛出重新抛出 RejectedExecutionException 。</p><p>　　<strong>这里改变了 jdk 的 ThreadPoolExecutor 的 RejectedExecutionException 抛出的逻辑，也就是超出了 maxThreads 不会抛出 RejectedExecutionException ，而是继续往队列丢任务，而 taskQueue 本身是无界的，因此可以默认几乎不会抛出 RejectedExecutionException </strong></p><h5 id="回顾-JDK-线程池策略"><a href="#回顾-JDK-线程池策略" class="headerlink" title="回顾 JDK 线程池策略　"></a>回顾 JDK 线程池策略　</h5><ul><li>每次提交任务时，如果线程数还没达到 coreSize 就创建新线程并绑定该任务。所以第 coreSize 次提交任务后线程总数必达到 coreSize ，不会重用之前的空闲线程。</li><li>线程数达到 coreSize 后，新增的任务就放到工作队列里，而线程池里的线程则努力的使用 take() 从工作队列里拉活来干。</li><li>如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。</li><li>临时线程使用 poll(keepAliveTime，timeUnit) 来从工作队列拉活，如果时候到了仍然两手空空没拉到活，表明它太闲了，就会被解雇掉。</li><li>如果 core 线程数＋临时线程数  &gt; maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder 。默认的 AbortPolicy 抛 RejectedExecutionException 异常，其他选择包括静默放弃当前任务(Discard)，放弃工作队列里最老的任务(DisacardOldest)，或由主线程来直接执行(CallerRuns).</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>tomcat 的线程池与 jdk 的使用无界 LinkedBlockingQueue 主要有如下两点区别：</p><p>举个例子：假设队列大小为 10，corePoolSize 为 3，maximumPoolSize 为 6，那么当加入 20 个任务时</p><table><thead><tr><th>jdk有界执行任务过程</th><th></th></tr></thead><tbody><tr><td>核心线程(3)</td><td>1、2、3</td></tr><tr><td>等待队列(10)</td><td>4、5、6、… 12、13</td></tr><tr><td>非核心线程(3)</td><td>14、15、16</td></tr><tr><td>拒绝任务</td><td>17、18、19、20</td></tr><tr><td>任务执行顺序</td><td>1、2、3、14、15、16、4、5、6、… 12、13</td></tr></tbody></table><table><thead><tr><th>tomcat执行任务过程</th><th></th></tr></thead><tbody><tr><td>核心线程</td><td>1、2、3</td></tr><tr><td>等待队列（无界)</td><td>7、8、9、… 19、20</td></tr><tr><td>非核心线程</td><td>4、5、6</td></tr><tr><td>拒绝任务</td><td></td></tr><tr><td>任务执行顺序</td><td>1、2、3、4、5、6、… 19、20</td></tr></tbody></table><ul><li>ThreadPoolExecutor 的线程池增长策略是：<ul><li>如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。</li><li>而 tomcat 的 ThreadPoolExecutor 使用的 taskQueue ，是无界的 LinkedBlockingQueue ，但是通过 taskQueue 的 offer 方法覆盖了 LinkedBlockingQueue 的 offer 方法，改写了规则，使得它也走 jdk 的 ThreadPoolExecutor 的有界队列的线程增长策略。</li></ul></li><li>ThreadPoolExecutor 拒绝任务策略：<ul><li>jdk ，当 core线程数＋临时线程数 &gt; maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder 。</li><li>而 tomcat 的ThreadPoolExecutor 则改写了这个规则，即 catch 住了 RejectExecutionHanlder ，继续往队列里头放，直到队列满了才抛出 RejectExecutionHanlder 。而默认 taskQueue 是无界的。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程池在tomcat中的创建实现为：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/java/JUC/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="tomcat" scheme="https://enpong.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://enpong.github.io/2019/04/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://enpong.github.io/2019/04/20/线程池/</id>
    <published>2019-04-20T08:44:09.000Z</published>
    <updated>2019-04-20T11:29:39.361Z</updated>
    
    <content type="html"><![CDATA[<p>　　JAVA语言为我们提供了两种基础线程池的选择：<code>ScheduledThreadPoolExecutor</code>和<code>ThreadPoolExecutor</code>。它们都实现了<code>ExecutorService</code>接口<font color="green">（注意，ExecutorService接口本身和“线程池”并没有直接关系，它的定义更接近“执行器”，而“使用线程管理的方式进行实现”只是其中的一种实现方式）</font>。这篇文章中，我们主要围绕 ThreadPoolExecutor 类进行讲解。</p><h5 id="ThreadPoolExecutor的构造方法"><a href="#ThreadPoolExecutor的构造方法" class="headerlink" title="ThreadPoolExecutor的构造方法"></a>ThreadPoolExecutor的构造方法</h5><h6 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||  maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　构造函数中需要传入的参数包括<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>keepAliveTime</code>、<code>timeUnit</code>和<code>workQueue</code>。要明确理解这些参数（和后续将要介绍的参数）的含义，就首先要搞清楚 ThreadPoolExecutor 线程池的逻辑结构。</p><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/1.jpg"></div><p>　　一定要注意一个概念，即<font color="pink">存在于线程池中容器的一定是 Thread 对象，而不是您要求运行的任务</font>（所以叫线程池而不叫任务池也不叫对象池，更不叫游泳池）；您要求运行的任务将被线程池分配给某一个空闲的 Thread 运行。从上图中，我们可以看到构成线程池的几个重要元素：</p><ul><li><strong>等待队列</strong>：顾名思义，就是您调用线程池对象的 submit() 方法或者 execute() 方法，要求线程池运行的任务（这些任务必须实现 Runnable 接口或者 Callable 接口）。但是出于某些原因线程池并没有马上运行这些任务，而是送入一个队列等待执行。</li><li><strong>核心线程</strong>：线程池主要用于执行任务的是“核心线程”，“核心线程”的数量是您创建线程时所设置的 corePoolSize 参数决定的。如果不进行特别的设定，线程池中始终会保持 corePoolSize 数量的线程数（不包括创建阶段）。</li><li><strong>非核心线程</strong>：一旦任务数量过多（由等待队列的特性决定），线程池将创建“非核心线程”临时帮助运行任务。您设置的大于 corePoolSize 参数小于 maximumPoolSize 参数的部分，就是线程池可以临时创建的“非核心线程”的最大数量。<font color="pink">这种情况下如果某个线程没有运行任何任务，在等待 keepAliveTime 时间后，这个线程将会被销毁，直到线程池的线程数量重新达到corePoolSize</font>。<font color="blue">也就是说，并不是所谓的“非核心线程”才会被回收；而是谁的空闲时间达到 keepAliveTime 这个阀值，就会被回收。直到线程池中线程数量等于 corePoolSize 为止</font>。</li><li>maximumPoolSize 参数也是当前线程池允许创建的最大线程数量。那么如果您设置的 corePoolSize 参数和您设置的 maximumPoolSize 参数一致时，线程池在任何情况下都不会回收空闲线程。 keepAliveTime 和 timeUnit 也就失去了意义。</li><li>keepAliveTime 参数和 timeUnit 参数也是配合使用的。 keepAliveTime 参数指明等待时间的量化值， timeUnit 指明量化值单位。例如 keepAliveTime=1，timeUnit 为 TimeUnit.MINUTES ，代表空闲线程的回收阀值为1分钟。</li></ul><h6 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h6><ul><li><p>CachedThreadPool：一个任务创建一个线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>FixedThreadPool：所有任务只能使用固定大小的线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="完整的任务处理过程"><a href="#完整的任务处理过程" class="headerlink" title="完整的任务处理过程"></a>完整的任务处理过程</h6><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/2.jpg"></div><p>　　1、首先您可以通过线程池提供的 submit() 方法或者 execute() 方法，要求线程池执行某个任务。线程池收到这个要求执行的任务后，会有几种处理情况：</p><p>　　　　1.1、如果当前线程池中运行的线程数量还没有达到 corePoolSize 大小时，线程池会创建一个新的线程运行您的任务，<font color="red">无论之前已经创建的线程是否处于空闲状态</font>。</p><p>　　　　1.2、如果当前线程池中运行的线程数量已经达到设置的 corePoolSize 大小，线程池会把您的这个任务加入到等待队列中。直到某一个的线程空闲了，线程池会根据您设置的等待队列规则，从队列中取出一个新的任务执行。</p><p>　　　　1.3、<font color="red">如果根据队列规则，这个任务无法加入等待队列。这时线程池就会创建一个“非核心线程”直接运行这个任务</font>。注意，如果这种情况下任务执行成功，那么当前线程池中的线程数量一定大于 corePoolSize 。</p><p>　　　　1.4、如果这个任务，无法被“核心线程”直接执行，又无法加入等待队列，又无法创建“非核心线程”直接执行，且您没有为线程池设置<code>RejectedExecutionHandler</code>。这时线程池会抛出 RejectedExecutionException 异常，即线程池拒绝接受这个任务。（<font color="red">实际上抛出 RejectedExecutionException 异常的操作，是 ThreadPoolExecutor 线程池中一个默认的 RejectedExecutionHandler 实现：<code>AbortPolicy</code></font>）</p><p>　　2、一旦线程池中某个线程完成了任务的执行，它就会试图到任务等待队列中拿去下一个等待任务（所有的等待任务都实现了<code>BlockingQueue</code>接口，按照接口字面上的理解，这是一个可阻塞的队列接口），它会调用等待队列的 poll() 方法，并停留在哪里。</p><p>　　3、当线程池中的线程超过您设置的 corePoolSize 参数，说明当前线程池中有所谓的“非核心线程”。那么当某个线程处理完任务后，如果等待 keepAliveTime 时间后仍然没有新的任务分配给它，那么这个线程将会被回收。线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于您设置的 corePoolSize 参数时，回收过程才会停止，还有回收的前提条件是线程数大于 corePoolSize。</p><h5 id="allowCoreThreadTimeOut"><a href="#allowCoreThreadTimeOut" class="headerlink" title="allowCoreThreadTimeOut"></a>allowCoreThreadTimeOut</h5><p>　　前文我们讨论到，线程池回收线程只会发生在当前线程池中线程数量大于 corePoolSize 参数的时候；当线程池中线程数量小于等于 corePoolSize 参数的时候，回收过程就会停止。 allowCoreThreadTimeOut 设置项可以要求线程池：将包括“核心线程”在内的，没有任务分配的任何线程，在等待 keepAliveTime 时间后全部进行回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>));</span><br><span class="line">poolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h5 id="prestartAllCoreThreads"><a href="#prestartAllCoreThreads" class="headerlink" title="prestartAllCoreThreads"></a>prestartAllCoreThreads</h5><p>　　前文我们还讨论到，当线程池中的线程还没有达到您设置的 corePoolSize 参数值的时候，如果有新的任务到来，线程池将创建新的线程运行这个任务，无论之前已经创建的线程是否处于空闲状态。这个描述可以用下面的示意图表示出来：</p><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/3.jpg"></div><p>　　<code>prestartAllCoreThreads</code>设置项，可以在线程池创建，但还没有接收到任何任务的情况下，先行创建符合 corePoolSize 参数值的线程数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>));</span><br><span class="line">poolExecutor.prestartAllCoreThreads();</span><br></pre></td></tr></table></figure><h5 id="使用ThreadFactory"><a href="#使用ThreadFactory" class="headerlink" title="使用ThreadFactory"></a>使用ThreadFactory</h5><p> 　　线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在 ThreadPoolExecutor 线程池中，创建线程的工作交给<code>ThreadFactory</code>来完成。<font color="sandybrown">要使用线程池，就必须要指定ThreadFactory</font>。</p><p>　　 如果我们使用的构造函数时并没有指定使用的 ThreadFactory ，这个时候 ThreadPoolExecutor 会使用一个默认的 ThreadFactory：<code>DefaultThreadFactory</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.thread.pool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试自定义的一个线程工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something before new thread created;</span></span><br><span class="line">        <span class="comment">// create new thread ， and return</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程池的等待队列"><a href="#线程池的等待队列" class="headerlink" title="线程池的等待队列"></a>线程池的等待队列</h5><p>　　在使用 ThreadPoolExecutor 线程池的时候，需要指定一个实现了 BlockingQueue接口的任务等待队列。在 ThreadPoolExecutor 线程池的 API 文档中，一共推荐了三种等待队列，它们是：<code>SynchronousQueue</code>、<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>；但通过观察 BlockingQueue 接口的实现情况，您可以发现，能够直接使用的等待队列还有：<code>PriorityBlockingQueue</code>、<code>LinkedBlockingDeque</code>和<code>LinkedTransferQueue</code>。</p><div align="center"><img src="//enpong.github.io/2019/04/20/线程池/4.jpg"></div><h6 id="有限队列"><a href="#有限队列" class="headerlink" title="有限队列"></a>有限队列</h6><ul><li><p><code>SynchronousQueue</code>： 一种阻塞队列，其中每个 put 必须等待一个 take，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。即这是<font color="palegoldenrod">一个内部没有任何容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行插入操作的线程就要一直等待，反之亦然</font>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;Object&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;Object&gt;();</span><br><span class="line"><span class="comment">// 不要使用add，因为这个队列内部没有任何容量，所以会抛出异常“IllegalStateException”</span></span><br><span class="line"><span class="comment">// queue.add(new Object());</span></span><br><span class="line"><span class="comment">// 操作线程会在这里被阻塞，直到有其他操作线程取走这个对象</span></span><br><span class="line">queue.put(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>ArrayBlockingQueue</code>：一个由数组支持的有界阻塞队列。此队列按  FIFO （先进先出）原则对元素进行排序。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。<font color="red">一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞</font>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们创建了一个ArrayBlockingQueue，并且设置队列空间为2</span></span><br><span class="line">ArrayBlockingQueue&lt;Object&gt; arrayQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Object&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 插入第一个对象</span></span><br><span class="line">arrayQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第二个对象</span></span><br><span class="line">arrayQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第三个对象时，这个操作线程就会被阻塞。</span></span><br><span class="line">arrayQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 请不要使用add操作，和SynchronousQueue的add操作一样，它们都使用了AbstractQueue中的add实现</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="无限队列"><a href="#无限队列" class="headerlink" title="无限队列"></a>无限队列</h6><ul><li><p><code>LinkedBlockingQueue</code>： 在 ThreadPoolExecutor 线程池中常应用的等待队列。它可以指定容量也可以不指定容量。由于它具有“无限容量”的特性，所以我还是将它归入了无限队列的范畴（实际上任何无限容量的队列/栈都是有容量的，这个容量就是 Integer.MAX_VALUE ）。 LinkedBlockingQueue 的实现是基于链表结构，而不是类似 ArrayBlockingQueue 那样的数组。但实际使用过程中，您不需要关心它的内部实现，如果您指定了 LinkedBlockingQueue 的容量大小，那么它反映出来的使用特性就和 ArrayBlockingQueue 类似了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue&lt;Object&gt; linkedQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;(<span class="number">2</span>);</span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第二个对象</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第三个对象时，这个操作线程就会被阻塞。</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line">=======================================</span><br><span class="line"><span class="comment">// 或者如下使用：</span></span><br><span class="line">LinkedBlockingQueue&lt;Object&gt; linkedQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第二个对象</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 插入第N个对象时，都不会阻塞</span></span><br><span class="line">linkedQueue.put(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure></li><li><p><code>LinkedBlockingDeque</code>：一个基于链表的双端队列。 LinkedBlockingQueue 的内部结构决定了它只能从队列尾部插入，从队列头部取出元素；但是 LinkedBlockingDeque 既可以从尾部插入/取出元素，还可以从头部插入元素/取出元素。</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingDeque&lt;TempObject&gt; linkedDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;TempObject&gt;();</span><br><span class="line"><span class="comment">// push ，可以从队列的头部插入元素</span></span><br><span class="line">linkedDeque.push(<span class="keyword">new</span> TempObject(<span class="number">1</span>));</span><br><span class="line">linkedDeque.push(<span class="keyword">new</span> TempObject(<span class="number">2</span>));</span><br><span class="line">linkedDeque.push(<span class="keyword">new</span> TempObject(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// poll ， 可以从队列的头部取出元素</span></span><br><span class="line">TempObject tempObject = linkedDeque.poll();</span><br><span class="line"><span class="comment">// 这里会打印 tempObject.index = 3</span></span><br><span class="line">System.out.println(<span class="string">"tempObject.index = "</span> + tempObject.getIndex());</span><br><span class="line"></span><br><span class="line"><span class="comment">// put ， 可以从队列的尾部插入元素</span></span><br><span class="line">linkedDeque.put(<span class="keyword">new</span> TempObject(<span class="number">4</span>));</span><br><span class="line">linkedDeque.put(<span class="keyword">new</span> TempObject(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// pollLast , 可以从队列尾部取出元素</span></span><br><span class="line">tempObject = linkedDeque.pollLast();</span><br><span class="line"><span class="comment">// 这里会打印 tempObject.index = 5</span></span><br><span class="line">System.out.println(<span class="string">"tempObject.index = "</span> + tempObject.getIndex());</span><br></pre></td></tr></table></figure><ul><li><p><code>PriorityBlockingQueue</code>： 一个按照优先级进行内部元素排序的无限队列。存放在 PriorityBlockingQueue 中的元素必须实现 Comparable 接口，这样才能通过实现 compareTo() 方法进行排序。优先级最高的元素将始终排在队列的头部；<font color="red"> PriorityBlockingQueue 不会保证优先级一样的元素的排序，也不保证当前队列中除了优先级最高的元素以外的元素，随时处于正确排序的位置</font>。</p></li><li><p><code>LinkedTransferQueue</code>：一个无限队列，它除了具有一般队列的操作特性外（先进先出），还具有一个<strong>阻塞特性</strong>： LinkedTransferQueue 可以由一对生产者/消费者线程进行操作，当消费者将一个新的元素插入队列后，消费者线程将会一直等待，直到某一个消费者线程将这个元素取走，反之亦然。</p></li></ul><h5 id="拒绝任务"><a href="#拒绝任务" class="headerlink" title="　　拒绝任务"></a>　　拒绝任务</h5><p>　　在 ThreadPoolExecutor 线程池中还有一个重要的接口：<code>RejectedExecutionHandler</code>。<strong>当提交给线程池的某一个新任务无法直接被线程池中“核心线程”直接处理，又无法加入等待队列，也无法创建新的线程执行；又或者线程池已经调用 shutdown() 方法停止了工作；又或者线程池不是处于正常的工作状态；这时候 ThreadPoolExecutor 线程池会拒绝处理这个任务，触发您创建 ThreadPoolExecutor 线程池时定义的 RejectedExecutionHandler 接口的实现。</strong></p><p>　　ThreadPoolExecutor线程池在创建时，会使用一个默认的 RejectedExecutionHandler 接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default rejected execution handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">        <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看到，ThreadPoolExecutor中的两个没有指定RejectedExecutionHandler</span></span><br><span class="line">    <span class="comment">// 接口的构造函数，都是使用了一个RejectedExecutionHandler接口的默认实现：AbortPolicy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　实际上，在 ThreadPoolExecutor 中已经提供了四种可以直接使用的 RejectedExecutionHandler 接口的实现：</p><ul><li><code>CallerRunsPolicy</code>：这个拒绝处理器，将直接运行这个任务的 run 方法。但是，请注意并不是在 ThreadPoolExecutor 线程池中的线程中运行，而是直接调用这个任务实现的 run 方法。</li><li><code>AbortPolicy</code>：这个处理器，在任务被拒绝后会创建一个 RejectedExecutionException 异常并抛出。这个处理过程也是 ThreadPoolExecutor 线程池默认的 RejectedExecutionHandler 实现。</li><li><code>DiscardPolicy</code> ： DiscardPolicy处理器，将会<strong>默默丢弃</strong>这个被拒绝的任务，不会抛出异常，也不会通过其他方式执行这个任务的任何一个方法，更不会出现任何的日志提示。</li><li><code>DiscardOldestPolicy</code>：这个处理器很有意思。它会检查当前ThreadPoolExecutor线程池的等待队列。并调用队列的 poll() 方法，将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。</li></ul><blockquote><p>　    CallerRunsPolicy 在非线程池以外直接调用任务的 run 方法，可能会造成线程安全上的问题；</p><p>​    DiscardPolicy 默默的忽略掉被拒绝任务，也没有输出日志或者提示，开发人员不会知道线程池的处理过程出现了错误；</p><p>​    DiscardOldestPolicy 中 e.getQueue().poll() 的方式好像是科学的，但是如果等待队列出现了容量问题，大多数情况下就是这个线程池的代码出现了 BUG 。</p><p>​    <strong>最科学的的还是 AbortPolicy 提供的处理方式：抛出异常，由开发人员进行处理</strong>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　JAVA语言为我们提供了两种基础线程池的选择：&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;和&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。它们都实现了&lt;code&gt;ExecutorService&lt;/code&gt;接口&lt;fo
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="JUC" scheme="https://enpong.github.io/categories/java/JUC/"/>
    
    
      <category term="线程" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="阻塞队列" scheme="https://enpong.github.io/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>spring AOP</title>
    <link href="https://enpong.github.io/2019/04/20/spring-AOP/"/>
    <id>https://enpong.github.io/2019/04/20/spring-AOP/</id>
    <published>2019-04-20T07:13:02.000Z</published>
    <updated>2019-04-20T07:21:54.144Z</updated>
    
    <content type="html"><![CDATA[<h5 id="存在的意义"><a href="#存在的意义" class="headerlink" title="存在的意义"></a>存在的意义</h5><blockquote><p>面向对象编程（ OOP ）有一些弊端，当需要为多个不具有继承关系的对象引人同一个公共行为时，例如日志、安全检测等，我们只有在每个对象里引用公共行为，这样程序中就产生了大量的重复代码，程序就不便于维护了，所以就有了一个对面向对象编程的补充，即面向方面编程（ AOP ), AOP 所关注的方向是横向的，不同于OOP 的纵向。</p></blockquote><h5 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h5><ol><li>通知<code>Advice</code>：你想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下 ；</li><li>连接点<code>JoinPoint</code>：spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的钱、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点 ；</li><li>切入点<code>PoinCut</code>：你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法 ；</li><li>切面<code>Aspect</code>：通知和切入点的结合 ，通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义 ；</li><li>织入<code>Weaving</code>：切面应用到目标对象来创建新的代理对象的过程 。</li></ol><h5 id="常用的AOP"><a href="#常用的AOP" class="headerlink" title="常用的AOP"></a>常用的AOP</h5><p><code>AspectJ</code>、<code>JBossAOP</code>、<code>SpringAOP</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;存在的意义&quot;&gt;&lt;a href=&quot;#存在的意义&quot; class=&quot;headerlink&quot; title=&quot;存在的意义&quot;&gt;&lt;/a&gt;存在的意义&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;面向对象编程（ OOP ）有一些弊端，当需要为多个不具有继承关系的对象引人同一个公共行为时
      
    
    </summary>
    
      <category term="ssm" scheme="https://enpong.github.io/categories/ssm/"/>
    
      <category term="spring" scheme="https://enpong.github.io/categories/ssm/spring/"/>
    
      <category term="AOP" scheme="https://enpong.github.io/categories/ssm/spring/AOP/"/>
    
    
      <category term="spring" scheme="https://enpong.github.io/tags/spring/"/>
    
      <category term="AOP" scheme="https://enpong.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>spring IOC</title>
    <link href="https://enpong.github.io/2019/04/20/spring-IOC/"/>
    <id>https://enpong.github.io/2019/04/20/spring-IOC/</id>
    <published>2019-04-20T06:45:13.000Z</published>
    <updated>2019-04-20T06:59:50.920Z</updated>
    
    <content type="html"><![CDATA[<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>spring ioc是spring的特性，称为控制反转。将对象的创建、初始化和销毁交由容器管理。实现方式有依赖查找和依赖注入。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在spring容器启动的时候，通过反射的方式，主动加载（或延迟加载）我们主动配置的bean以及该bean的依赖对象。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>在不同的业务之间的相互调用，我们无需去关注业务对象的产生。而更注重业务之间的逻辑，这在复杂工程中显得尤为重要。 </p><h5 id="spring构造对象的三种方法"><a href="#spring构造对象的三种方法" class="headerlink" title="spring构造对象的三种方法"></a>spring构造对象的三种方法</h5><ol><li><p>采用默认的构造函数创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mc.base.learn.spring.bean.Person"</span> <span class="attr">id</span>=<span class="string">"person"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>静态工厂创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"com.mc.base.learn.spring.factory.PersonStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createPerson"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>实例化工厂</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   　　<span class="comment">&lt;!-- 实例工程方法需要先创建工厂实例，然后在创建所需对象的时候，将其赋值为factory-bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personFactory"</span> <span class="attr">class</span>=<span class="string">"com.mc.base.learn.spring.factory.PersonFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">factory-bean</span>=<span class="string">"personFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="spring初始化的三种方式"><a href="#spring初始化的三种方式" class="headerlink" title="spring初始化的三种方式"></a>spring初始化的三种方式</h5><ol><li>通过实现 <code>InitializingBean/DisposableBean</code> 接口来定制初始化之后/销毁之前的操作方法； </li><li>通过<code>&lt;bean&gt;</code>元素的<code>init-method/destroy-method</code>属性指定初始化之后 /销毁之前调用的操作方法； </li><li>在指定方法上加上@PostConstruct 或@PreDestroy注解来制定该方法是在初始化之后还是销毁之前调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h5&gt;&lt;p&gt;spring ioc是spring的特性，称为控制反转。将对象的创建、初始化和销毁交由容器管理。实现方式有依赖查找和依赖注入。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="ssm" scheme="https://enpong.github.io/categories/ssm/"/>
    
      <category term="spring" scheme="https://enpong.github.io/categories/ssm/spring/"/>
    
    
      <category term="spring" scheme="https://enpong.github.io/tags/spring/"/>
    
      <category term="IOC" scheme="https://enpong.github.io/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://enpong.github.io/2019/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://enpong.github.io/2019/04/19/单例模式/</id>
    <published>2019-04-19T05:56:25.000Z</published>
    <updated>2019-04-20T12:29:14.738Z</updated>
    
    <content type="html"><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>确保一个类只有一个实例，并提供该实例的全局访问点 。</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul><li><code>私有构造函数</code>、<code>私有静态变量</code>、<code>公有静态函数</code></li><li>保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量 </li></ul><div align="center"><img src="//enpong.github.io/2019/04/19/单例模式/1.png"></div><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><h6 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h6><ul><li><h6 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h6></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h5&gt;&lt;p&gt;确保一个类只有一个实例，并提供该实例的全局访问点 。&lt;/p&gt;
&lt;h5 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;he
      
    
    </summary>
    
      <category term="设计模式" scheme="https://enpong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://enpong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="创建型模式" scheme="https://enpong.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链</title>
    <link href="https://enpong.github.io/2019/04/19/%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
    <id>https://enpong.github.io/2019/04/19/责任链/</id>
    <published>2019-04-19T03:20:12.000Z</published>
    <updated>2019-04-19T03:28:52.908Z</updated>
    
    <content type="html"><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 </p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><div align="center"><img src="//enpong.github.io/2019/04/19/责任链/1.png"></div><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteHandler1</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.TYPE1) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">" is handle by ConcreteHandler1"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteHandler2</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.TYPE2) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">" is handle by ConcreteHandler2"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RequestType type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(RequestType type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</span><br><span class="line">    TYPE1, TYPE2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler1(<span class="keyword">null</span>);</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler2(handler1);</span><br><span class="line"></span><br><span class="line">        Request request1 = <span class="keyword">new</span> Request(RequestType.TYPE1, <span class="string">"request1"</span>);</span><br><span class="line">        handler2.handleRequest(request1);</span><br><span class="line"></span><br><span class="line">        Request request2 = <span class="keyword">new</span> Request(RequestType.TYPE2, <span class="string">"request2"</span>);</span><br><span class="line">        handler2.handleRequest(request2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; request1 is handle by ConcreteHandler1</span><br><span class="line">&gt; request2 is handle by ConcreteHandler2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="Java中的应用"><a href="#Java中的应用" class="headerlink" title="Java中的应用"></a>Java中的应用</h5><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29" target="_blank" rel="noopener">java.util.logging.Logger#log()</a></li><li><a href="https://commons.apache.org/proper/commons-chain/index.html" target="_blank" rel="noopener">Apache Commons Chain</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-" target="_blank" rel="noopener">javax.servlet.Filter#doFilter()</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h5&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为
      
    
    </summary>
    
      <category term="设计模式" scheme="https://enpong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://enpong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="行为型模式" scheme="https://enpong.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://enpong.github.io/2019/04/18/机器人的运动范围/</id>
    <published>2019-04-18T06:01:23.000Z</published>
    <updated>2019-04-18T06:09:13.849Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p><blockquote><p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>深度遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] digitSum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">    initDigitSum();</span><br><span class="line">    <span class="keyword">boolean</span>[][] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    dfs(marked, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] marked, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols || marked[r][c])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.digitSum[r][c] &gt; <span class="keyword">this</span>.threshold)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] n : next)</span><br><span class="line">        dfs(marked, r + n[<span class="number">0</span>], c + n[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDigitSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] digitSumOne = <span class="keyword">new</span> <span class="keyword">int</span>[Math.max(rows, cols)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digitSumOne.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digitSumOne[i] += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.digitSum = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++)</span><br><span class="line">            <span class="keyword">this</span>.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="dfs" scheme="https://enpong.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>矩阵中的路径</title>
    <link href="https://enpong.github.io/2019/04/18/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://enpong.github.io/2019/04/18/矩阵中的路径/</id>
    <published>2019-04-18T05:32:26.000Z</published>
    <updated>2019-04-18T06:01:00.140Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><p>例如下面的矩阵包含了一条 bfce 路径。</p><div align="center"><img src="//enpong.github.io/2019/04/18/矩阵中的路径/12_1.png"></div><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>回溯法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rows == <span class="number">0</span> || cols == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">boolean</span>[][] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = buildMatrix(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            <span class="keyword">if</span> (backtracking(matrix, str, marked, <span class="number">0</span>, i, j))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[][] marked, <span class="keyword">int</span> pathLen, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pathLen == str.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols || matrix[r][c] != str[pathLen] || marked[r][c])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] n : next)</span><br><span class="line">        <span class="keyword">if</span> (backtracking(matrix, str, marked, pathLen + <span class="number">1</span>, r + n[<span class="number">0</span>], c + n[<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] buildMatrix(<span class="keyword">char</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, idx = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            matrix[i][j] = array[idx++];</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="回溯" scheme="https://enpong.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="路径" scheme="https://enpong.github.io/tags/%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://enpong.github.io/2019/04/18/旋转数组的最小数字/</id>
    <published>2019-04-18T05:15:05.000Z</published>
    <updated>2019-04-18T05:26:41.398Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><blockquote><p>{3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为 O(logN)。</p><p>本题可以修改二分查找算法进行求解：</p><ul><li>当 nums[m] &lt;= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m；</li><li>否则解在 [m + 1, h] 之间，令 l = m + 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == nums[m] &amp;&amp; nums[m] == nums[h])</span><br><span class="line">            <span class="keyword">return</span> minNumber(nums, l, h);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; h; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二分查找" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>矩形覆盖</title>
    <link href="https://enpong.github.io/2019/04/18/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>https://enpong.github.io/2019/04/18/矩形覆盖/</id>
    <published>2019-04-18T04:55:15.000Z</published>
    <updated>2019-04-18T05:13:07.941Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ </p><div align="center"><img src="//enpong.github.io/2019/04/18/矩形覆盖/11_1.gif"></div><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>由于小矩形的尺寸是2×1，所以有大矩形为2×<em>n</em>的存在，那么我们第一步就可以有两种处理方式：</p><ul><li>第一步如果选择竖方向填充，那么该问题的规模就缩减为对于剩余的<code>2*(n-1)</code>的大矩形的填充 ；</li><li>第一步如果选择横方向的填充，则第二排的前面两个小矩形也只能如此填充，那么该问题的规模就缩减为对于剩余的<code>2*(n-2)</code>的大矩形的填充 。</li><li>结合上述分析，很容易得到递推的关系： <code>rectCover(n) = rectCover(n-1)+rectCover(n-2)</code>。当然此处也要注意递归跳出条件的判定 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> ret1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        ret = ret1 + ret2;</span><br><span class="line">        ret1 = ret2;</span><br><span class="line">        ret2 = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://enpong.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://enpong.github.io/2019/04/18/斐波那契数列/</id>
    <published>2019-04-18T04:44:42.000Z</published>
    <updated>2019-04-18T04:54:56.699Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>求斐波那契数列的第 n 项，n &lt;= 39。 </p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><div align="center"><img src="//enpong.github.io/2019/04/18/斐波那契数列/10_1.jpg"></div><ul><li><p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span>[] fib = <span class="keyword">new</span> fib[n+<span class="number">1</span>];</span><br><span class="line">    fib[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        fib[i] = fib[i-<span class="number">1</span>] + fib[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 <code>O(N)</code> 降低为 <code>O(1)</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> fib1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fib2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        result = fib1 + fib2;</span><br><span class="line">        fib1 = fib2;</span><br><span class="line">        fib2 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;求斐波那契数列的第 n 项，n &amp;lt;= 39。 &lt;/p&gt;
&lt;h5 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://enpong.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="空间优化" scheme="https://enpong.github.io/tags/%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://enpong.github.io/2019/04/18/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://enpong.github.io/2019/04/18/用两个栈实现队列/</id>
    <published>2019-04-17T19:42:52.000Z</published>
    <updated>2019-04-17T19:50:42.122Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。 </p><div align="center"><img src="//enpong.github.io/2019/04/18/用两个栈实现队列/9_1.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">            out.push(in.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span>(out.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty!"</span>);</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 &lt;/p&gt;
&lt;h4 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://enpong.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://enpong.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的下一个结点</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://enpong.github.io/2019/04/18/二叉树的下一个结点/</id>
    <published>2019-04-17T19:10:37.000Z</published>
    <updated>2019-04-17T19:42:10.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>该节点的右子树不为空，则下一节点是该节点右子树中最左节点；</p><div align="center"><img src="//enpong.github.io/2019/04/18/二叉树的下一个结点/8_1.gif"></div></li></ol><ol start="2"><li><p>该节点的右子树为空，则下一节点是包含该节点的最小左子树的子树根节点。</p><div align="center"><img src="//enpong.github.io/2019/04/18/二叉树的下一个结点/8_2.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getNext</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode temp = node.right;</span><br><span class="line">        <span class="keyword">while</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode parent = node.parent;</span><br><span class="line">            <span class="keyword">if</span>(parent.left==node)</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="中序" scheme="https://enpong.github.io/tags/%E4%B8%AD%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://enpong.github.io/2019/04/18/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://enpong.github.io/2019/04/18/重建二叉树/</id>
    <published>2019-04-17T18:07:54.000Z</published>
    <updated>2019-04-17T19:10:01.869Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder =  [9,3,15,20,7]</span><br></pre></td></tr></table></figure><div align="center"><img src="//enpong.github.io/2019/04/18/重建二叉树/7_1.gif"></div><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。 </p><div align="center"><img src="//enpong.github.io/2019/04/18/重建二叉树/7_2.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;<span class="keyword">this</span>.val = val; left = <span class="keyword">null</span>; right = <span class="keyword">null</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存中序遍历数组每个值对应的索引</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; indexForInOrder = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">        indexForInOrder.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBianryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：前序遍历数组、前序部分数组左边界，前序部分数组右边界、中序部分数组左边界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> leftTreeSize = indexForInOrder(root.val) - inL;</span><br><span class="line">    <span class="comment">//对于preL和preR的计算：DLR</span></span><br><span class="line">    <span class="comment">//对于inL的计算：LDR</span></span><br><span class="line">    root.left = reConstructBinaryTree(pre, preL+<span class="number">1</span>, preL+leftTreeSize, inL);<span class="comment">//D(L)R</span></span><br><span class="line">    root.right = reConstructBinaryTree(pre, preL+leftSize+<span class="number">1</span>, preR, inL+leftTreeSize+<span class="number">1</span>);<span class="comment">//DL(R)</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>重建一棵二叉树：</p><ol><li><p>前序+中序</p></li><li><p>后序+中序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;<span class="keyword">this</span>.val = val; left = <span class="keyword">null</span>; right = <span class="keyword">null</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存中序遍历数组每个值对应的索引</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; indexForInOrder = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] next, <span class="keyword">int</span>[] in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">        indexForInOrder.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBianryTree(next, next.length-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：后序遍历数组、后序部分数组右边界，后序部分数组左边界、中序部分数组左边界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] next, <span class="keyword">int</span> nextR, <span class="keyword">int</span> nextL, <span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextL &gt; nextR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(next[nextR]);</span><br><span class="line">    <span class="keyword">int</span> rightTreeSize = indexForInOrder(root.val) - inL;</span><br><span class="line">    <span class="comment">//对于nextR和nextL的计算：LRD</span></span><br><span class="line">    <span class="comment">//对于inL的计算：LDR</span></span><br><span class="line">    root.right = reConstructBinaryTree(next, nextR-<span class="number">1</span>, nextR-rightTreeSize, inL);<span class="comment">//L(R)D</span></span><br><span class="line">    root.left = reConstructBinaryTree(pre, nextR-rightTreeSize-<span class="number">1</span>, nextL, inL+leftTreeSize+<span class="number">1</span>);<span class="comment">//(L)RD</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="前序" scheme="https://enpong.github.io/tags/%E5%89%8D%E5%BA%8F/"/>
    
      <category term="后序" scheme="https://enpong.github.io/tags/%E5%90%8E%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://enpong.github.io/2019/04/18/从尾到头打印链表/</id>
    <published>2019-04-17T17:12:02.000Z</published>
    <updated>2019-04-18T04:30:49.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>反转链表，返回反转后链表头部</p><blockquote><p>Input: 1-&gt;2-&gt;3</p><p>Output: 3-&gt;2-&gt;1</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)<span class="comment">//如果没有节点或者只有一个节点直接返回</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node cur = head.next;<span class="comment">//保存当前节点的下一个节点</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;<span class="comment">//打断当前节点的指针域，使之能够成为末尾节点</span></span><br><span class="line">    Node newHead = reverseList(cur); <span class="comment">//返回以pNext为头的反转链表，</span></span><br><span class="line">    <span class="comment">//返回之后newHead为新头，pNext为末节点</span></span><br><span class="line">    cur.next = head;<span class="comment">//在以newHead为头、以pNext为末的新链表中接上应该为末节点的head</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node newHead = <span class="keyword">null</span>;<span class="comment">//记录最后一个指针,即反转后头节点</span></span><br><span class="line">    <span class="keyword">while</span>(head.next!=<span class="keyword">null</span>)&#123;<span class="comment">//最后一个指针不入栈，方便出栈容易实现</span></span><br><span class="line">        s.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    newHead = head;</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">        head.next = s.pop();</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node newHead = <span class="keyword">null</span>;<span class="comment">//反转后的新头节点</span></span><br><span class="line">    Node cur = head; <span class="comment">//当前节点</span></span><br><span class="line">    Node pre = <span class="keyword">null</span>; <span class="comment">//当前节点前一节点</span></span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node next = cur.next; <span class="comment">//当前节点后一节点</span></span><br><span class="line">        <span class="keyword">if</span>(next==<span class="keyword">null</span>)</span><br><span class="line">            newHead = cur;</span><br><span class="line">        cur.next = pre;<span class="comment">//当前节点下一节点指向前节点，起到反转作用</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;<span class="comment">//三个指针整体向后移动，起到遍历效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>反转部分链表，反转[m,n]之间的链表</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6    [2,5]</p><p>Output: 1-&gt;5-&gt;4-&gt;3-&gt;2-&gt;6</p></blockquote><p>个人感觉递归实现困难，采用栈和遍历的方式应该简单（只要记录以下入栈节点个数或者遍历个数即可）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;反转链表，返回反转后链表头部&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://enpong.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="反转" scheme="https://enpong.github.io/tags/%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="递归" scheme="https://enpong.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="遍历" scheme="https://enpong.github.io/tags/%E9%81%8D%E5%8E%86/"/>
    
      <category term="栈" scheme="https://enpong.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://enpong.github.io/2019/04/18/替换空格/</id>
    <published>2019-04-17T17:00:45.000Z</published>
    <updated>2019-04-17T17:11:36.244Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个字符串中的空格替换成 “%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。</p><p>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</p><p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p><div align="center"><img src="//enpong.github.io/2019/04/18/替换空格/5.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> P1 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= P1; i++)</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">            str.append(<span class="string">"  "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> P2 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (P1 &gt;= <span class="number">0</span> &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(P1--);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'%'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;将一个字符串中的空格替换成 “%20”。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="字符串" scheme="https://enpong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="替换" scheme="https://enpong.github.io/tags/%E6%9B%BF%E6%8D%A2/"/>
    
      <category term="双指针" scheme="https://enpong.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://enpong.github.io/2019/04/18/二维数组中的查找/</id>
    <published>2019-04-17T16:36:41.000Z</published>
    <updated>2019-04-18T04:43:45.768Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。</p><p>该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><div align="center"> <img src="//enpong.github.io/2019/04/18/二维数组中的查找/4.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = col-<span class="number">1</span>;<span class="comment">//从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span>(r&lt;=row-<span class="number">1</span> &amp;&amp; c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == matrix[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="查找" scheme="https://enpong.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://enpong.github.io/2019/04/18/数组中重复的数字/</id>
    <published>2019-04-17T16:10:37.000Z</published>
    <updated>2019-04-17T16:30:22.058Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 </p><blockquote><p>Input:{2, 3, 1, 0, 2, 5}</p><p>Output:2</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。</p><p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><div align="center"> <img src="//enpong.github.io/2019/04/18/数组中重复的数字/3.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplicatin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[j] = nums[i];</span><br><span class="line">    nums[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="重复" scheme="https://enpong.github.io/tags/%E9%87%8D%E5%A4%8D/"/>
    
  </entry>
  
</feed>
