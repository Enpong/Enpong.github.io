<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enpong</title>
  
  <subtitle>成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://enpong.github.io/"/>
  <updated>2019-04-17T19:50:42.122Z</updated>
  <id>https://enpong.github.io/</id>
  
  <author>
    <name>Enpong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://enpong.github.io/2019/04/18/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://enpong.github.io/2019/04/18/用两个栈实现队列/</id>
    <published>2019-04-17T19:42:52.000Z</published>
    <updated>2019-04-17T19:50:42.122Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。 </p><div align="center"><img src="//enpong.github.io/2019/04/18/用两个栈实现队列/9_1.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">            out.push(in.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span>(out.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty!"</span>);</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 &lt;/p&gt;
&lt;h4 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://enpong.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://enpong.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的下一个结点</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://enpong.github.io/2019/04/18/二叉树的下一个结点/</id>
    <published>2019-04-17T19:10:37.000Z</published>
    <updated>2019-04-17T19:42:10.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>该节点的右子树不为空，则下一节点是该节点右子树中最左节点；</p><div align="center"><img src="//enpong.github.io/2019/04/18/二叉树的下一个结点/8_1.gif"></div></li></ol><ol start="2"><li><p>该节点的右子树为空，则下一节点是包含该节点的最小左子树的子树根节点。</p><div align="center"><img src="//enpong.github.io/2019/04/18/二叉树的下一个结点/8_2.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getNext</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode temp = node.right;</span><br><span class="line">        <span class="keyword">while</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode parent = node.parent;</span><br><span class="line">            <span class="keyword">if</span>(parent.left==node)</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="中序" scheme="https://enpong.github.io/tags/%E4%B8%AD%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://enpong.github.io/2019/04/18/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://enpong.github.io/2019/04/18/重建二叉树/</id>
    <published>2019-04-17T18:07:54.000Z</published>
    <updated>2019-04-17T19:10:01.869Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder =  [9,3,15,20,7]</span><br></pre></td></tr></table></figure><div align="center"><img src="//enpong.github.io/2019/04/18/重建二叉树/7_1.gif"></div><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。 </p><div align="center"><img src="//enpong.github.io/2019/04/18/重建二叉树/7_2.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;<span class="keyword">this</span>.val = val; left = <span class="keyword">null</span>; right = <span class="keyword">null</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存中序遍历数组每个值对应的索引</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; indexForInOrder = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">        indexForInOrder.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBianryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：前序遍历数组、前序部分数组左边界，前序部分数组右边界、中序部分数组左边界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> leftTreeSize = indexForInOrder(root.val) - inL;</span><br><span class="line">    <span class="comment">//对于preL和preR的计算：DLR</span></span><br><span class="line">    <span class="comment">//对于inL的计算：LDR</span></span><br><span class="line">    root.left = reConstructBinaryTree(pre, preL+<span class="number">1</span>, preL+leftTreeSize, inL);<span class="comment">//D(L)R</span></span><br><span class="line">    root.right = reConstructBinaryTree(pre, preL+leftSize+<span class="number">1</span>, preR, inL+leftTreeSize+<span class="number">1</span>);<span class="comment">//DL(R)</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>重建一棵二叉树：</p><ol><li><p>前序+中序</p></li><li><p>后序+中序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;<span class="keyword">this</span>.val = val; left = <span class="keyword">null</span>; right = <span class="keyword">null</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存中序遍历数组每个值对应的索引</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; indexForInOrder = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] next, <span class="keyword">int</span>[] in)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">        indexForInOrder.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBianryTree(next, next.length-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：后序遍历数组、后序部分数组右边界，后序部分数组左边界、中序部分数组左边界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] next, <span class="keyword">int</span> nextR, <span class="keyword">int</span> nextL, <span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextL &gt; nextR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(next[nextR]);</span><br><span class="line">    <span class="keyword">int</span> rightTreeSize = indexForInOrder(root.val) - inL;</span><br><span class="line">    <span class="comment">//对于nextR和nextL的计算：LRD</span></span><br><span class="line">    <span class="comment">//对于inL的计算：LDR</span></span><br><span class="line">    root.right = reConstructBinaryTree(next, nextR-<span class="number">1</span>, nextR-rightTreeSize, inL);<span class="comment">//L(R)D</span></span><br><span class="line">    root.left = reConstructBinaryTree(pre, nextR-rightTreeSize-<span class="number">1</span>, nextL, inL+leftTreeSize+<span class="number">1</span>);<span class="comment">//(L)RD</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="前序" scheme="https://enpong.github.io/tags/%E5%89%8D%E5%BA%8F/"/>
    
      <category term="后序" scheme="https://enpong.github.io/tags/%E5%90%8E%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://enpong.github.io/2019/04/18/从尾到头打印链表/</id>
    <published>2019-04-17T17:12:02.000Z</published>
    <updated>2019-04-17T18:06:49.180Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>反转链表，返回反转后链表头部</p><blockquote><p>Input: 1-&gt;2-&gt;3</p><p>Output: 3-&gt;2-&gt;1</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)<span class="comment">//如果没有节点或者只有一个节点直接返回</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node cur = head.next;<span class="comment">//保存当前节点的下一个节点</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;<span class="comment">//打断当前节点的指针域，使之能够成为末尾节点</span></span><br><span class="line">    Node newHead = reverseList(cur); <span class="comment">//返回以pNext为头的反转链表，</span></span><br><span class="line">    <span class="comment">//返回之后newHead为新头，pNext为末节点</span></span><br><span class="line">    cur.next = head;<span class="comment">//在以newHead为头、以pNext为末的新链表中接上应该为末节点的head</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node newHead = <span class="keyword">null</span>;<span class="comment">//记录最后一个指针,即反转后头节点</span></span><br><span class="line">    <span class="keyword">while</span>(head.next!=<span class="keyword">null</span>)&#123;<span class="comment">//最后一个指针不入栈，方便出栈容易实现</span></span><br><span class="line">        s.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    newHead = head;</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">        head.next = s.pop();</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node newHead = <span class="keyword">null</span>;<span class="comment">//反转后的新头节点</span></span><br><span class="line">    Node cur = head; <span class="comment">//当前节点</span></span><br><span class="line">    Node pre = <span class="keyword">null</span>; <span class="comment">//当前节点前一节点</span></span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node next = cur.next; <span class="comment">//当前节点后一节点</span></span><br><span class="line">        <span class="keyword">if</span>(next==<span class="keyword">null</span>)</span><br><span class="line">            newHead = cur;</span><br><span class="line">        cur.next = pre;<span class="comment">//当前节点下一节点指向前节点，起到反转作用</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;<span class="comment">//三个指针整体向后移动，起到遍历效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>反转部分链表，反转[m,n]之间的链表</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6    [2,5]</p><p>Output: 1-&gt;5-&gt;4-&gt;3-&gt;2-&gt;6</p></blockquote><p>个人感觉递归实现困难，采用栈和遍历的方式应该简单（只要记录以下入栈节点个数或者遍历个数即可）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;反转链表，返回反转后链表头部&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表，反转，递归，遍历，栈" scheme="https://enpong.github.io/tags/%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%8F%8D%E8%BD%AC%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E9%81%8D%E5%8E%86%EF%BC%8C%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://enpong.github.io/2019/04/18/替换空格/</id>
    <published>2019-04-17T17:00:45.000Z</published>
    <updated>2019-04-17T17:11:36.244Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个字符串中的空格替换成 “%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。</p><p>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</p><p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p><div align="center"><img src="//enpong.github.io/2019/04/18/替换空格/5.gif"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> P1 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= P1; i++)</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">            str.append(<span class="string">"  "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> P2 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (P1 &gt;= <span class="number">0</span> &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(P1--);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'%'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;将一个字符串中的空格替换成 “%20”。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="字符串" scheme="https://enpong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="替换" scheme="https://enpong.github.io/tags/%E6%9B%BF%E6%8D%A2/"/>
    
      <category term="双指针" scheme="https://enpong.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://enpong.github.io/2019/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://enpong.github.io/2019/04/18/二维数组中的查找/</id>
    <published>2019-04-17T16:36:41.000Z</published>
    <updated>2019-04-17T16:55:53.059Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。</p><p>该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><div align="center"> <img src="//enpong.github.io/2019/04/18/二维数组中的查找/4.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = col-<span class="number">1</span>;<span class="comment">//从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span>(r&lt;=row-<span class="number">1</span> &amp;&amp; c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == matrix[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组，查找" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84%EF%BC%8C%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="https://enpong.github.io/2019/04/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://enpong.github.io/2019/04/18/数组中重复的数字/</id>
    <published>2019-04-17T16:10:37.000Z</published>
    <updated>2019-04-17T16:30:22.058Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 </p><blockquote><p>Input:{2, 3, 1, 0, 2, 5}</p><p>Output:2</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。</p><p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><div align="center"> <img src="//enpong.github.io/2019/04/18/数组中重复的数字/3.gif"> </div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplicatin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[j] = nums[i];</span><br><span class="line">    nums[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://enpong.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://enpong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="重复" scheme="https://enpong.github.io/tags/%E9%87%8D%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>为运算表达式设计优先级</title>
    <link href="https://enpong.github.io/2019/03/22/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://enpong.github.io/2019/03/22/为运算表达式设计优先级/</id>
    <published>2019-03-22T07:39:51.000Z</published>
    <updated>2019-04-17T19:56:50.081Z</updated>
    
    <content type="html"><![CDATA[<p>回溯搜索。该问题牵涉到括号的组合问题，一般使用递归+回溯的思想。主要想法：</p><ul><li>递归回溯。可以产生所有的组合方式。 </li><li>每个小组合方式相当于一个子集，不断的将计算结果返回给上一层。 </li></ul><p>举例：a + (b - (c <em> d))会不断的变成a + (b - (res1 </em> res2))-&gt; a + (res1 - res2) -&gt; res1</p><ul><li>res2</li></ul><p>计算结果需要for循环！！！其实有这种情况，a + (b - (c <em> d))和a + (b - c) </em> d))，这里 a +<br>res2，res2就可能有多种情况。</p><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ways = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'+'</span> || c==<span class="string">'-'</span> || c==<span class="string">'*'</span>)&#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(Integer l : left)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Integer r : right)&#123;</span><br><span class="line">                        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                                ways.add(l+r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                                ways.add(l-r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                                ways.add(l*r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ways.size()==<span class="number">0</span>)</span><br><span class="line">            ways.add(Integer.valueOf(input));</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回溯搜索。该问题牵涉到括号的组合问题，一般使用递归+回溯的思想。主要想法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归回溯。可以产生所有的组合方式。 &lt;/li&gt;
&lt;li&gt;每个小组合方式相当于一个子集，不断的将计算结果返回给上一层。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：a + (b - 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
    
      <category term="括号" scheme="https://enpong.github.io/tags/%E6%8B%AC%E5%8F%B7/"/>
    
      <category term="组合" scheme="https://enpong.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
      <category term="回溯" scheme="https://enpong.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode---二分查找</title>
    <link href="https://enpong.github.io/2019/03/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://enpong.github.io/2019/03/22/二分查找/</id>
    <published>2019-03-22T07:10:34.000Z</published>
    <updated>2019-04-17T21:38:30.425Z</updated>
    
    <content type="html"><![CDATA[<h5 id="二分查找基本实现"><a href="#二分查找基本实现" class="headerlink" title="二分查找基本实现"></a>二分查找基本实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;  <span class="comment">//防止(h+l)/2加法溢出</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]==key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;key)</span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变种二分查找，找出数组中key重复元素最左位置-注意边界"><a href="#变种二分查找，找出数组中key重复元素最左位置-注意边界" class="headerlink" title="变种二分查找，找出数组中key重复元素最左位置(注意边界)"></a>变种二分查找，找出数组中key重复元素最左位置(注意边界)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&gt;=key)</span><br><span class="line">h = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[l]==key)</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="leetcode上二分查找题"><a href="#leetcode上二分查找题" class="headerlink" title="leetcode上二分查找题"></a>leetcode上二分查找题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求开方   69. Sqrt(x) (Easy)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,h=x;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sqrt = x/mid;</span><br><span class="line"><span class="keyword">if</span>(sqrt==mid)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mid&gt;sqrt)</span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符</span></span><br><span class="line"><span class="comment">//744. Find Smallest Letter Greater Than Target (Easy)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=letters.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(letters[mid]&lt;=target)</span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l&lt;letters.length ? letters[l] : letters[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以O(logN)时间复杂度找出有序数组中唯一不出现2次的元素</span></span><br><span class="line"><span class="comment">//540. Single Element in a Sorted Array (Medium)</span></span><br><span class="line"><span class="comment">//假设index是该元素所在位置，mid是偶数，则当(mid+1&lt;index)时，nums[m]==nums[m+1];</span></span><br><span class="line"><span class="comment">//当(mid+1&gt;=index),nums[m]!=nums[m+1]</span></span><br><span class="line"><span class="comment">//因此，m为偶数的情况下，当nums[m]==nums[m+1],index所在区间应该为[m+2,h];否则，index在[l,m];</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(mid%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">mid--; <span class="comment">//保证mid是偶数</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>)</span><br><span class="line">l = m+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">h = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旋转数组中的最小数字 153. Find Minimum in Rotated Sorted Array (Medium)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;=nums[h])</span><br><span class="line">h = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找区间，找到最左位置，找到最右位置</span></span><br><span class="line"><span class="comment">//34. Search for a Range (Medium)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> first=<span class="number">0</span>, last=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//找最左位置</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">h = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[l]!=target)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">first = l;</span><br><span class="line"><span class="comment">//找最右位置</span></span><br><span class="line">l=<span class="number">0</span>, h=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(h-l+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//这里mid选择向上取整，否则会死循环</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">l = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">h = mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = h;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>&#123;first, last&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;二分查找基本实现&quot;&gt;&lt;a href=&quot;#二分查找基本实现&quot; class=&quot;headerlink&quot; title=&quot;二分查找基本实现&quot;&gt;&lt;/a&gt;二分查找基本实现&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
      <category term="查找" scheme="https://enpong.github.io/categories/leetcode/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="二分查找" scheme="https://enpong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---线程同步</title>
    <link href="https://enpong.github.io/2019/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://enpong.github.io/2019/03/21/操作系统---线程同步/</id>
    <published>2019-03-21T08:22:46.000Z</published>
    <updated>2019-04-09T07:59:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88718474" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88718474</a></p><h4 id="进程中线程同步的四种常用方式："><a href="#进程中线程同步的四种常用方式：" class="headerlink" title="进程中线程同步的四种常用方式："></a>进程中线程同步的四种常用方式：</h4><h6 id="临界区（CCriticalSection"><a href="#临界区（CCriticalSection" class="headerlink" title="临界区（CCriticalSection)"></a>临界区（CCriticalSection)</h6><p>当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区对象的线程可以访问被保护的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程释<br>放临界区为止。</p><ol><li>定义临界区对象CCriticalSection g_CriticalSection； </li><li>在访问共享资源之前，先获取临界区对象，g_CriticalSection； </li><li>访问资源结束后，释放临界区对象，g_CriticalSection.unLock(); </li></ol><h6 id="事件（CEvent）"><a href="#事件（CEvent）" class="headerlink" title="事件（CEvent）"></a>事件（CEvent）</h6><p>事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程A负责侦听通信端口，另外一个线程B负责更新用户数<br>据，利用事件机制，则线程A可以通知线程B何时更新用户数据。<br>每个Cevent对象可以有两种状态：<br>有信号状态和无信号状态。<br>Cevent类对象有两种类型：人工事件和自动事件。<br>自动事件对象，在被至少一个线程释放后自动返回到无信号状态；<br>人工事件对象，获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。在创建Cevent对象时，默认创建的是自动事件。</p><h6 id="互斥量（CMutex）"><a href="#互斥量（CMutex）" class="headerlink" title="互斥量（CMutex）"></a>互斥量（CMutex）</h6><p>互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。<br>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带<br>来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</p><h6 id="信号量（CSemphore）"><a href="#信号量（CSemphore）" class="headerlink" title="信号量（CSemphore）"></a>信号量（CSemphore）</h6><p>当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数<br>值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计<br>数值不为零为止。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88718474&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="线程同步" scheme="https://enpong.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java实现LRU策略缓冲</title>
    <link href="https://enpong.github.io/2019/03/08/Java%E5%AE%9E%E7%8E%B0LRU%E7%AD%96%E7%95%A5%E7%BC%93%E5%86%B2/"/>
    <id>https://enpong.github.io/2019/03/08/Java实现LRU策略缓冲/</id>
    <published>2019-03-08T13:05:21.000Z</published>
    <updated>2019-04-17T21:32:46.494Z</updated>
    
    <content type="html"><![CDATA[<p>1.基于<code>双向链表+HashMap</code>实现：</p><ul><li><p>访问某个节点时，将该节点从双向链表中原位置删除，并重新插入链表头。这样可以保证链表尾部节点就是最近最久未被使用的，当节点数量大于缓存空间就淘汰链表尾部节点； </p></li><li><p>为了能在<code>O(1)</code>时间内从链表删除某个节点，不能通过遍历链表查找该节点。需要借助<code>HashMap</code>存储key与节点的映射，通过key在<code>O(1)</code>时间内找到节点，并在<code>O(1)</code>时间内删除该节点。 </p></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;(maxSize * <span class="number">4</span> / <span class="number">3</span>);</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        unlink(node);</span><br><span class="line">        appendHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            unlink(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        map.put(key, node);</span><br><span class="line">        appendHead(node);</span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt; maxSize) &#123;</span><br><span class="line">            Node toRemove = removeTail();</span><br><span class="line">            map.remove(toRemove.k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node next = head.next;</span><br><span class="line">        node.next = next;</span><br><span class="line">        next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = tail.pre;</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        tail.pre = pre;</span><br><span class="line">        pre.next = tail;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Node cur = head.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != tail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Node node = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> node.k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>2.使用Java容器中的<code>LinkedHashMap</code></p><ul><li><code>LinkedHashMap</code>继承自<code>HashMap</code>，因此具有和<code>HashMap</code>一样的快速查找特性； </li><li>内部维护了一个<code>双向链表</code>，用来维护插入顺序或者LRU顺序；<code>accessOrder</code>字段决定了顺序，默认为<code>false</code>（插入顺序）； </li><li>因此，<code>LinkedHashMap = 双向链表+HashMap</code>. </li><li>但是<code>LinkedHashMap</code>实现的LRU缓存与第1个实现方式有一点  区别，即<code>LinkedHashMap</code>的链表首部才是最近最久未使用节点  ；当然，这个区别对于双向链表来说不是事儿，只是寓意上的区别而已（在我看来）。 </li></ul><blockquote><p>访问一个节点时，调用<code>get()</code>方法，<code>get()</code>中有一个函数<code>afterNodeAccess()</code>；该方法用于将该节点移到链表尾部（最近访问节点）</p></blockquote><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在<code>put</code>等操作之后执行<code>afterNodeInsertion()</code>，当<code>removeEldestEntry()</code>方法返回true时会移除最晚的节点，也就是链表首<br>部节点；<code>evict</code>只有在构建Map时才为<code>false</code>，在这里为<code>true</code>.</p></blockquote><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>removeEldestEntry()</code>默认为false，也就是说put操作后执行的<code>afterNodeInsertion()</code>并没有移除首部节点，也就没有L<br>RU缓存淘汰的说法了；如果需要让它为true，需要继承<code>LinkedHashMap</code>并且覆盖该方法；</p></blockquote><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>因此，要用<code>LinkedHashMap</code>来实现一个LRU缓存，需要：<br>1.设定最大缓存空间<code>MAX_ENTRIES</code><br>2.使用<code>LinkedHashMap</code>的构造方法将<code>accessOrder</code>设置为true，开启LRU顺序；<br>3.覆盖<code>removeEldestEntry（）</code>方法实现，在节点多于<code>MAX_ENTRIES</code>就会将最近最久未使用的节点删除。</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUTest</span></span>&#123;</span><br><span class="line">    - <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">        cache.get(<span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(cache.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.基于&lt;code&gt;双向链表+HashMap&lt;/code&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;访问某个节点时，将该节点从双向链表中原位置删除，并重新插入链表头。这样可以保证链表尾部节点就是最近最久未被使用的，当节点数量大于缓存空间就淘汰链表尾部节点； &lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
    
      <category term="java容器" scheme="https://enpong.github.io/tags/java%E5%AE%B9%E5%99%A8/"/>
    
      <category term="LRU" scheme="https://enpong.github.io/tags/LRU/"/>
    
      <category term="缓存" scheme="https://enpong.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程的中断操作</title>
    <link href="https://enpong.github.io/2019/03/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C/"/>
    <id>https://enpong.github.io/2019/03/06/Java多线程的中断操作/</id>
    <published>2019-03-06T07:33:09.000Z</published>
    <updated>2019-04-09T07:59:24.724Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88238190" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88238190</a></p><h5 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h5><p>如果一个线程处于阻塞、限期等待或无限期等待状态时，调用该线程的interrupt()方法中断线程，就会抛出InterruptedException，从而提前<br>结束该线程；（注意：不能中断IO阻塞和Synchronized锁阻塞）</p><h5 id="Interupted"><a href="#Interupted" class="headerlink" title="Interupted"></a>Interupted</h5><ul><li>如果一个线程的run()方法执行一个循环体，并且循环体中没有会抛出InterruptedException的操作（如sleep())，那么该线程调用interrupted()就无法中断线程； </li><li>由于一个线程调用interrupt()会设置线程中断标志，该标志可以通过interrupted()来获取；因此可以在run()方法的循环体中以该标志来判断线程是否处于中断状态，以结束线程。 </li></ul><h5 id="Executor中断操作"><a href="#Executor中断操作" class="headerlink" title="Executor中断操作"></a>Executor中断操作</h5><ol><li>Executor的shutDown()会等待所有线程执行完毕之后再关闭；而调用shutDownNow()，相当于调用每个线程的interrupt()方法，中断所有线程； </li><li>如果只想中断Executor中的一个线程，可以使用submit()提交一个线程，该方法返回一个Future&lt;?&gt;对象，通过调用该对象的cancel(true)方法中断线程。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88238190&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
    
      <category term="多线程" scheme="https://enpong.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="中断" scheme="https://enpong.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Web页面请求过程</title>
    <link href="https://enpong.github.io/2019/03/06/Web%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://enpong.github.io/2019/03/06/Web页面请求过程/</id>
    <published>2019-03-06T06:23:37.000Z</published>
    <updated>2019-04-09T07:59:24.218Z</updated>
    
    <content type="html"><![CDATA[<p>转自： <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener"> https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/计算机网络.md#web-<br>页面请求过程 </a></p><h5 id="DHCP配置主机信息"><a href="#DHCP配置主机信息" class="headerlink" title="DHCP配置主机信息"></a>DHCP配置主机信息</h5><ul><li>假设主机最开始没有IP地址以及其他信息，那么就需要先使用DHCP来获取； </li><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中； </li><li>该报文段则被放入在一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中； </li><li>该数据报则被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备； </li><li>连接在交换机的DHCP服务器收到广播帧之后，不断向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段又被放入IP数据报中，最后放入MAC帧中； </li><li>该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧； </li><li>主机收到该帧后，不断向上分解得到DHCP报文。之后就配置它的IP地址，子网掩码和DNS服务器IP地址，并在其IP转发表中安装默认网关． </li></ul><h5 id="ARP解析MAC地址"><a href="#ARP解析MAC地址" class="headerlink" title="ARP解析MAC地址"></a>ARP解析MAC地址</h5><ul><li>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成该套接字，主机需要知道网站的域名对应的IP地址。 </li><li>主机生成一个DNS查询报文，该报文具有53端口，因为DNS服务器的端口号时53； </li><li>该DNS查询报文被放入目的地址为DNS服务器的IP数据报中； </li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器； </li><li>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议； </li><li>主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将该ARP查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器； </li><li>网关路由器接收到该帧后，不断向上分解得到ARP报文，发现其中的IP地址与其接口的IP地址匹配，因此就发送ARP回答报文，包含了它的MAC地址，发回给主机。 </li></ul><h5 id="DNS解析域名"><a href="#DNS解析域名" class="headerlink" title="DNS解析域名"></a>DNS解析域名</h5><ul><li>知道了网关路由器的MAC地址之后，就可以继续DNS的解析过程了； </li><li>网关路由器接收到包含DNS查询报文的以太网帧后，抽取出IP数据报，并根据转发表决定该IP数据报应该转发的路由器； </li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达DNS服务器的路由表项； </li><li>到达DNS服务器后，DNS服务器抽取出DNS查询报文，并在DNS数据库中查找待解析的域名； </li><li>找到DNS记录之后，发送DNS回答报文，将该回答报文放入UDP报文段中，然后放入IP数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 </li></ul><h5 id="HTTP请求页面"><a href="#HTTP请求页面" class="headerlink" title="HTTP请求页面"></a>HTTP请求页面</h5><ul><li>有了HTTP服务器的IP地址，主机就能够生成TCP套接字，该套接字将用于向Web服务器发送HTTP GET报文； </li><li>在生成TCP套接字之前，必须先与HTTP服务器进行三次握手来建立连接。生成一个具有目的端口80的TCP SYN报文段，并向HTTP服务器发送该报文段； </li><li>HTTP服务器接到该报文段之后，生成TCP SYN ACK报文段，发回给主机； </li><li>连接建立之后，浏览器生成HTTP GET报文，并交付给HTTP服务器； </li><li>HTTP服务器从TCP套接字中读取HTTP GET报文，生成一个HTTP响应报文，将Web页面内容放入报文体中，发回给主机； </li><li>浏览器收到HTTP响应报文后，抽取出Web页面内容，之后进行渲染，显示Web页面。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自： &lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%
E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#web-%E9%A1%B5%E
      
    
    </summary>
    
      <category term="网络" scheme="https://enpong.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="undefined" scheme="https://enpong.github.io/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="https://enpong.github.io/2019/03/05/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://enpong.github.io/2019/03/05/五种IO模型/</id>
    <published>2019-03-05T04:55:40.000Z</published>
    <updated>2019-04-09T07:59:23.537Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88177447" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88177447</a></p><p>一个输入操作通常有两个阶段：</p><ul><li>等待数据准备，即从存储介质（磁盘，网络等）拷贝到内核； </li><li>从内核向进程复制数据 </li></ul><h5 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124039713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回 </li></ul><h5 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124240779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。 </li></ul><h5 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h5><p><img src="https://img-blog.csdnimg.cn/20190305124437547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中； </li><li>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。 </li></ul><h5 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305124709590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的； </li><li>当数据报准备好被读时，就为该进程生成一个SIGIO信号； </li><li>应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。 </li></ul><h5 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h5><p><img src="https://img-blog.csdnimg.cn/20190305125019326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号； </li><li>调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。 </li></ul><h5 id="对比五种I-O模型"><a href="#对比五种I-O模型" class="headerlink" title="对比五种I/O模型"></a>对比五种I/O模型</h5><p><img src="https://img-blog.csdnimg.cn/20190305125145450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞； </li><li>异步I/O：在I/O操作未完成前，请求进程未被阻塞。 </li><li>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88177447&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I" scheme="https://enpong.github.io/tags/I/"/>
    
      <category term="O" scheme="https://enpong.github.io/tags/O/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中BitSet</title>
    <link href="https://enpong.github.io/2019/03/02/JAVA%E4%B8%ADBitSet/"/>
    <id>https://enpong.github.io/2019/03/02/JAVA中BitSet/</id>
    <published>2019-03-02T11:10:27.000Z</published>
    <updated>2019-04-09T07:59:22.639Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA中BitSet就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示<br>false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个数据结构KEY和Value的保存需要消耗较多的<br>内存，不适合保存较多的数据，即大数据场景；比如在有10亿条URL中判定一个（ <a href="http://www.baidu.com" target="_blank" rel="noopener"> www.baidu.com </a><br>）是否存在，如果我们使用常规的hashmap来保存将是不现实的，因为URL本身需要占据较多的内存而无法直接操作。如果我们使用bitset来保存，那么可以对一<br>条URL求hashcode，并将数字映射在bitset上，那么事实上它只需要bitset上的一个bit位即可，即我们1位空间即可表达一个URL字符串的存在性<br>。</p><blockquote><p>所谓“存在性”，就是通过BitSet来检测一个数字是否存在。</p></blockquote><h4 id="BitSet原理"><a href="#BitSet原理" class="headerlink" title="BitSet原理"></a>BitSet原理</h4><p>JAVA中，一个long型数字占用64位空间，根据上述“位图”的概念，那么一个long型数字（4个字节）就可以保存64个数字的“存在性”状态(无碰撞冲突时，<br>即true、false状态)。比如50个数字{0,1,10,…63}，判定“15”是否存在，那么我们通常会首先将这些数字使用数组或者hashmap保存，然后<br>再去判定，那么保存这些这些数据需要占用64 * 64位；如果使用位图，那么一个long型数字即可。（如果换成50个字符串，那么其节约的空间可能更大）。</p><ol><li>BitSet只面向数字比较，比如set(int a,boolean value)方法，将数字a在bitSet中设定为true或者false；此后可以通过get(int a)方法检测结果。对于string类型的数据，如果像使用BitSet，那么可以将其hashcode值映射在bitset中。 </li><li>首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 首先我们需要知道：1，1&lt;&lt;64，1&lt;&lt;128，1&lt;&lt;192…等，这些数字的计算结果是相等的（位运算）；这也是一个long数字，只能表达连续的(或者无冲突的)64个数字的状态，即如果把数字1在long中用位表示，那么数字64将无法通过同一个long数字中位表示–冲突；BitSet内部，是一个long[]数组，数组的大小由bitSet接收的最大数字决定，这个数组将数字分段表示[0,63],[64,127],[128,191]…。即long[0]用来存储[0,63]这个范围的数字的“存在性”，long[1]用来存储[64,127]，依次轮推，这样就避免了位运算导致的冲突。 </li></ol><p>数字范围  [0,63]  [64,127]  [128,191]  …</p><p>long数组索引</p><p>0</p><p>1</p><p>2</p><p>…</p><ol start="3"><li><p>bitSet内部的long[]数组是基于向量的，即随着set的最大数字而动态扩展。数组的最大长度计算： </p><p>   (maxValue - 1) &gt;&gt; 6  + 1  </p></li></ol><ol start="4"><li><p>BitSet中set方法伪代码： </p><p>   public void set(int number) {<br>   int index = number &gt;&gt; 6;//找到number需要映射的数组的index。<br>   if(index + 1 &gt; length) {  </p><pre><code>ensureCapacity(index + 1);//重新扩展long[]数组  </code></pre><p>   }<br>   long[index] |= (1L &lt;&lt; number);//冲突解决<br>}  </p></li></ol><h4 id="使用BitSet"><a href="#使用BitSet" class="headerlink" title="使用BitSet"></a>使用BitSet</h4><p>本例中使用bitSet做String字符串的存在性校验。</p><pre><code>BitSet bitSet = new BitSet(Integer.MAX_VALUE);//hashcode的值域  //0x7FFFFFFF  String url = &quot;http://baidu.com/a&quot;;  int hashcode = url.hashCode() &amp; 0x7FFFFFFF;  bitSet.set(hashcode);  System.out.println(bitSet.cardinality());//着色位的个数  System.out.println(bitSet.get(hashcode));//检测存在性  bitSet.clear(hashcode);//清除位数据  </code></pre><h4 id="BitSet与Hashcode冲突"><a href="#BitSet与Hashcode冲突" class="headerlink" title="BitSet与Hashcode冲突"></a>BitSet与Hashcode冲突</h4><p>因为BitSet API只能接收int型的数字，即只能判定int数字是否在bitSet中存在。所以，对于String类型，我们通常使用它的hashcode，<br>但这有一种隐患，java中hashcode存在冲突问题，即不同的String可能得到的hashcode是一样的（即使不重写hashcode方法），如果我们不<br>能很好的解决这个问题，那么就会出现“数据抖动”—不同的hashcode算法、运行环境、bitSet容量，会导致判断的结果有所不同。比如A、B连个字符串，它们<br>的hashcode一样，如果A在BitSet中“着色”(值为true)，那么检测B是否在BitSet存在时，也会得到true。</p><p>这个问题该如何解决或者缓解呢？</p><ol><li><p>调整hashcode生成算法：我们可以对一个String使用多个hashcode算法，生成多个hashcode，然后在同一个BitSet进行多次“着色”，在判断存在性时，只有所有的着色位为true时，才判定成功 </p><p>   String url = “<a href="http://baidu.com/a&quot;" target="_blank" rel="noopener">http://baidu.com/a&quot;</a>;<br>int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF;<br>bitSet.set(hashcode1);  </p><p>int hashcode2 = (url + “-seed-“).hashCode() &amp; 0x7FFFFFFF;<br>bitSet.set(hashcode2);<br>System.out.println(bitSet.get(hashcode1) &amp;&amp; bitSet.get(hashcode2));<br>//也可以在两个不同的bitSet上进行2次“着色”，这样冲突性更小。但会消耗双倍的内存  </p></li></ol><p>其实我们能够看出，这种方式降低了误判的概率。但是如果BitSet中存储了较多的数字，那么互相覆盖着色，最终数据冲突的可能性会逐渐增加，最终仍然有一定概率的判<br>断失误。所以在hashcode算法的个数与实际String的个数之间有一个权衡，我们建议: “hashcode算法个数 <em> String字符串的个数” &lt;<br>Integer.MAX_VALUE </em> 0.8</p><ol start="2"><li>多个BitSet并行保存：<br>改良1)中的实现方式，我们仍然使用多个hashcode生成算法，但是每个算法生成的值在不同的BitSet中着色，这样可以保持每个BitSet的稀疏度(降低冲<br>突的几率)。在实际结果上，比1)的误判率更低，但是它需要额外的占用更多的内存，毕竟每个BitSet都需要占用内存。这种方式，通常是缩小hashcode的值域<br>，避免内存过度消耗。</li></ol><pre><code>    BitSet bitSet1 = new BitSet(Integer.MAX_VALUE);//127M  BitSet bitSet2 = new BitSet(Integer.MAX_VALUE);  String url = &quot;http://baidu.com/a&quot;;  int hashcode1 = url.hashCode() &amp; 0x7FFFFFFF;  bitSet1.set(hashcode1);  int hashcode2 = (url + &quot;-seed-&quot;).hashCode() &amp; 0x7FFFFFFF;  bitSet2.set(hashcode2);  System.out.println(bitSet1.get(hashcode1) &amp;&amp; bitSet2.get(hashcode2));  </code></pre><ol start="3"><li>是否有必要完全避免误判？<br>如果做到100%的正确判断率，在原理上说BitSet是无法做的，BitSet能够保证“如果判定结果为false，那么数据一定是不存在；但是如果结果为true<br>，可能数据存在，也可能不存在(冲突覆盖)”,即“false == YES，true ==<br>Maybe”。有人提出将冲突的数据保存在类似于BTree的额外数据结构中，事实上这种方式增加了设计的复杂度，而且最终仍然没有良好的解决内存占用较大的问题。</li></ol><h4 id="BloomFilter-布隆姆过滤器"><a href="#BloomFilter-布隆姆过滤器" class="headerlink" title="BloomFilter(布隆姆过滤器)"></a>BloomFilter(布隆姆过滤器)</h4><p>BloomFilter 的设计思想和BitSet有较大的相似性，目的也一致，它的核心思想也是使用多个Hash算法在一个“位图”结构上着色，最终提高“存在性”<br>判断的效率。请参见Guava BloomFilter。如下为代码样例：</p><pre><code>Charset charset = Charset.forName(&quot;utf-8&quot;);  BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(charset),2&lt;&lt;21);//指定bloomFilter的容量  String url = &quot;www.baidu.com/a&quot;;  bloomFilter.put(url);  System.out.println(bloomFilter.mightContain(url));  </code></pre><h4 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h4><p>据上所述，BitSet可以有效的降低内存的使用量，但是它的内存使用量是有内部long数组的大小决定，所以在创建BitSet时指定的值域非常重要，过大的值域将<br>会导致OOM（比如指定Long.MAX_VALUE）,在一个BitMap上存储Integer.MAX_VALUE个“着色”（注意，BitSet只能对正数操作<br>），大概消耗128M内存。</p><hr><p>转自： <a href="https://shift-alt-ctrl.iteye.com/blog/2194519" target="_blank" rel="noopener"> https://shift-alt-ctrl.iteye.com/blog/2194519 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JAVA中BitSet就是“位图”数据结构，根据“位图”的语义，数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示&lt;br&gt;false和true。对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个
      
    
    </summary>
    
      <category term="java" scheme="https://enpong.github.io/categories/java/"/>
    
      <category term="大数据量" scheme="https://enpong.github.io/categories/java/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/"/>
    
    
      <category term="BitSet" scheme="https://enpong.github.io/tags/BitSet/"/>
    
  </entry>
  
  <entry>
    <title>实现Trie前缀树</title>
    <link href="https://enpong.github.io/2019/03/02/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <id>https://enpong.github.io/2019/03/02/实现Trie前缀树/</id>
    <published>2019-03-02T09:59:11.000Z</published>
    <updated>2019-04-17T21:39:41.490Z</updated>
    
    <content type="html"><![CDATA[<p>Java非递归版</p><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isTrie;</span><br><span class="line">        Map&lt;Character, Node&gt; children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!node.children.containsKey(c))&#123;</span><br><span class="line">                node.children.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        node.isTrie = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            Node temp = node.children.get(c);</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node  = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isTrie;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            Node temp = node.children.get(c);</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node  = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    </p><h3 id="关于Trie"><a href="#关于Trie" class="headerlink" title="关于Trie"></a>关于Trie</h3><ul><li><p>核心思想：空间换取时间 </p></li><li><p>Trie 树又叫又叫字典树、前缀树、单词查找树，它是一颗多叉查找树。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。 </p></li><li><p>如果  海量数据  是字符串数据，那么就可以用很小的空间开销构建一颗 Trie 树，空间开销和树高有关。 </p></li></ul><p><code>{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”}</code><br><img src="https://img-blog.csdnimg.cn/20190302174704179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>基本性质： </p><ul><li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 </li><li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 </li><li>每个节点的所有子节点包含的字符互不相同。 </li></ul></li><li><p>优点 </p><ul><li>插入和查询效率很高，都是O(m)，m是待插入/查询字符串长度；（关于查询，会有人认为hash表时间复杂度O(1)不是更快？确实，但是哈希搜索的效率通常取决于hash函数的好坏，因为这决定着冲突的概率）。 </li><li>Trie树中不同关键字不会冲突； </li><li>可以对关键字按字典排序。 </li></ul></li><li><p>缺点 </p><ul><li>当hash函数很好时，Trie树的查找效率会低于哈希查找； </li><li>空间消耗比较大。 </li></ul></li><li>主要应用：字符串检索、词频统计、字符串排序、前缀匹配等 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java非递归版&lt;/p&gt;
&lt;p&gt;​&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
    
      <category term="前缀树" scheme="https://enpong.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>重新排序得到2的幂</title>
    <link href="https://enpong.github.io/2019/03/02/%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"/>
    <id>https://enpong.github.io/2019/03/02/重新排序得到2的幂/</id>
    <published>2019-03-02T04:54:18.000Z</published>
    <updated>2019-04-17T21:41:15.942Z</updated>
    
    <content type="html"><![CDATA[<h4 id="😍题目描述"><a href="#😍题目描述" class="headerlink" title="😍题目描述"></a>😍题目描述</h4><p>从正整数 N 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回<br>false。</p><h4 id="😘解题思路"><a href="#😘解题思路" class="headerlink" title="😘解题思路"></a>😘解题思路</h4><ul><li>先将数值N中的每个数字独立存储并排序为list，长度记作n；在2的幂中找出长度为n的所有数值，并同样对每个数字存储排序,得到list2，判断list与list2是否逐位相等 </li><li>对于2的幂的正整数，有个规律：位数每隔3都有对应的整数个数4、3、3， </li></ul><table><thead><tr><th>位数</th><th style="text-align:center">个数</th><th>整数</th><th style="text-align:right">幂指数</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">4</td><td>1，2，4，8</td><td style="text-align:right">0，1，2，3</td></tr><tr><td>2</td><td style="text-align:center">3</td><td>16，32，64</td><td style="text-align:right">4，5，6</td></tr><tr><td>3</td><td style="text-align:center">3</td><td>128，256，512</td><td style="text-align:right">7，8，9</td></tr><tr><td>4</td><td style="text-align:center">4</td><td>1024，2048，4096，8192</td><td style="text-align:right">10，11，12，13</td></tr><tr><td>5</td><td style="text-align:center">3</td><td>16384，32768，65536</td><td style="text-align:right">14，15，16</td></tr><tr><td>6</td><td style="text-align:center">3</td><td>….</td><td style="text-align:right">17，18，19</td></tr><tr><td>7</td><td style="text-align:center">4</td><td>…</td><td style="text-align:right">20，21，22，23</td></tr><tr><td>8</td><td style="text-align:center">3</td><td>…</td><td style="text-align:right">24，25，26</td></tr><tr><td>9</td><td style="text-align:center">3</td><td>…</td><td style="text-align:right">27，28，29</td></tr><tr><td>…</td><td style="text-align:center">…</td><td>…</td><td style="text-align:right">…</td></tr></tbody></table><h4 id="😱示例代码"><a href="#😱示例代码" class="headerlink" title="😱示例代码"></a>😱示例代码</h4><p>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        String num = N+<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = num.length();</span><br><span class="line">        <span class="keyword">int</span> n;<span class="comment">//位数为len的整数（2的幂)的个数</span></span><br><span class="line">        <span class="keyword">int</span> m;<span class="comment">//位数为len的整数的幂指数</span></span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            m = (len/<span class="number">3</span>)*<span class="number">10</span>-<span class="number">3</span>;</span><br><span class="line">            n = <span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            m = (len/<span class="number">3</span>)*<span class="number">10</span>;</span><br><span class="line">            n = <span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m = (len/<span class="number">3</span>)*<span class="number">10</span>+<span class="number">4</span>;</span><br><span class="line">            n = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] pows = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            pows[i] = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, m+i) + <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">char</span>[] powlist = pows[i].toCharArray();</span><br><span class="line">            Arrays.sort(powlist);</span><br><span class="line">            <span class="keyword">char</span>[] numlist = num.toCharArray();</span><br><span class="line">            Arrays.sort(numlist);</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(powlist, numlist))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;😍题目描述&quot;&gt;&lt;a href=&quot;#😍题目描述&quot; class=&quot;headerlink&quot; title=&quot;😍题目描述&quot;&gt;&lt;/a&gt;😍题目描述&lt;/h4&gt;&lt;p&gt;从正整数 N 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上
      
    
    </summary>
    
      <category term="leetcode" scheme="https://enpong.github.io/categories/leetcode/"/>
    
    
      <category term="找规律" scheme="https://enpong.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---进程通信</title>
    <link href="https://enpong.github.io/2019/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://enpong.github.io/2019/03/01/操作系统---进程通信/</id>
    <published>2019-03-01T15:54:07.000Z</published>
    <updated>2019-04-09T07:59:18.751Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88071041" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88071041</a></p><h3 id="对进程通信的理解"><a href="#对进程通信的理解" class="headerlink" title="对进程通信的理解"></a>对进程通信的理解</h3><p>进程是资源分配的基本单位，所以说某块资源分配给一个进程后，该资源只能是该进程独占，所以进程之间的通信就会比较麻烦，因为需要让不同的进程间能够看到一份公共的资<br>源。所以交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信<br>。</p><h3 id="实现进程通信的方式"><a href="#实现进程通信的方式" class="headerlink" title="实现进程通信的方式"></a>实现进程通信的方式</h3><h5 id="匿名管道（pipe）"><a href="#匿名管道（pipe）" class="headerlink" title="匿名管道（pipe）"></a>匿名管道（pipe）</h5><ul><li>管道是通过调用 pipe 函数创建的，是在内核中开辟出的一块缓冲区，fd[0] 用于读，fd[1] 用于写。 </li><li>只支持半双工通信（单向交替传输）； </li><li>只能在父子进程中使用。 </li><li>父进程关闭读端（fd[0]）,子进程关闭写端(fd[1])，则此时父进程可以往管道中进行写操作，子进程可以从管道中读，从而实现了通过管道的进程间通信<br><img src="https://img-blog.csdnimg.cn/20190301210844562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code>#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;int main(){    int fd[2];    int ret = pipe(fd);        //开启匿名管道    if(ret&lt;0)         perror(&quot;pipe\n&quot;);    //开启失败    pid_t id = fork();        //创建子进程    if(id&lt;0)         perror(&quot;fork\n&quot;);    //创建失败    else if(id==0){        //子进程        close(fd[0]);        //子进程关闭读端        int i=0;        char *mesg = NULL;        while(i&lt;100){            mesg = &quot;child&quot;;            write(fd[1], mesg, strlen(mesg)+1);        //向管道另一端写数据            sleep(1);            i++;        }    }    else{        //父进程        close(fd[1]);        //父进程关闭写端        int i=0;        char mesg[100];        while(i&lt;100){            memset(mesg, &apos;\0&apos;, sizeof(mesg));            read(fd[0], mesg, sizeof(mesg));        //从管道另一端读数据            printf(&quot;%s\n&quot;, mesg);            j++;        }    }    return 0;}</code></pre><h5 id="命名管道（FIFO）"><a href="#命名管道（FIFO）" class="headerlink" title="命名管道（FIFO）"></a>命名管道（FIFO）</h5><ul><li>命名管道，去除了管道只能在父子进程中使用的限制。 </li><li>命名管道创建后就可以使用了，使用方法和匿名管道基本相同。只是使用命名管道时，必须先调用open()将其打开，因为命名管道是一个存在于硬盘的文件，而匿名管道是存在于内存中的特殊文件 </li><li>调用open()打开命名管道的进程可能会被阻塞。但如果同时用读写方式（ O_RDWR）打开，则一定不会导致阻塞；如果以只读方式（ O_RDONLY）打开，则调用open()函数的进程将会被阻塞直到有写方打开管道；同样以写方式（ O_WRONLY）打开也会阻塞直到有读方式打开管道。<br><img src="https://img-blog.csdnimg.cn/2019030121392516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code>     😜Client.c文件，向管道写数据#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#define _PATH_NAME_ &quot;/tmp/file.tmp&quot;#define _SIZE_ 100int main(){    int ret=mkfifo(_PATH_NAME_,S_IFIFO|0666);        //第一个参数是命名管道存储路径，第二个是命名管道的存取权限    if(ret==-1){        printf(&quot;make fifo error\n&quot;);        return 1;    }    char buf[_SIZE_];    memset(buf,&apos;\0&apos;,sizeof(buf));    int fd=open(_PATH_NAME_,O_WRONLY);        //打开命名管道，因为其是硬盘上的文件    while(1)    {        //scanf(&quot;%s&quot;,buf);        fgets(buf,sizeof(buf)-1,stdin);        int ret=write(fd,buf,strlen(buf)+1);        if(ret&lt;0){            printf(&quot;write error&quot;);            break;        }    }    close(fd);    return 0;}      😜Server.c文件，从管道读数据并输出 #include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#define _PATH_NAME &quot;/tmp/file.tmp&quot;#define _SIZE_ 100int main(){    int fd=open(_PATH_NAME,O_RDONLY);    if(fd&lt;0){        printf(&quot;open file error&quot;);        return 1;    }    char buf[_SIZE_];    memset(buf,&apos;\0&apos;,sizeof(buf));    while(1){        int ret=read(fd,buf,sizeof(buf));        if(ret&lt;0){            printf(&quot;read end or error\n&quot;);            break;        }        printf(&quot;%s&quot;,buf);    }    close(fd);    return 0;}</code></pre><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><ul><li><p>消息队列可以独立于读写进程存在，从而避免了FIFO中为了同步管道的打开和关闭可能产生的困难； </p></li><li><p>避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法； </p></li><li><p>读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收. </p><pre><code>int msgget(key_t key, int msgflg);</code></pre><p>ssize_t msgrcv(int msqid, void <em>msgp, size_t msgsz, long msgtyp, int msgflg);<br>int msgsnd(int msqid, const void </em>msgp, size_t msgsz, int msgflg);<br>int msgctl ( int msgqid, int cmd, struct msqid_ds *buf );</p></li></ul><ul><li><p>创建消息队列用系统调用msgget()来实现，这一步工作也被称为消息队列的初始化。 </p></li><li><p>在进行通信时，消息队列的发送和接收分别用系统调用msgsnd()和msgrcv()来实现.。 </p></li><li><p>在需要改变队列的使用权限及其它一些特性时，用msgclt()来实现。 </p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10287879）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10287879）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10287879）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10287879）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10287879）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89</a>)</p><pre><code>     😘msgreceive.c#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msg_st{    long int msg_type;    char text[BUFSIZ];};int main(){    int running = 1;    int msgid = -1;    struct msg_st data;    long int msgtype = 0; //注意1    //建立消息队列    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);    if(msgid == -1)    {        fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno);        exit(EXIT_FAILURE);    }    //从队列中获取消息，直到遇到end消息为止    while(running)    {        if(msgrcv(msgid, (void*)&amp;data, BUFSIZ, msgtype, 0) == -1)        {            fprintf(stderr, &quot;msgrcv failed with errno: %d\n&quot;, errno);            exit(EXIT_FAILURE);        }        printf(&quot;You wrote: %s\n&quot;,data.text);        //遇到end结束        if(strncmp(data.text, &quot;end&quot;, 3) == 0)            running = 0;    }    //删除消息队列    if(msgctl(msgid, IPC_RMID, 0) == -1)    {        fprintf(stderr, &quot;msgctl(IPC_RMID) failed\n&quot;);        exit(EXIT_FAILURE);    }    exit(EXIT_SUCCESS);}    😘msgsend.c文件#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/msg.h&gt;#include &lt;errno.h&gt;#define MAX_TEXT 512struct msg_st{    long int msg_type;    char text[MAX_TEXT];};int main(){    int running = 1;    struct msg_st data;    char buffer[BUFSIZ];    int msgid = -1;    //建立消息队列    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);    if(msgid == -1)    {        fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno);        exit(EXIT_FAILURE);    }    //向消息队列中写消息，直到写入end    while(running)    {        //输入数据        printf(&quot;Enter some text: &quot;);        fgets(buffer, BUFSIZ, stdin);        data.msg_type = 1;    //注意2        strcpy(data.text, buffer);        //向队列发送数据        if(msgsnd(msgid, (void*)&amp;data, MAX_TEXT, 0) == -1)        {            fprintf(stderr, &quot;msgsnd failed\n&quot;);            exit(EXIT_FAILURE);        }        //输入end结束输入        if(strncmp(buffer, &quot;end&quot;, 3) == 0)            running = 0;        sleep(1);    }    exit(EXIT_SUCCESS);}</code></pre><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><ul><li>它是一个计数器，用于为多个进程提供对共享数据对象的访问 </li><li>semget()用于创建一个新信号量或返回一个已有信号量（根据IPCkey） </li><li>semop()用于改变信号量的值，用于对信号量增减操作，即PV操作 </li><li><p>semclt()用于直接控制信号量的值，用于对信号量初始化操作 </p><pre><code>int semget(key_t key, int num_sems, int sem_flags);</code></pre><p>int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);<br>int semctl(int sem_id, int sem_num, int command, …);</p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10243617）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10243617）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10243617）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10243617）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10243617）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10243617%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10243617%EF%BC%89</a>)</p><pre><code>#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/sem.h&gt;union semun{    int val;    struct semid_ds *buf;    unsigned short *arry;};static int sem_id = 0;static int set_semvalue();static void del_semvalue();static int semaphore_p();static int semaphore_v();int main(int argc, char *argv[]){    char message = &apos;X&apos;;    int i = 0;    //创建信号量    sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);    if(argc &gt; 1)    {        //程序第一次被调用，初始化信号量        if(!set_semvalue())        {            fprintf(stderr, &quot;Failed to initialize semaphore\n&quot;);            exit(EXIT_FAILURE);        }        //设置要输出到屏幕中的信息，即其参数的第一个字符        message = argv[1][0];        sleep(2);    }    for(i = 0; i &lt; 10; ++i)    {        //进入临界区        if(!semaphore_p())            exit(EXIT_FAILURE);        //向屏幕中输出数据        printf(&quot;%c&quot;, message);        //清理缓冲区，然后休眠随机时间        fflush(stdout);        sleep(rand() % 3);        //离开临界区前再一次向屏幕输出数据        printf(&quot;%c&quot;, message);        fflush(stdout);        //离开临界区，休眠随机时间后继续循环        if(!semaphore_v())            exit(EXIT_FAILURE);        sleep(rand() % 2);    }    sleep(10);    printf(&quot;\n%d - finished\n&quot;, getpid());    if(argc &gt; 1)    {        //如果程序是第一次被调用，则在退出前删除信号量        sleep(3);        del_semvalue();    }    exit(EXIT_SUCCESS);}static int set_semvalue(){    //用于初始化信号量，在使用信号量前必须这样做    union semun sem_union;    sem_union.val = 1;    if(semctl(sem_id, 0, SETVAL, sem_union) == -1)        return 0;    return 1;}static void del_semvalue(){    //删除信号量    union semun sem_union;    if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)        fprintf(stderr, &quot;Failed to delete semaphore\n&quot;);}static int semaphore_p(){    //对信号量做减1操作，即等待P（sv）    struct sembuf sem_b;    sem_b.sem_num = 0;    sem_b.sem_op = -1;//P()    sem_b.sem_flg = SEM_UNDO;    if(semop(sem_id, &amp;sem_b, 1) == -1)    {        fprintf(stderr, &quot;semaphore_p failed\n&quot;);        return 0;    }    return 1;}static int semaphore_v(){    //这是一个释放操作，它使信号量变为可用，即发送信号V（sv）    struct sembuf sem_b;    sem_b.sem_num = 0;    sem_b.sem_op = 1;//V()    sem_b.sem_flg = SEM_UNDO;    if(semop(sem_id, &amp;sem_b, 1) == -1)    {        fprintf(stderr, &quot;semaphore_v failed\n&quot;);        return 0;    }    return 1;}</code></pre><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><ul><li><p>允许多个进程共享一个给定的存储区 </p></li><li><p>因为数据不需要进程之间的复制，而是直接访问内存，所以这是最快的一种IPC。 </p></li><li><p>由于共享内存并不提供同步操作，所以在使用共享内存这种通信方式时，需要借助其他手段进行进程间的同步工作，可以使用信号量等 </p></li><li><p>shmget()用来创建共享内存，返回一个与key相关的共享内存标识符 </p></li><li><p>shmat()用来启动对共享内存的访问，并把共享内存连接到当前进程的地址空间（第一次创建完共享内存时，还不能被任何进程访问），返回指向共享内存的指针 </p></li><li><p>shmclt()用来控制共享内存，与信号量的semclt()函数一样 </p></li><li><p>shmdt()用于将共享内存从当前进程中分离，注意分离不等于删除共享内存 </p><pre><code>int shmget(key_t key, size_t size, int shmflg);</code></pre><p>void <em>shmat(int shm_id, const void </em>shm_addr, int shmflg);<br>int shmctl(int shm_id, int command, struct shmid_ds <em>buf);<br>int shmdt(const void </em>shmaddr);</p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10253345）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10253345）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10253345）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10253345）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10253345）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10253345%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10253345%EF%BC%89</a>)</p><pre><code>      😀shmdata.h文件，定义共享内存结构//shmdata.h文件，定义共享内存结构#ifndef _SHMDATA_H_HEADER#define _SHMDATA_H_HEADER #define TEXT_SZ 2048struct shared_use_st{    int written;//作为一个标志，非0：表示可读，0表示可写    char text[TEXT_SZ];//记录写入和读取的文本};#endif    😀shmread.c文件，创建共享内存，并读取其中信息#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include &quot;shmdata.h&quot;int main(){    int running = 1;//程序是否继续运行的标志    void *shm = NULL;//分配的共享内存的原始首地址    struct shared_use_st *shared;//指向shm    int shmid;//共享内存标识符    //创建共享内存    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);    if(shmid == -1)    {        fprintf(stderr, &quot;shmget failed\n&quot;);        exit(EXIT_FAILURE);    }    //将共享内存连接到当前进程的地址空间    shm = shmat(shmid, 0, 0);    if(shm == (void*)-1)    {        fprintf(stderr, &quot;shmat failed\n&quot;);        exit(EXIT_FAILURE);    }    printf(&quot;\nMemory attached at %X\n&quot;, (int)shm);    //设置共享内存    shared = (struct shared_use_st*)shm;    shared-&gt;written = 0;    while(running)//读取共享内存中的数据    {        //没有进程向共享内存定数据有数据可读取        if(shared-&gt;written != 0)        {            printf(&quot;You wrote: %s&quot;, shared-&gt;text);            sleep(rand() % 3);            //读取完数据，设置written使共享内存段可写            shared-&gt;written = 0;            //输入了end，退出循环（程序）            if(strncmp(shared-&gt;text, &quot;end&quot;, 3) == 0)                running = 0;        }        else//有其他进程在写数据，不能读取数据            sleep(1);    }    //把共享内存从当前进程中分离    if(shmdt(shm) == -1)    {        fprintf(stderr, &quot;shmdt failed\n&quot;);        exit(EXIT_FAILURE);    }    //删除共享内存    if(shmctl(shmid, IPC_RMID, 0) == -1)    {        fprintf(stderr, &quot;shmctl(IPC_RMID) failed\n&quot;);        exit(EXIT_FAILURE);    }    exit(EXIT_SUCCESS);}    😀shmwrite.c文件，向共享内存写入数据#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &quot;shmdata.h&quot;int main(){    int running = 1;    void *shm = NULL;    struct shared_use_st *shared = NULL;    char buffer[BUFSIZ + 1];//用于保存输入的文本    int shmid;    //创建共享内存    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);    if(shmid == -1)    {        fprintf(stderr, &quot;shmget failed\n&quot;);        exit(EXIT_FAILURE);    }    //将共享内存连接到当前进程的地址空间    shm = shmat(shmid, (void*)0, 0);    if(shm == (void*)-1)    {        fprintf(stderr, &quot;shmat failed\n&quot;);        exit(EXIT_FAILURE);    }    printf(&quot;Memory attached at %X\n&quot;, (int)shm);    //设置共享内存    shared = (struct shared_use_st*)shm;    while(running)//向共享内存中写数据    {        //数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本        while(shared-&gt;written == 1)        {            sleep(1);            printf(&quot;Waiting...\n&quot;);        }        //向共享内存中写入数据        printf(&quot;Enter some text: &quot;);        fgets(buffer, BUFSIZ, stdin);        strncpy(shared-&gt;text, buffer, TEXT_SZ);        //写完数据，设置written使共享内存段可读        shared-&gt;written = 1;        //输入了end，退出循环（程序）        if(strncmp(buffer, &quot;end&quot;, 3) == 0)            running = 0;    }    //把共享内存从当前进程中分离    if(shmdt(shm) == -1)    {        fprintf(stderr, &quot;shmdt failed\n&quot;);        exit(EXIT_FAILURE);    }    sleep(2);    exit(EXIT_SUCCESS);}</code></pre><h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><ul><li><p>与其它通信机制不同的是，它可用于不同机器间的进程通信 </p></li><li><p>因特网提供了两种通信机制：流（stream）和数据报（datagram），因而套接字的类型也就分为流套接字和数据报套接字。 </p></li><li><p>一种套接字域是AF_INET，它指的是Internet网络，结构中有IP地址和端口 </p></li><li><p>另一种域AF_UNIX，表示UNIX文件系统，它就是文件输入/输出，结构中有文件路径名 </p></li><li><p>socket()用于创建一个套接字，三个参数分别为套接字域、通信机制、协议类型 </p></li><li><p>bind()函数把通过socket调用创建的套接字命名，从而让它可以被其他进程使用。对于AF_UNIX，调用该函数后套接字就会关联到一个文件系统路径名，对于AF_INET，则会关联到一个IP端口号 </p></li><li><p>listen()用来创建一个队列来保存未处理的请求 </p></li><li><p>accept()用来等待客户建立对该套接字的连接，阻塞直到有客户建立连接 </p></li><li><p>connect()用来让客户程序通过在一个未命名套接字和服务器监听套接字之间建立连接的方法来连接到服务器 </p></li><li><p>close()用来终止服务器和客户上的套接字连接，我们应该总是在连接的两端（服务器和客户）关闭套接字 </p><pre><code>int socket(int domain, int type, int protocol);</code></pre><p>int bind( int socket, const struct sockaddr <em>address, size_t address_len);<br>int listen(int socket, int backlog);<br>int accept(int socket, struct sockaddr </em>address, size_t <em>address_len);<br>int connect(int socket, const struct sockaddr </em>address, size_t address_len);</p></li></ul><h6 id="示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10477427）"><a href="#示例代码（来自-https-blog-csdn-net-ljianhui-article-details-10477427）" class="headerlink" title="示例代码（来自 [ https://blog.csdn.net/ljianhui/article/details/10477427）"></a>示例代码（来自 [ <a href="https://blog.csdn.net/ljianhui/article/details/10477427）" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10477427）</a></h6><p>](<a href="https://blog.csdn.net/ljianhui/article/details/10477427%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/10477427%EF%BC%89</a>)</p><pre><code>     😡sockserver.c文件，服务器端#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int server_sockfd = -1;    int client_sockfd = -1;    int client_len = 0;    struct sockaddr_in server_addr;    struct sockaddr_in client_addr;    //创建流套接字    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);    //设置服务器接收的连接地址和监听的端口    server_addr.sin_family = AF_INET;//指定网络套接字    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//接受所有IP地址的连接    server_addr.sin_port = htons(9736);//绑定到9736端口    //绑定（命名）套接字    bind(server_sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));    //创建套接字队列，监听套接字    listen(server_sockfd, 5);    //忽略子进程停止或退出信号    signal(SIGCHLD, SIG_IGN);    while(1)    {        char ch = &apos;\0&apos;;        client_len = sizeof(client_addr);        printf(&quot;Server waiting\n&quot;);        //接受连接，创建新的套接字        client_sockfd = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len);        if(fork() == 0)        {            //子进程中，读取客户端发过来的信息，处理信息，再发送给客户端            read(client_sockfd, &amp;ch, 1);            sleep(5);            ch++;            write(client_sockfd, &amp;ch, 1);            close(client_sockfd);            exit(0);        }        else        {            //父进程中，关闭套接字            close(client_sockfd);        }    }}    😡sockclient.c文件，客户端#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int sockfd = -1;    int len = 0;    struct sockaddr_in address;    int result;    char ch = &apos;A&apos;;    //创建流套接字    sockfd = socket(AF_INET, SOCK_STREAM, 0);    //设置要连接的服务器的信息    address.sin_family = AF_INET;//使用网络套接字    address.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//服务器地址    address.sin_port = htons(9736);//服务器所监听的端口    len = sizeof(address);    //连接到服务器    result = connect(sockfd, (struct sockaddr*)&amp;address, len);    if(result == -1)    {        perror(&quot;ops:client\n&quot;);        exit(1);    }    //发送请求给服务器    write(sockfd, &amp;ch, 1);    //从服务器获取数据    read(sockfd, &amp;ch, 1);    printf(&quot;char form server = %c\n&quot;, ch);    close(sockfd);    exit(0);}</code></pre><h5 id="关于System-V-IPC"><a href="#关于System-V-IPC" class="headerlink" title="关于System V IPC"></a>关于System V IPC</h5><p>System V IPC指的是AT&amp;T在System V.2发行版中引入的三种进程间通信工具：</p><ol><li>信号量，用来管理对共享资源的访问 </li><li>共享内存，用来高效地实现进程间的数据共享 共享内存，用来高效地实现进程间的数据共享 </li><li>消息队列，用来实现进程间数据的传递。 </li></ol><p>我们把这三种工具统称为System V<br>IPC的对象，每个对象都具有一个唯一的IPC标识符(identifier)。要保证不同的进程能够获取同一个IPC对象，必须提供一个IPC关键字(IPC<br>key)，内核负责把IPC关键字转换成IPC标识符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88071041&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程通信" scheme="https://enpong.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---进程同步经典问题</title>
    <link href="https://enpong.github.io/2019/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://enpong.github.io/2019/03/01/操作系统---进程同步经典问题/</id>
    <published>2019-03-01T12:43:04.000Z</published>
    <updated>2019-04-09T07:59:17.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full<br>记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full<br>信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行<br>down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty =<br>0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为<br>0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><pre><code>#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer(){    while(TRUE){        int item = produce_item();        down(&amp;empty);        down(&amp;mutex);        insert_item(item);        up(&amp;mutex);        up(&amp;full);    }}void consumer(){    while(TRUE){        down(&amp;full);        down(&amp;mutex);        int item = remove_item();        consume_item(item);        up(&amp;mutex);        up(&amp;empty);    }}</code></pre><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex<br>用于对读写的数据加锁。</p><ul><li>读者优先策略：当读者进行读取时，如果后面一直有读者进入，那么写者就会阻塞，直到所有读者完成之后，写者才可以进入。 </li></ul><pre><code>typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void writer(){    while(TRUE){        down(&amp;data_mutex);        write();        up(&amp;data_mutex);    }}void reader(){    while(TRUE){        down(&amp;count_mutex);        if(count==0)            down(&amp;data_mutex);//如果是第一个读者，阻塞写者        count++;        up(&amp;count_mutex);        read();        down(&amp;count_mutex);        count--;        if(count==0)            up(&amp;data_mutex);//最后一个读者出来，释放写者        up(&amp;count_mutex);    }}</code></pre><ul><li>写者优先：置一个WriterMutex信号量来实现优先读。我们可以看到，当有写者进入时，通过P(WriterMutex)阻塞了读者 </li></ul><pre><code>typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;semaphore write_mutex = 1;//实现写者优先int count = 0;void writer(){    while(TRUE){        down(&amp;write_mutex);        down(&amp;data_mutex);        write();        up(&amp;data_mutex);        up(&amp;write_mutex);    }}void reader(){    while(TRUE){        down(&amp;write_mutex);//无写者进入时        down(&amp;count_mutex);        if(count==0)            down(&amp;data_mutex);//如果是第一个读者，阻塞写者        count++;        up(&amp;write_mutex);//恢复对共享资源的访问        up(&amp;count_mutex);        read();        down(&amp;count_mutex);        count--;        if(count==0)            up(&amp;data_mutex);//最后一个读者出来，释放写者        up(&amp;count_mutex);    }}</code></pre><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>五个哲学家（A~E）围着一张圆桌就餐，他们每个人面前都有一盘通心粉。由于通心粉很滑，所以需要两只筷子才能夹住，但每两个盘子之间只放着一只筷子，如下图。<br>哲学家只有两个动作：要么就餐，要么思考。而且他们之间从不交谈。<br>当一个哲学家饿了的时候，就拿起盘子左右两边的筷子开始就餐（不能同时拿起两只筷子）。就餐完以后，就把筷子放回盘子左右，继续思考。<br>由于他们之间互不交谈，所以很容易出现“死锁”：假如每个人都拿着左边的筷子，则所有人都在等右边的筷子，谁都吃不了。<br><img src="https://img-blog.csdnimg.cn/20190301203327590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了防止死锁的发生，可以设置两个条件：</p><p>必须同时拿起左右两根筷子；<br>只有在两个邻居都没有进餐的情况下才允许进餐。</p><pre><code>#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N    // 右邻居#define THINKING 0#define HUNGRY   1#define EATING   2typedef int semaphore;int state[N];                // 跟踪每个哲学家的状态semaphore mutex = 1;         // 临界区的互斥semaphore s[N];              // 每个哲学家一个信号量void philosopher(int i) {    while(TRUE) {        think();        take_two(i);        eat();        put_two(i);    }}void take_two(int i) {    down(&amp;mutex);    state[i] = HUNGRY;    test(i);    up(&amp;mutex);    down(&amp;s[i]);}void put_two(i) {    down(&amp;mutex);    state[i] = THINKING;    test(LEFT);    test(RIGHT);    up(&amp;mutex);}void test(i) {         // 尝试拿起两把筷子    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) {        state[i] = EATING;        up(&amp;s[i]);    }}</code></pre><ul><li>其他解决方案（ <a href="https://blog.csdn.net/Sunflowerfiona/article/details/52756819%EF%BC%89" target="_blank" rel="noopener"> https://blog.csdn.net/Sunflowerfiona/article/details/52756819） </a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生产者-消费者问题&quot;&gt;&lt;a href=&quot;#生产者-消费者问题&quot; class=&quot;headerlink&quot; title=&quot;生产者-消费者问题&quot;&gt;&lt;/a&gt;生产者-消费者问题&lt;/h3&gt;&lt;p&gt;问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲
      
    
    </summary>
    
      <category term="操作系统" scheme="https://enpong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程同步" scheme="https://enpong.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>SSM---对Spring的理解</title>
    <link href="https://enpong.github.io/2019/03/01/SSM---%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://enpong.github.io/2019/03/01/SSM---对Spring的理解/</id>
    <published>2019-03-01T06:24:16.000Z</published>
    <updated>2019-04-09T07:59:16.987Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：Enpong之家 <a href="https://blog.csdn.net/qq_40005950/article/details/88057759" target="_blank" rel="noopener">https://blog.csdn.net/qq_40005950/article/details/88057759</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Spring是一个开源框架，为简化企业级应用开发而生。Spring可以是使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和<br>AOP容器框架。</p><h3 id="主要核心"><a href="#主要核心" class="headerlink" title="主要核心"></a>主要核心</h3><ul><li>控制反转（IOC），传统的Java开发模式中，当需要一个对象时，我们会自己使用new或者getInstance等直接或者间接调用构造方法创建一个对象，而在Spring开发模式中，spring容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring提供的对象就可以了，这是控制反转的思想。控制反转主要的实现方式有两种：依赖查找、依赖注入。 </li><li>依赖注入（DI），spring使用JavaBean对象的set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。 </li><li>面向切面编程（AOP），在面向对象编程(oop)思想中，我们将事物纵向抽成一个个对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事务管理、记录日志等公用操作处理的过程就是面向切面编程的思想。AOP底层是动态代理，如果是接口采用JDK动态代理，如果是类采用CGLIB方式实现动态代理。 </li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://img-blog.csdnimg.cn/20190301134638454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDA1OTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>spring由20多个模块组成，可以分为数据访问/集成、Web、面向切面编程、应用服务器设备管理、消息发送、核心容器和测试</p><ol><li>Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换和常用的工具类； </li><li>Beans模块：提供框架的基础部分，包括控制反转和依赖注入。其中BeanFactory是容器核心。 </li><li>Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化等；核心接口是ApplicationContext。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版权声明：Enpong之家 &lt;a href=&quot;https://blog.csdn.net/qq_40005950/article/details/88057759&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/q
      
    
    </summary>
    
      <category term="ssm" scheme="https://enpong.github.io/categories/ssm/"/>
    
    
      <category term="spring" scheme="https://enpong.github.io/tags/spring/"/>
    
      <category term="IOC" scheme="https://enpong.github.io/tags/IOC/"/>
    
      <category term="AOP" scheme="https://enpong.github.io/tags/AOP/"/>
    
  </entry>
  
</feed>
